






Started logging.

<<<
Content-Length: 3083

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":14189,"clientInfo":{"name":"vscode","version":"1.50.0"},"rootPath":"/home/manos/Documents/IOT_SmartHelmet_project/Esp_Master","rootUri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master","name":"Esp_Master"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 7191

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","languageId":"cpp","version":1,"text":"//#include <Arduino.h>\n// For IMU\n#include <Adafruit_LSM6DS33.h>\n#include <Adafruit_Sensor.h>\n\n//For WiFi and TwoWayCom\n#include <esp_now.h>\n#include <WiFi.h>\n\n//  Create sensor object\nAdafruit_LSM6DS33 imu;\n\n//  Create sensor object\nsensors_event_t a,g,temp;\nfloat accX, accY, accZ,\n      accRoll,      accPitch,     accYaw;            // units degrees (roll and pitch noisy, yaw not possible)\n\n\n// LDR sensor pin\nconst int ldrPin=34;\n// Flashed pins\nconst int rightPin=13;\nconst int leftPin=14;\nconst int lightPin=12;\nint lightInit; // initial value\n//Receiver MAC Address\n//C4:4F:33:6B:0F:E1\nuint8_t broadcastAddress[] = {0xC4, 0x4F, 0x33, 0x6B, 0x0F, 0xE1};\n\n// Define the struct that contains the message content\n// for our purposes we import the accelerometer readings \ntypedef struct masterMessage {\n  float roll;\n  float pitch;\n  int lightSensor;\n} masterMessage;\n\ntypedef struct receivedMessage{\n  bool imuUsage;\n  //String rec_message;\n}receivedMessage;\n\n// Define the masterMessage\nmasterMessage msgToSlave;\n// TO_DO -> Change the struct because we will get different content (ie, pin to trigger the flashes)\nreceivedMessage messageFromSlave;\n\n// String receivedString; \n// Variable to store if sending data was successful\nString success;\n// Should be global ... ( TODO -> Check why ???)\nesp_now_peer_info_t peerInfo;\n\nvoid initESPNOW(){\n  WiFi.mode(WIFI_MODE_STA);\n  Serial.println(WiFi.macAddress());\n  // Init ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n\n  // Once ESPNow is successfully Init, we will register for Send CB to\n  // get the status of Trasnmitted packet\n  esp_now_register_send_cb(OnDataSent);\n  \n  // Register peer\n  //esp_now_peer_info_t peerInfo;\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;  \n  peerInfo.encrypt = false;\n  \n  // Add peer        \n  if (esp_now_add_peer(&peerInfo) != ESP_OK){\n    Serial.println(\"Failed to add peer\");\n    return;\n  }\n  // Register for a callback function that will be called when data is received\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\n\nvoid initIMU(){\n  while (!Serial)\n    delay(10); // will pause Zero, Leonardo, etc until serial console opens\n\n  Serial.println(\"Adafruit LSM6DS33 test!\");\n\n  if (!imu.begin_I2C()) {\n    // if (!lsm6ds33.begin_SPI(LSM_CS)) {\n    // if (!lsm6ds33.begin_SPI(LSM_CS, LSM_SCK, LSM_MISO, LSM_MOSI)) {\n    Serial.println(\"Failed to find LSM6DS33 chip\");\n    while (1) {\n      delay(10);\n    }\n  }  \n  Serial.println(\"Adafruit LSM6DS33 FOUND!\");\n}\n\nvoid initLDRSensor(){\n  //we will take a single reading from the light sensor and store it in the lightCal        \n  //variable. This will give us a prelinary value to compare against in the loop\n  pinMode(ldrPin, INPUT);\n  // lightInit=analogRead(ldrPin);\n}\n\nvoid serialPrint(){\n  Serial.print(\"X: \");\n  Serial.print(accX);\n  Serial.print(\"  Y: \");\n  Serial.print(accY);\n  Serial.print(\"  Z: \");\n  Serial.print(accZ);\n  Serial.print(\"  Roll: \");\n  Serial.print(msgToSlave.roll);\n  Serial.print(\"  Pitch: \");\n  Serial.print(msgToSlave.pitch);\n  Serial.print(\"  Light: \");\n  Serial.print(msgToSlave.lightSensor);\n  Serial.println();\n\n}\n\nvoid serialPlotter(){\n  // Serial.print(accX);\n  // Serial.print(accY);\n  // Serial.print(accZ);\n  Serial.print(msgToSlave.roll);\n  Serial.print(\"\\t\");\n  Serial.println(msgToSlave.pitch);\n  \n  // Serial.print(\"  Light: \");\n  // Serial.print(msgToSlave.lightSensor);\n  // Serial.println();\n\n}\n\n// Callback Function that sents message\nvoid OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status){\n  //Serial.print(\"\\r\\nLast Packet Send Status:\\t\");\n  //Serial.println(status == ESP_NOW_SEND_SUCCESS ? \"Delivery Success\" : \"Delivery Fail\");\n  if (status == 0){\n    success = \"Delivery Success :)\";\n  }\n  else{\n    success = \"Delivery Fail :(\";\n  }\n}\n// Callback Function that triggered when a new packet arrives\nvoid OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len){\n  memcpy(&messageFromSlave,incomingData, sizeof(messageFromSlave));\n  //Just for debug\n  //Serial.print(\"Bytes received: \");\n  //Serial.println(len);\n\n  // Write the data that have been sent\n  // receivedString = messageFromSlave.rec_message;\n  \n}\nvoid getAccReadings(){\n  imu.getEvent(&a, &g, &temp);\n  // Get current acceleration values\n  accX = a.acceleration.x;\n  accY = a.acceleration.y;\n  accZ = a.acceleration.z;\n}\n\n\nvoid getLDRReadings(){\n  // Read the current light Levels\n  // lightInit=\n  msgToSlave.lightSensor=analogRead(ldrPin);\n}\n\nvoid doCalculations() {\n  /*\n  Calculate Roll and pitch and save them into the structure message\n  */\n  msgToSlave.roll = atan2(accY, accZ) * 180/M_PI;\n  msgToSlave.pitch = atan2(-accX, sqrt(accY*accY + accZ*accZ)) * 180/M_PI;\n}\n\nvoid blinking(int pin){\n  /*\n  Blinking the alarm 5 times (about 1 second procedure)\n  */\n  for(int k=0; k<=5; k++){\n    digitalWrite(pin,HIGH);\n    vTaskDelay(200/portTICK_PERIOD_MS);\n    // delay(200);\n    digitalWrite(pin,LOW);\n    // delay(300);\n    vTaskDelay(300/portTICK_PERIOD_MS);\n    \n  }\n}\n\nvoid checkAlarms(){\n  if (msgToSlave.lightSensor< 800){\n    digitalWrite(lightPin,HIGH);\n  }else{\n    digitalWrite(lightPin,LOW);\n  \n  }\n  if (msgToSlave.roll<-30){\n    //Enable Ligh LEFT\n    blinking(leftPin);\n  }\n  else if (msgToSlave.roll>30){\n    // Enable light Right     \n    blinking(rightPin);\n  }\n  \n}\n\n\nvoid task1(void * parameters){\n  for(;;){\n    Serial.print(\"Task 1\");\n    //Get accelation readings\n    getAccReadings();\n    getLDRReadings();\n    doCalculations();\n    \n    // Send message via ESP-NOW\n    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *) &msgToSlave, sizeof(msgToSlave));\n    \n    if (result == ESP_OK) {\n      // Serial.println(\"Sent with success\");\n    }\n    else {\n      // Serial.println(\"Error sending the data\");\n    }\n    // Delay should be reduced ? \n    // serialPrint();\n    serialPlotter();\n    checkAlarms();\n    vTaskDelay(500/portTICK_PERIOD_MS);\n  }\n}\n\nvoid task2(void * parameters){\n  for(;;){\n    checkAlarms();\n    vTaskDelay(500/portTICK_PERIOD_MS);\n  }\n}\n\nvoid setup(){\n  Serial.begin(115200);\n  initIMU();\n  initLDRSensor();\n  initESPNOW();\n\n  // Init alarms\n  pinMode(leftPin,OUTPUT);\n  pinMode(rightPin, OUTPUT);\n  pinMode(lightPin,OUTPUT);\n\n  xTaskCreate(\n    task1, // function name\n    \"Task1\", // task name\n    2000, // stack size\n    NULL, // task parameters \n    1, // task priority\n    NULL // task handle\n    );\n  delay(500);\n  xTaskCreate(\n    task2, // function name\n    \"Task2\", // task name\n    1000, // stack size\n    NULL, // task parameters \n    1, // task priority\n    NULL // task handle\n    );\n}\n\n\n\nvoid loop(){\n\n}\n"}}}Content-Length: 282

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":2},"end":{"line":116,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/62","percentage":4.838709677419355,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/62","percentage":6.451612903225806,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/62","percentage":6.451612903225806,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/62","percentage":8.064516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/62","percentage":8.064516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 157

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/62","percentage":9.67741935483871,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/62","percentage":11.290322580645162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/62","percentage":11.290322580645162,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/62","percentage":12.903225806451612,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/62","percentage":12.903225806451612,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/62","percentage":14.516129032258064,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/62","percentage":14.516129032258064,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/62","percentage":16.129032258064516,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/62","percentage":16.129032258064516,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/62","percentage":17.741935483870968,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/62","percentage":19.35483870967742,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/62","percentage":19.35483870967742,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/62","percentage":20.967741935483872,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/62","percentage":20.967741935483872,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/62","percentage":22.580645161290324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/62","percentage":22.580645161290324,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/62","percentage":24.193548387096776,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/62","percentage":24.193548387096776,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/62","percentage":25.806451612903224,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/62","percentage":25.806451612903224,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/62","percentage":27.419354838709676,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/62","percentage":29.032258064516128,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/62","percentage":29.032258064516128,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/62","percentage":30.64516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/62","percentage":30.64516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/62","percentage":32.25806451612903,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/62","percentage":32.25806451612903,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/62","percentage":33.87096774193548,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/62","percentage":33.87096774193548,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/62","percentage":35.483870967741936,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/62","percentage":35.483870967741936,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/62","percentage":37.096774193548384,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/62","percentage":38.70967741935484,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/62","percentage":38.70967741935484,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/62","percentage":40.32258064516129,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/62","percentage":40.32258064516129,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/62","percentage":41.935483870967744,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/62","percentage":41.935483870967744,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/62","percentage":43.54838709677419,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/62","percentage":43.54838709677419,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/62","percentage":45.16129032258065,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/62","percentage":46.774193548387096,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/62","percentage":46.774193548387096,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/62","percentage":48.38709677419355,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/62","percentage":48.38709677419355,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/62","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/62","percentage":51.61290322580645,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/62","percentage":51.61290322580645,"kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":2},"contentChanges":[{"range":{"start":{"line":113,"character":2},"end":{"line":116,"character":27}},"rangeLength":115,"text":"v"}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":3},"contentChanges":[{"range":{"start":{"line":113,"character":3},"end":{"line":113,"character":3}},"rangeLength":0,"text":" "}]}}Content-Length: 281

{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":2,"result":[],"jsonrpc":"2.0"}Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 176

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":3}}}Content-Length: 281

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":1,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":1,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/62","percentage":53.225806451612904,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/62","percentage":54.83870967741935,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/62","percentage":54.83870967741935,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/62","percentage":56.45161290322581,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/62","percentage":56.45161290322581,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/62","percentage":58.064516129032256,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"37/62","percentage":59.67741935483871,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"38/62","percentage":61.29032258064516,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"38/62","percentage":61.29032258064516,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"39/62","percentage":62.903225806451616,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"39/62","percentage":62.903225806451616,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"40/62","percentage":64.51612903225806,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"40/62","percentage":64.51612903225806,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"41/62","percentage":66.12903225806451,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"41/62","percentage":66.12903225806451,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"42/62","percentage":67.74193548387096,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"42/62","percentage":67.74193548387096,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"43/62","percentage":69.35483870967742,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"43/62","percentage":69.35483870967742,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"44/62","percentage":70.96774193548387,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"44/62","percentage":70.96774193548387,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"45/62","percentage":72.58064516129032,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"45/62","percentage":72.58064516129032,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"46/62","percentage":74.19354838709677,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"46/62","percentage":74.19354838709677,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"47/62","percentage":75.80645161290323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"47/62","percentage":75.80645161290323,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"48/62","percentage":77.41935483870968,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"48/62","percentage":77.41935483870968,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"49/62","percentage":79.03225806451613,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"49/62","percentage":79.03225806451613,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"50/62","percentage":80.64516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"50/62","percentage":80.64516129032258,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"51/62","percentage":82.25806451612904,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"51/62","percentage":82.25806451612904,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"52/62","percentage":83.87096774193549,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"52/62","percentage":83.87096774193549,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"53/62","percentage":85.48387096774194,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"53/62","percentage":85.48387096774194,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"54/62","percentage":87.09677419354838,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"54/62","percentage":87.09677419354838,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"55/62","percentage":88.70967741935483,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"55/62","percentage":88.70967741935483,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"56/62","percentage":90.3225806451613,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"56/62","percentage":90.3225806451613,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"57/62","percentage":91.93548387096774,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"57/62","percentage":91.93548387096774,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"58/62","percentage":93.54838709677419,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"58/62","percentage":93.54838709677419,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"59/62","percentage":95.16129032258064,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"60/62","percentage":96.7741935483871,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"61/62","percentage":98.38709677419355,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 2958

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":10,"character":0},"end":{"line":10,"character":17}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Adafruit_LSM6DS33'"},{"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":15}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'sensors_event_t'"},{"range":{"start":{"line":27,"character":0},"end":{"line":27,"character":7}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'uint8_t'"},{"range":{"start":{"line":49,"character":0},"end":{"line":49,"character":6}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'String'"},{"range":{"start":{"line":51,"character":0},"end":{"line":51,"character":19}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'esp_now_peer_info_t'"},{"range":{"start":{"line":54,"character":2},"end":{"line":54,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'WiFi'"},{"range":{"start":{"line":54,"character":12},"end":{"line":54,"character":25}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'WIFI_MODE_STA'"},{"range":{"start":{"line":55,"character":2},"end":{"line":55,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Serial'"},{"range":{"start":{"line":55,"character":17},"end":{"line":55,"character":21}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'WiFi'"},{"range":{"start":{"line":57,"character":6},"end":{"line":57,"character":18}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'esp_now_init'"},{"range":{"start":{"line":57,"character":24},"end":{"line":57,"character":30}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'ESP_OK'"},{"range":{"start":{"line":58,"character":4},"end":{"line":58,"character":10}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Serial'"},{"range":{"start":{"line":73,"character":37},"end":{"line":73,"character":43}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'ESP_OK'"},{"range":{"start":{"line":74,"character":4},"end":{"line":74,"character":10}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Serial'"},{"range":{"start":{"line":83,"character":10},"end":{"line":83,"character":16}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Serial'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 281

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 208

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":139,"character":32}}}
>>>
Content-Length: 38

{"id":5,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":130,"character":22},"end":{"line":130,"character":22}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":6,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 208

{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":222,"character":18}}}
>>>
Content-Length: 283

{"id":7,"result":{"contents":{"kind":"markdown","value":"### variable `result`  \n\n---\nType: `int`  \nSend message via ESP-NOW  \n\n---\n```cpp\n// In task1\npublic: int result\n```"},"range":{"start":{"line":257,"character":14},"end":{"line":257,"character":20}}},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":8,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":234,"character":18}}}
>>>
Content-Length: 36

{"id":8,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":9,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":234,"character":18},"end":{"line":234,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":9,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","id":10,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":3},"end":{"line":235,"character":3}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":10,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":4},"contentChanges":[{"range":{"start":{"line":235,"character":3},"end":{"line":235,"character":3}},"rangeLength":0,"text":"\n  "}]}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":2,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":2,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":5},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"s"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":11,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":3},"context":{"triggerKind":1}}}
>>>
Content-Length: 42980

{"id":11,"result":{"isIncomplete":true,"items":[{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPlotter()"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setup()"}},{"label":" success","kind":6,"detail":"int","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3f2cccccsuccess","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"success"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"406433bdSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"406433bdSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_EN"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"4066be48size_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"size_t"}},{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40762d8dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Serial"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"407b01f1String","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"String"}},{"label":"sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"408e069asensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_event_t"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"408f437fStream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Stream"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"409a8b50strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlen(${1:const char *})"}},{"label":"sockaddr_in","kind":22,"documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`  \nmembers are in network byte order"},"sortText":"409bc15asockaddr_in","filterText":"sockaddr_in","insertText":"sockaddr_in","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sockaddr_in"}},{"label":"SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"409c96d9SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":"SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":"SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_COLOR"}},{"label":"SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":"SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":"SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":"SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":"SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":"SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":"SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":"SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":"SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":"SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":"SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"409c96d9SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":"sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"409c96d9sensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensor_t"}},{"label":"sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"409c96d9sensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_color_t"}},{"label":"sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"409c96d9sensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_type_t"}},{"label":"sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"409c96d9sensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_vec_t"}},{"label":"sockaddr","kind":22,"documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40abeeb4sockaddr","filterText":"sockaddr","insertText":"sockaddr","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sockaddr"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"40ac2d33SDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SDA"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40ac2d33sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40ac2d33sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"40ac2d33sketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sketchSize_t"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40ac2d33spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40ac2d33spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40ac2d33spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40ac2d33spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40ac2d33spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40ac2d33spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40ac2d33spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"40add229STA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STA_CONNECTED_BIT"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"40add229step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"40add229step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_b"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40af2acfSC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40af2acfSC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SNTP_SYNC_MODE_IMMED","kind":20,"detail":"sntp_sync_mode_t","documentation":{"kind":"markdown","value":"From `\"sntp.h\"`  \nUpdate system time immediately when receiving a response from the SNTP server."},"sortText":"40af2acfSNTP_SYNC_MODE_IMMED","filterText":"SNTP_SYNC_MODE_IMMED","insertText":"SNTP_SYNC_MODE_IMMED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SNTP_SYNC_MODE_IMMED"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40af2acfSYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40af2acfSYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40af2acfSYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40af2acfsc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sc_callback_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"scanf(${1:const char *, ...})"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"40af2acfsinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"40af2acfsinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinhf(${1:float})"}},{"label":"siprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsiprintf","filterText":"siprintf","insertText":"siprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"siprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"siscanf(const char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsiscanf","filterText":"siscanf","insertText":"siscanf(${1:const char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"siscanf(${1:const char *}, ${2:const char *, ...})"}},{"label":"sniprintf(char *, size_t, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsniprintf","filterText":"sniprintf","insertText":"sniprintf(${1:char *}, ${2:size_t}, ${3:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sniprintf(${1:char *}, ${2:size_t}, ${3:const char *, ...})"}},{"label":"snprintf(char *, size_t, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsnprintf","filterText":"snprintf","insertText":"snprintf(${1:char *}, ${2:size_t}, ${3:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"snprintf(${1:char *}, ${2:size_t}, ${3:const char *, ...})"}},{"label":"sntp_sync_time(struct timeval *tv)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"sntp.h\"`  \n@brief This function updates the system time.  \nThis is a weak-linked function. It is possible to replace all SNTP update functionality by placing a sntp_sync_time() function in the app firmware source.  \nIf the default implementation is used, calling sntp_set_sync_mode() allows the time synchronization mode to be changed to instant or smooth.  \nIf a callback function is registered via sntp_set_time_sync_notification_cb(),  \nit will be called following time synchronization.  \n@param tv Time received from SNTP server."},"sortText":"40af2acfsntp_sync_time","filterText":"sntp_sync_time","insertText":"sntp_sync_time(${1:struct timeval *tv})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sntp_sync_time(${1:struct timeval *tv})"}},{"label":"spi_flash_guard_get()","kind":3,"detail":"const spi_flash_guard_funcs_t *","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Get the guard functions used for flash access  \n@return The guard functions that were set via spi_flash_guard_set(). These functions can be called if implementing custom low-level SPI flash operations."},"sortText":"40af2acfspi_flash_guard_get","filterText":"spi_flash_guard_get","insertText":"spi_flash_guard_get()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spi_flash_guard_get()"}},{"label":"spi_flash_mmap_get_free_pages(spi_flash_mmap_memory_t memory)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief get free pages number which can be mmap  \nThis function will return number of free pages available in mmu table. This could be useful before calling actual spi_flash_mmap (maps flash range to DCache or ICache memory) to check if there is sufficient space available for mapping.  \n@param memory memory type of MMU table free page  \n@return number of free pages which can be mmaped"},"sortText":"40af2acfspi_flash_mmap_get_free_pages","filterText":"spi_flash_mmap_get_free_pages","insertText":"spi_flash_mmap_get_free_pages(${1:spi_flash_mmap_memory_t memory})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spi_flash_mmap_get_free_pages(${1:spi_flash_mmap_memory_t memory})"}},{"label":"spi_flash_munmap(spi_flash_mmap_handle_t handle)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Release region previously obtained using spi_flash_mmap  \n@note Calling this function will not necessarily unmap memory region.  \nRegion will only be unmapped when there are no other handles which reference this region. In case of partially overlapping regions it is possible that memory will be unmapped partially.  \n@param handle Handle obtained from spi_flash_mmap"},"sortText":"40af2acfspi_flash_munmap","filterText":"spi_flash_munmap","insertText":"spi_flash_munmap(${1:spi_flash_mmap_handle_t handle})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spi_flash_munmap(${1:spi_flash_mmap_handle_t handle})"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"40af2acfsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"sscanf(const char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsscanf","filterText":"sscanf","insertText":"sscanf(${1:const char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sscanf(${1:const char *}, ${2:const char *, ...})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"40af2acfstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strtoimax(const char *, char **, int)","kind":3,"detail":"intmax_t","documentation":{"kind":"markdown","value":"From `\"inttypes.h\"`"},"sortText":"40af2acfstrtoimax","filterText":"strtoimax","insertText":"strtoimax(${1:const char *}, ${2:char **}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strtoimax(${1:const char *}, ${2:char **}, ${3:int})"}},{"label":"strtoumax(const char *, char **, int)","kind":3,"detail":"uintmax_t","documentation":{"kind":"markdown","value":"From `\"inttypes.h\"`"},"sortText":"40af2acfstrtoumax","filterText":"strtoumax","insertText":"strtoumax(${1:const char *}, ${2:char **}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strtoumax(${1:const char *}, ${2:char **}, ${3:int})"}},{"label":"swprintf(wchar_t *, size_t, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"40af2acfswprintf","filterText":"swprintf","insertText":"swprintf(${1:wchar_t *}, ${2:size_t}, ${3:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"swprintf(${1:wchar_t *}, ${2:size_t}, ${3:const wchar_t *, ...})"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"40af2acfswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40af2acfsystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"system_event_cb_t"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40af7a82SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SIGMADELTA"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40af7a82setsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"40b044fcSLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SLEEP_MODE"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"40b044fcSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"SUBNET_MASK","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"40b044fcSUBNET_MASK","filterText":"SUBNET_MASK","insertText":"SUBNET_MASK","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SUBNET_MASK"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"40b044fcSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SemaphoreHandle_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"40b044fcSendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"40b044fcStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StaticSemaphore_t"}},{"label":"s8_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"arch/cc.h\"`"},"sortText":"40b044fcs8_t","filterText":"s8_t","insertText":"s8_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"s8_t"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":6},"contentChanges":[{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":12,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":4},"context":{"triggerKind":3}}}
>>>
Content-Length: 49753

{"id":12,"result":{"isIncomplete":true,"items":[{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setup()"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"initLDRSensor()"}},{"label":" OnDataSent(const int *mac_addr, int status)","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"4013a2a3OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const int *mac_addr}, ${2:int status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"OnDataSent(${1:const int *mac_addr}, ${2:int status})"}},{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40762d8dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial"}},{"label":"sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"408e069asensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_event_t"}},{"label":"sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"409c96d9sensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensor_t"}},{"label":"sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"409c96d9sensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_color_t"}},{"label":"sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"409c96d9sensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_type_t"}},{"label":"sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"409c96d9sensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_vec_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"40ac2d33Server","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Server"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialEventRun()"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40ac2d33setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"40af2acfseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"seed48(${1:unsigned short *})"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"40af2acfsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"40af2acfsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40af7a82setsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"40b044fcSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SemaphoreHandle_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"40b044fcSendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcselect","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsend","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"40b044fcsend_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"40b044fcset_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"set_rtc_memory_crc()"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcsetitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcsettimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40b903feSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":"SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":"SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_COLOR"}},{"label":"SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":"SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":"SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":"SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":"SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":"SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":"SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":"SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":"SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":"SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":"SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":"SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":"SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40ca3c5dSERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SERVER_IDENTIFIER"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"40ca3c5dSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SEVEN_BITS"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"40d1f902set_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"40d1f902set_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"40d1f902set_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"40d2e427search","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"40d2e427search_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"40d2e427seed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_union($0)"}},{"label":"spiEndTransaction(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40e121e7spiEndTransaction","filterText":"spiEndTransaction","insertText":"spiEndTransaction(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"spiEndTransaction(${1:spi_t *spi})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"40e1cb19setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40e3601bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40e3601bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_AP_STAIPASSIGNED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP assign an IP to a connected station"},"sortText":"40e3601bSYSTEM_EVENT_AP_STAIPASSIGNED","filterText":"SYSTEM_EVENT_AP_STAIPASSIGNED","insertText":"SYSTEM_EVENT_AP_STAIPASSIGNED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STAIPASSIGNED"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40e3601bSYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40e3601bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40e3601bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_START","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet start"},"sortText":"40e3601bSYSTEM_EVENT_ETH_START","filterText":"SYSTEM_EVENT_ETH_START","insertText":"SYSTEM_EVENT_ETH_START","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_START"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40e3601bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_SCAN_DONE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 finish scanning AP"},"sortText":"40e3601bSYSTEM_EVENT_SCAN_DONE","filterText":"SYSTEM_EVENT_SCAN_DONE","insertText":"SYSTEM_EVENT_SCAN_DONE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_SCAN_DONE"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40e3601bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40e3601bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40e3601bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_START","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station start"},"sortText":"40e3601bSYSTEM_EVENT_STA_START","filterText":"SYSTEM_EVENT_STA_START","insertText":"SYSTEM_EVENT_STA_START","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_START"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40e3601bSYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"SYSTEM_EVENT_WIFI_READY","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 WiFi ready"},"sortText":"40e3601bSYSTEM_EVENT_WIFI_READY","filterText":"SYSTEM_EVENT_WIFI_READY","insertText":"SYSTEM_EVENT_WIFI_READY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_WIFI_READY"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_id_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"StaticEventGroup_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`  \nIn line with software engineering best practice, especially when supplying a library that is likely to change in future versions, FreeRTOS implements a strict data hiding policy. This means the event group structure used internally by FreeRTOS is not accessible to application code. However, if the application writer wants to statically allocate the memory required to create an event group then the size of the event group object needs to be know. The StaticEventGroup_t structure below is provided for this purpose.  \nIts sizes and alignment requirements are guaranteed to match those of the genuine structure, no matter which architecture is being used, and no matter how the values in FreeRTOSConfig.h are set. Its contents are somewhat obfuscated in the hope users will recognise that it would be unwise to make direct use of the structure members."},"sortText":"40e433bdStaticEventGroup_t","filterText":"StaticEventGroup_t","insertText":"StaticEventGroup_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"StaticEventGroup_t"}},{"label":"sei()","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"413f6ee9sei","filterText":"sei","insertText":"sei()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sei()"}},{"label":" semBINARY_SEMAPHORE_QUEUE_LENGTH","kind":1,"sortText":"41432771semBINARY_SEMAPHORE_QUEUE_LENGTH","filterText":"semBINARY_SEMAPHORE_QUEUE_LENGTH","insertText":"semBINARY_SEMAPHORE_QUEUE_LENGTH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"semBINARY_SEMAPHORE_QUEUE_LENGTH"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":7},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":13,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":5},"context":{"triggerKind":3}}}
>>>
Content-Length: 46071

{"id":13,"result":{"isIncomplete":false,"items":[{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"serialPrint()"}},{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40762d8dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"Serial"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"40ac2d33Server","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"Server"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"serialEventRun()"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40d2e427SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERVER_IDENTIFIER"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"40d2e427set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"set_rtc_memory_crc()"}},{"label":"spi_flash_erase_range(size_t start_address, size_t size)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase a range of flash sectors  \n@param start_address Address where erase operation has to start.  \nMust be 4kB-aligned  \n@param size Size of erased range, in bytes. Must be divisible by 4kB.  \n@return esp_err_t"},"sortText":"40e3601bspi_flash_erase_range","filterText":"spi_flash_erase_range","insertText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})"}},{"label":"spi_flash_erase_sector(size_t sector)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase the Flash sector.  \n@param sector Sector number, the count starts at sector 0, 4KB per sector.  \n@return esp_err_t"},"sortText":"40e3601bspi_flash_erase_sector","filterText":"spi_flash_erase_sector","insertText":"spi_flash_erase_sector(${1:size_t sector})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"spi_flash_erase_sector(${1:size_t sector})"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"4108df65HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"HardwareSerial"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"410c5c9asystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"WiFiServer","kind":7,"documentation":{"kind":"markdown","value":"From `\"WiFiServer.h\"`"},"sortText":"41262898WiFiServer","filterText":"WiFiServer","insertText":"WiFiServer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"WiFiServer"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"412f2acfSYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"412f2acfSYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"412f2acfSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"412f2acfSYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"412f2acfSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"DPORT_SEQUENCE_REG_READ(uint32_t reg)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"soc/dport_access.h\"`  \n@brief Read value from register, NOT SMP-safe version.  \nThis method uses the pre-reading of the APB register before reading the register of the DPORT.  \nThere is not disable/enable interrupt.  \nThe difference from DPORT_REG_READ() is that the user himself must disable interrupts while DPORT reading.  \nThis implementation is useful for reading DORT registers in loop without stall other CPU. Note the usage example.  \nThe recommended way to read registers sequentially without stall other CPU is to use the method esp_dport_read_buffer(buff_out, address, num_words). It allows you to read registers in the buffer.  \n\\\\code{c} // This example shows how to use it.  \n{ // Use curly brackets to limit the visibility of variables in macros DPORT_INTERRUPT_DISABLE/RESTORE.  \nDPORT_INTERRUPT_DISABLE(); // Disable interrupt only on current CPU.  \nfor (i = 0; i \u003c max; ++i) { array[i] = DPORT_SEQUENCE_REG_READ(Address + i * 4); // reading DPORT registers } DPORT_INTERRUPT_RESTORE(); // restore the previous interrupt level }  \n\\\\endcode  \n@param reg Register address  \n@return Value"},"sortText":"413044fbDPORT_SEQUENCE_REG_READ","filterText":"DPORT_SEQUENCE_REG_READ","insertText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})"}},{"label":"dns_clear_servers(bool keep_fallback)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"lwip/dns.h\"`"},"sortText":"413044fcdns_clear_servers","filterText":"dns_clear_servers","insertText":"dns_clear_servers(${1:bool keep_fallback})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"dns_clear_servers(${1:bool keep_fallback})"}},{"label":"rmtSetRxThreshold(rmt_obj_t *rmt, uint32_t value)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-rmt.h\"`  \nSetting threshold for Rx completed"},"sortText":"414f7afermtSetRxThreshold","filterText":"rmtSetRxThreshold","insertText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"414f7afeuartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"COOKIE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427COOKIE_SERVER","filterText":"COOKIE_SERVER","insertText":"COOKIE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"COOKIE_SERVER"}},{"label":"IMPRESS_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427IMPRESS_SERVER","filterText":"IMPRESS_SERVER","insertText":"IMPRESS_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"IMPRESS_SERVER"}},{"label":"LOG_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427LOG_SERVER","filterText":"LOG_SERVER","insertText":"LOG_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"LOG_SERVER"}},{"label":"LPR_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427LPR_SERVER","filterText":"LPR_SERVER","insertText":"LPR_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"LPR_SERVER"}},{"label":"NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427NAME_SERVER","filterText":"NAME_SERVER","insertText":"NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NAME_SERVER"}},{"label":"NAME_SERVICE_SEARCH","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"4152e427NAME_SERVICE_SEARCH","filterText":"NAME_SERVICE_SEARCH","insertText":"NAME_SERVICE_SEARCH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NAME_SERVICE_SEARCH"}},{"label":"NDS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"4152e427NDS_SERVERS","filterText":"NDS_SERVERS","insertText":"NDS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NDS_SERVERS"}},{"label":"NNTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"4152e427NNTP_SERVER","filterText":"NNTP_SERVER","insertText":"NNTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NNTP_SERVER"}},{"label":"SMTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"4152e427SMTP_SERVER","filterText":"SMTP_SERVER","insertText":"SMTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SMTP_SERVER"}},{"label":"STREETTALK_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"4152e427STREETTALK_SERVER","filterText":"STREETTALK_SERVER","insertText":"STREETTALK_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"STREETTALK_SERVER"}},{"label":"SWAP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427SWAP_SERVER","filterText":"SWAP_SERVER","insertText":"SWAP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SWAP_SERVER"}},{"label":"TFTP_SERVER_NAME","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"4152e427TFTP_SERVER_NAME","filterText":"TFTP_SERVER_NAME","insertText":"TFTP_SERVER_NAME","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"TFTP_SERVER_NAME"}},{"label":"TIME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"4152e427TIME_SERVER","filterText":"TIME_SERVER","insertText":"TIME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"TIME_SERVER"}},{"label":"gpio_install_isr_service(int intr_alloc_flags)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers.  \nThis function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.  \n@param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG\\_\\* values. See esp_intr_alloc.h for more info.  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_NO_MEM No memory to install this service  \n\\- ESP_ERR_INVALID_STATE ISR service already installed.  \n\\- ESP_ERR_NOT_FOUND No free interrupt found with the specified flags  \n\\- ESP_ERR_INVALID_ARG GPIO error"},"sortText":"4152e427gpio_install_isr_service","filterText":"gpio_install_isr_service","insertText":"gpio_install_isr_service(${1:int intr_alloc_flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"gpio_install_isr_service(${1:int intr_alloc_flags})"}},{"label":"gpio_uninstall_isr_service()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Uninstall the driver's GPIO ISR service, freeing related resources."},"sortText":"4152e427gpio_uninstall_isr_service","filterText":"gpio_uninstall_isr_service","insertText":"gpio_uninstall_isr_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"gpio_uninstall_isr_service()"}},{"label":"hall_sensor_read()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Read Hall Sensor  \n@note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,  \nthe input of GPIO36 and GPIO39 will be pulled down for about 80ns.  \nWhen enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.  \nPlease refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.  \n@note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure these channels for use as ADC channels.  \n@note The ADC1 module must be enabled by calling adc1_config_width() before calling hall_sensor_read(). ADC1 should be configured for 12 bit readings, as the hall sensor readings are low values and do not cover the full range of the ADC.  \n@return The hall sensor reading."},"sortText":"4152e427hall_sensor_read","filterText":"hall_sensor_read","insertText":"hall_sensor_read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"hall_sensor_read()"}},{"label":"lwip_send_r(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"4152e427lwip_send_r","filterText":"lwip_send_r","insertText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"lwip_sendmsg_r(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"4152e427lwip_sendmsg_r","filterText":"lwip_sendmsg_r","insertText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"lwip_sendto_r(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"4152e427lwip_sendto_r","filterText":"lwip_sendto_r","insertText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"lwip_setsockopt_r(int s, int level, int optname, const void *optval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"4152e427lwip_setsockopt_r","filterText":"lwip_setsockopt_r","insertText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})"}},{"label":"xthal_set_region_attribute(void *addr, unsigned int size, unsigned int cattr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset cache attribute (access modes) for a range of memory"},"sortText":"4152e427xthal_set_region_attribute","filterText":"xthal_set_region_attribute","insertText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})"}},{"label":"xthal_set_region_translation(void *vaddr, void *paddr, unsigned int size, unsigned int cache_atr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"4152e427xthal_set_region_translation","filterText":"xthal_set_region_translation","insertText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})"}},{"label":"xthal_set_region_translation_raw(void *vaddr, void *paddr, unsigned int cattr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"4152e427xthal_set_region_translation_raw","filterText":"xthal_set_region_translation_raw","insertText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})"}},{"label":"SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"415f8716SERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"415f8716SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERIAL_8O2"}},{"label":" esp_dport_access_sequence_reg_read(uint32_t reg)","kind":3,"detail":"uint32_t","sortText":"4163601besp_dport_access_sequence_reg_read","filterText":"esp_dport_access_sequence_reg_read","insertText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})"}},{"label":"DEFAULT_FINGER_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352DEFAULT_FINGER_SERVER","filterText":"DEFAULT_FINGER_SERVER","insertText":"DEFAULT_FINGER_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"DEFAULT_FINGER_SERVER"}},{"label":"DEFAULT_IRC_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352DEFAULT_IRC_SERVER","filterText":"DEFAULT_IRC_SERVER","insertText":"DEFAULT_IRC_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"DEFAULT_IRC_SERVER"}},{"label":"DEFAULT_WWW_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352DEFAULT_WWW_SERVER","filterText":"DEFAULT_WWW_SERVER","insertText":"DEFAULT_WWW_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"DEFAULT_WWW_SERVER"}},{"label":"DOMAIN_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"41758352DOMAIN_NAME_SERVER","filterText":"DOMAIN_NAME_SERVER","insertText":"DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"DOMAIN_NAME_SERVER"}},{"label":"NETWORK_INFORMATION_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352NETWORK_INFORMATION_SERVERS","filterText":"NETWORK_INFORMATION_SERVERS","insertText":"NETWORK_INFORMATION_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETWORK_INFORMATION_SERVERS"}},{"label":"NETWORK_INFORMATION_SERVICE_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352NETWORK_INFORMATION_SERVICE_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETWORK_INFORMATION_SERVICE_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS"}},{"label":"POP3_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41758352POP3_SERVER","filterText":"POP3_SERVER","insertText":"POP3_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"POP3_SERVER"}},{"label":"RESOURCE_LOCATION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"41758352RESOURCE_LOCATION_SERVER","filterText":"RESOURCE_LOCATION_SERVER","insertText":"RESOURCE_LOCATION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"RESOURCE_LOCATION_SERVER"}},{"label":"esp_rom_spiflash_erase_area(uint32_t start_addr, uint32_t area_len)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase some sectors.  \nPlease do not call this function in SDK.  \n@param uint32_t start_addr : Start addr to erase, should be sector aligned.  \n@param uint32_t area_len : Length to erase, should be sector aligned.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41758352esp_rom_spiflash_erase_area","filterText":"esp_rom_spiflash_erase_area","insertText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})"}},{"label":"esp_rom_spiflash_erase_block(uint32_t block_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a 64KB block of flash Uses SPI flash command D8H.  \nPlease do not call this function in SDK.  \n@param uint32_t block_num : Which block to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41758352esp_rom_spiflash_erase_block","filterText":"esp_rom_spiflash_erase_block","insertText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})"}},{"label":"esp_rom_spiflash_erase_chip()","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase whole flash chip.  \nPlease do not call this function in SDK.  \n@param None  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41758352esp_rom_spiflash_erase_chip","filterText":"esp_rom_spiflash_erase_chip","insertText":"esp_rom_spiflash_erase_chip()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_rom_spiflash_erase_chip()"}},{"label":"esp_rom_spiflash_erase_sector(uint32_t sector_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a sector of flash.  \nUses SPI flash command 20H.  \nPlease do not call this function in SDK.  \n@param uint32_t sector_num : Which sector to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41758352esp_rom_spiflash_erase_sector","filterText":"esp_rom_spiflash_erase_sector","insertText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})"}},{"label":"xthal_tram_pending_to_service()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nTrampoline support functions:"},"sortText":"41758352xthal_tram_pending_to_service","filterText":"xthal_tram_pending_to_service","insertText":"xthal_tram_pending_to_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_tram_pending_to_service()"}},{"label":"NETWORK_TIME_PROTOCOL_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41b044fcNETWORK_TIME_PROTOCOL_SERVERS","filterText":"NETWORK_TIME_PROTOCOL_SERVERS","insertText":"NETWORK_TIME_PROTOCOL_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETWORK_TIME_PROTOCOL_SERVERS"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41b044fcSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","kind":20,"detail":"tcpip_adapter_dhcp_option_id_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \nDomain name server"},"sortText":"41f4c735TCPIP_ADAPTER_DOMAIN_NAME_SERVER","filterText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER"}},{"label":"ESP_ROM_SPIFLASH_RESULT_ERR","kind":20,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`"},"sortText":"41f58352ESP_ROM_SPIFLASH_RESULT_ERR","filterText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"ESP_ROM_SPIFLASH_RESULT_ERR"}},{"label":"X_WINDOW_SYSTEM_FONT_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41f58352X_WINDOW_SYSTEM_FONT_SERVER","filterText":"X_WINDOW_SYSTEM_FONT_SERVER","insertText":"X_WINDOW_SYSTEM_FONT_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"X_WINDOW_SYSTEM_FONT_SERVER"}},{"label":"NETBIOS_OVER_TCP_IP_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"42758352NETBIOS_OVER_TCP_IP_NAME_SERVER","filterText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETBIOS_OVER_TCP_IP_NAME_SERVER"}},{"label":"system_efuse_read_mac(uint8_t *mac)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Read hardware MAC address.  \nFunction has been renamed to esp_efuse_mac_get_default.  \nThis name will be removed in a future release.  \n@param mac hardware MAC address, length: 6 bytes.  \n@return ESP_OK on success"},"sortText":"42a13ebasystem_efuse_read_mac","filterText":"system_efuse_read_mac","insertText":"system_efuse_read_mac(${1:uint8_t *mac})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"system_efuse_read_mac(${1:uint8_t *mac})"}},{"label":"std::__throw_system_error(int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003clist\u003e`"},"sortText":"434759c2__throw_system_error","filterText":"__throw_system_error","insertText":"std::__throw_system_error(${1:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"std::__throw_system_error(${1:int})"}},{"label":"NETBIOS_OVER_TCP_IP_DATAGRAM_DISTRIBUTION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"80000000NETBIOS_OVER_TCP_IP_DATAGRAM_DISTRIBUTION_SERVER","filterText":"NETBIOS_OVER_TCP_IP_DATAGRAM_DISTRIBUTION_SERVER","insertText":"NETBIOS_OVER_TCP_IP_DATAGRAM_DISTRIBUTION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"NETBIOS_OVER_TCP_IP_DATAGRAM_DISTRIBUTION_SERVER"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":8},"contentChanges":[{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":9},"contentChanges":[{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"l"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":10},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"a"}]}}Content-Length: 282

{"jsonrpc":"2.0","id":14,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":14,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":10}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":11},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":12},"contentChanges":[{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":13},"contentChanges":[{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":14},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 241

{"jsonrpc":"2.0","id":15,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":4},"context":{"triggerKind":1}}}
>>>
Content-Length: 49753

{"id":15,"result":{"isIncomplete":true,"items":[{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setup()"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"initLDRSensor()"}},{"label":" OnDataSent(const int *mac_addr, int status)","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"4013a2a3OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const int *mac_addr}, ${2:int status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"OnDataSent(${1:const int *mac_addr}, ${2:int status})"}},{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40762d8dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial"}},{"label":"sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"408e069asensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_event_t"}},{"label":"sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"409c96d9sensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensor_t"}},{"label":"sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"409c96d9sensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_color_t"}},{"label":"sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"409c96d9sensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_type_t"}},{"label":"sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"409c96d9sensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_vec_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"40ac2d33Server","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Server"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"40ac2d33serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialEventRun()"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40ac2d33setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"40af2acfseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"seed48(${1:unsigned short *})"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"40af2acfsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"40af2acfsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"40af2acfsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40af7a82setsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"40b044fcSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SemaphoreHandle_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"40b044fcSendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcselect","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsend","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"40b044fcsend_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40b044fcsendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"40b044fcset_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"set_rtc_memory_crc()"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcsetitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"40b044fcsettimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"40b044fcsetuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40b903feSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":"SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":"SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_COLOR"}},{"label":"SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":"SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":"SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":"SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":"SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":"SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":"SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":"SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":"SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":"SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":"SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":"SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":"SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40b903feSENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40ca3c5dSERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SERVER_IDENTIFIER"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"40ca3c5dSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SEVEN_BITS"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"40d1f902set_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"40d1f902set_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"40d1f902set_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"40d2e427search","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"40d2e427search_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"40d2e427seed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40d2e427set_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_union($0)"}},{"label":"spiEndTransaction(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40e121e7spiEndTransaction","filterText":"spiEndTransaction","insertText":"spiEndTransaction(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"spiEndTransaction(${1:spi_t *spi})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"40e1cb19setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40e3601bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40e3601bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_AP_STAIPASSIGNED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP assign an IP to a connected station"},"sortText":"40e3601bSYSTEM_EVENT_AP_STAIPASSIGNED","filterText":"SYSTEM_EVENT_AP_STAIPASSIGNED","insertText":"SYSTEM_EVENT_AP_STAIPASSIGNED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STAIPASSIGNED"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40e3601bSYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40e3601bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40e3601bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_START","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet start"},"sortText":"40e3601bSYSTEM_EVENT_ETH_START","filterText":"SYSTEM_EVENT_ETH_START","insertText":"SYSTEM_EVENT_ETH_START","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_START"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40e3601bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_SCAN_DONE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 finish scanning AP"},"sortText":"40e3601bSYSTEM_EVENT_SCAN_DONE","filterText":"SYSTEM_EVENT_SCAN_DONE","insertText":"SYSTEM_EVENT_SCAN_DONE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_SCAN_DONE"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40e3601bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40e3601bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40e3601bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_START","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station start"},"sortText":"40e3601bSYSTEM_EVENT_STA_START","filterText":"SYSTEM_EVENT_STA_START","insertText":"SYSTEM_EVENT_STA_START","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_START"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40e3601bSYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40e3601bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"SYSTEM_EVENT_WIFI_READY","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 WiFi ready"},"sortText":"40e3601bSYSTEM_EVENT_WIFI_READY","filterText":"SYSTEM_EVENT_WIFI_READY","insertText":"SYSTEM_EVENT_WIFI_READY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_WIFI_READY"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_id_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40e3601bsystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"StaticEventGroup_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`  \nIn line with software engineering best practice, especially when supplying a library that is likely to change in future versions, FreeRTOS implements a strict data hiding policy. This means the event group structure used internally by FreeRTOS is not accessible to application code. However, if the application writer wants to statically allocate the memory required to create an event group then the size of the event group object needs to be know. The StaticEventGroup_t structure below is provided for this purpose.  \nIts sizes and alignment requirements are guaranteed to match those of the genuine structure, no matter which architecture is being used, and no matter how the values in FreeRTOSConfig.h are set. Its contents are somewhat obfuscated in the hope users will recognise that it would be unwise to make direct use of the structure members."},"sortText":"40e433bdStaticEventGroup_t","filterText":"StaticEventGroup_t","insertText":"StaticEventGroup_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"StaticEventGroup_t"}},{"label":"sei()","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"413f6ee9sei","filterText":"sei","insertText":"sei()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sei()"}},{"label":" semBINARY_SEMAPHORE_QUEUE_LENGTH","kind":1,"sortText":"41432771semBINARY_SEMAPHORE_QUEUE_LENGTH","filterText":"semBINARY_SEMAPHORE_QUEUE_LENGTH","insertText":"semBINARY_SEMAPHORE_QUEUE_LENGTH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"semBINARY_SEMAPHORE_QUEUE_LENGTH"}}]},"jsonrpc":"2.0"}Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":15},"contentChanges":[{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""}]}}Content-Length: 241

{"jsonrpc":"2.0","id":16,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":3},"context":{"triggerKind":1}}}
>>>
Content-Length: 734

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'serila'"}]},"jsonrpc":"2.0"}Content-Length: 41264

{"id":16,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Serial"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"size_t"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPlotter()"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_EN"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sketchSize_t"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SLEEP_MODE"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 's'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":16},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":17},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"A"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":17,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":3},"context":{"triggerKind":1}}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 38669

{"id":17,"result":{"isIncomplete":true,"items":[{"label":" a","kind":6,"detail":"sensors_event_t","documentation":{"kind":"markdown","value":"Create sensor object"},"sortText":"3e4f8622a","filterText":"a","insertText":"a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"a"}},{"label":" accY","kind":6,"detail":"float","sortText":"3ec3fa2aaccY","filterText":"accY","insertText":"accY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accY"}},{"label":" accZ","kind":6,"detail":"float","sortText":"3ec3fa2aaccZ","filterText":"accZ","insertText":"accZ","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accZ"}},{"label":" accX","kind":6,"detail":"float","sortText":"3eddaf05accX","filterText":"accX","insertText":"accX","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accX"}},{"label":" alignas(expression)","kind":15,"sortText":"3f000000alignas","filterText":"alignas","insertText":"alignas(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"alignas(${0:expression})"}},{"label":" alignof(type)","kind":15,"detail":"size_t","sortText":"3f000000alignof","filterText":"alignof","insertText":"alignof(${0:type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"alignof(${0:type})"}},{"label":" auto","kind":14,"sortText":"3f000000auto","filterText":"auto","insertText":"auto","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"auto"}},{"label":" accPitch","kind":6,"detail":"float","documentation":{"kind":"markdown","value":"units degrees (roll and pitch noisy, yaw not possible)"},"sortText":"3f2cccccaccPitch","filterText":"accPitch","insertText":"accPitch","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accPitch"}},{"label":" accRoll","kind":6,"detail":"float","documentation":{"kind":"markdown","value":"units degrees (roll and pitch noisy, yaw not possible)"},"sortText":"3f2cccccaccRoll","filterText":"accRoll","insertText":"accRoll","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accRoll"}},{"label":" accYaw","kind":6,"detail":"float","documentation":{"kind":"markdown","value":"units degrees (roll and pitch noisy, yaw not possible)"},"sortText":"3f2cccccaccYaw","filterText":"accYaw","insertText":"accYaw","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accYaw"}},{"label":"Adafruit_LSM6DS","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS.h\"`  \n@brief Class that stores state and functions for interacting with the LSM6DS I2C Accel/Gyro"},"sortText":"3f41e0a7Adafruit_LSM6DS","filterText":"Adafruit_LSM6DS","insertText":"Adafruit_LSM6DS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS"}},{"label":" atan2(double, double)","kind":3,"detail":"double","sortText":"3f52aa78atan2","filterText":"atan2","insertText":"atan2(${1:double}, ${2:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atan2(${1:double}, ${2:double})"}},{"label":" Adafruit_SPIDevice","kind":7,"documentation":{"kind":"markdown","value":"! The class which defines how we will talk to this device over SPI *"},"sortText":"3f5780d3Adafruit_SPIDevice","filterText":"Adafruit_SPIDevice","insertText":"Adafruit_SPIDevice","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_SPIDevice"}},{"label":" Adafruit_LSM6DS33","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS33.h\"`  \n@brief Class that stores state and functions for interacting with the LSM6DS33 I2C Digital Potentiometer"},"sortText":"3f5b380cAdafruit_LSM6DS33","filterText":"Adafruit_LSM6DS33","insertText":"Adafruit_LSM6DS33","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS33"}},{"label":" Adafruit_I2CDevice","kind":7,"sortText":"3f651eb8Adafruit_I2CDevice","filterText":"Adafruit_I2CDevice","insertText":"Adafruit_I2CDevice","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_I2CDevice"}},{"label":"Adafruit_LSM6DS_Accelerometer","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS.h\"`  \nAdafruit Unified Sensor interface for accelerometer component of LSM6DS"},"sortText":"3f651eb8Adafruit_LSM6DS_Accelerometer","filterText":"Adafruit_LSM6DS_Accelerometer","insertText":"Adafruit_LSM6DS_Accelerometer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Accelerometer"}},{"label":"Adafruit_LSM6DS_Gyro","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS.h\"`  \nAdafruit Unified Sensor interface for gyro component of LSM6DS"},"sortText":"3f651eb8Adafruit_LSM6DS_Gyro","filterText":"Adafruit_LSM6DS_Gyro","insertText":"Adafruit_LSM6DS_Gyro","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Gyro"}},{"label":"Adafruit_LSM6DS_Temp","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS.h\"`  \nAdafruit Unified Sensor interface for temperature component of LSM6DS"},"sortText":"3f651eb8Adafruit_LSM6DS_Temp","filterText":"Adafruit_LSM6DS_Temp","insertText":"Adafruit_LSM6DS_Temp","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Temp"}},{"label":"analogRead(uint8_t pin)","kind":3,"detail":"uint16_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nGet ADC value for pin"},"sortText":"3f651eb8analogRead","filterText":"analogRead","insertText":"analogRead(${1:uint8_t pin})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogRead(${1:uint8_t pin})"}},{"label":" Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire = \u0026Wire)","kind":4,"sortText":"3f733333Adafruit_I2CDevice","filterText":"Adafruit_I2CDevice","insertText":"Adafruit_I2CDevice(${1:uint8_t addr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_I2CDevice(${1:uint8_t addr})"}},{"label":" Adafruit_LSM6DS()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Adafruit_LSM6DS","filterText":"Adafruit_LSM6DS","insertText":"Adafruit_LSM6DS($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS($0)"}},{"label":" Adafruit_LSM6DS33()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Adafruit_LSM6DS33","filterText":"Adafruit_LSM6DS33","insertText":"Adafruit_LSM6DS33($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS33($0)"}},{"label":" Adafruit_LSM6DS_Accelerometer()","kind":4,"detail":"[3 overloads]","sortText":"3f733333Adafruit_LSM6DS_Accelerometer","filterText":"Adafruit_LSM6DS_Accelerometer","insertText":"Adafruit_LSM6DS_Accelerometer($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Accelerometer($0)"}},{"label":" Adafruit_LSM6DS_Gyro()","kind":4,"detail":"[3 overloads]","sortText":"3f733333Adafruit_LSM6DS_Gyro","filterText":"Adafruit_LSM6DS_Gyro","insertText":"Adafruit_LSM6DS_Gyro($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Gyro($0)"}},{"label":" Adafruit_LSM6DS_Temp()","kind":4,"detail":"[3 overloads]","sortText":"3f733333Adafruit_LSM6DS_Temp","filterText":"Adafruit_LSM6DS_Temp","insertText":"Adafruit_LSM6DS_Temp($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DS_Temp($0)"}},{"label":" Adafruit_SPIDevice()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Adafruit_SPIDevice","filterText":"Adafruit_SPIDevice","insertText":"Adafruit_SPIDevice($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_SPIDevice($0)"}},{"label":" Adafruit_Sensor","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \n@brief Common sensor interface to unify various sensors.  \nIntentionally modeled after sensors.h in the Android API:  \nhttps://github.com/android/platform_hardware_libhardware/blob/master/include/hardware/sensors.h"},"sortText":"4012b71bAdafruit_Sensor","filterText":"Adafruit_Sensor","insertText":"Adafruit_Sensor","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_Sensor"}},{"label":" Adafruit_BusIO_Register","kind":7,"documentation":{"kind":"markdown","value":"@brief The class which defines a device register (a location to read/write data from)"},"sortText":"402909deAdafruit_BusIO_Register","filterText":"Adafruit_BusIO_Register","insertText":"Adafruit_BusIO_Register","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_BusIO_Register"}},{"label":" Adafruit_BusIO_RegisterBits","kind":7,"documentation":{"kind":"markdown","value":"@brief The class which defines a slice of bits from within a device register (a location to read/write data from)"},"sortText":"402b06b9Adafruit_BusIO_RegisterBits","filterText":"Adafruit_BusIO_RegisterBits","insertText":"Adafruit_BusIO_RegisterBits","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_BusIO_RegisterBits"}},{"label":" ADDRBIT8_HIGH_TOREAD","kind":20,"detail":"_Adafruit_BusIO_SPIRegType","sortText":"403d0d22ADDRBIT8_HIGH_TOREAD","filterText":"ADDRBIT8_HIGH_TOREAD","insertText":"ADDRBIT8_HIGH_TOREAD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ADDRBIT8_HIGH_TOREAD"}},{"label":"A0","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA0","filterText":"A0","insertText":"A0","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A0"}},{"label":"A10","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA10","filterText":"A10","insertText":"A10","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A10"}},{"label":"A16","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA16","filterText":"A16","insertText":"A16","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A16"}},{"label":"A17","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA17","filterText":"A17","insertText":"A17","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A17"}},{"label":"A18","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA18","filterText":"A18","insertText":"A18","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A18"}},{"label":"A3","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA3","filterText":"A3","insertText":"A3","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A3"}},{"label":"A5","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bA5","filterText":"A5","insertText":"A5","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"A5"}},{"label":"accel_range","kind":13,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DS.h\"`  \nThe accelerometer data range"},"sortText":"403f858baccel_range","filterText":"accel_range","insertText":"accel_range","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"accel_range"}},{"label":"asiprintf(char **, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858basiprintf","filterText":"asiprintf","insertText":"asiprintf(${1:char **}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asiprintf(${1:char **}, ${2:const char *, ...})"}},{"label":"asniprintf(char *, size_t *, const char *, ...)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858basniprintf","filterText":"asniprintf","insertText":"asniprintf(${1:char *}, ${2:size_t *}, ${3:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asniprintf(${1:char *}, ${2:size_t *}, ${3:const char *, ...})"}},{"label":"asnprintf(char *, size_t *, const char *, ...)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858basnprintf","filterText":"asnprintf","insertText":"asnprintf(${1:char *}, ${2:size_t *}, ${3:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asnprintf(${1:char *}, ${2:size_t *}, ${3:const char *, ...})"}},{"label":"asprintf(char **, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858basprintf","filterText":"asprintf","insertText":"asprintf(${1:char **}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asprintf(${1:char **}, ${2:const char *, ...})"}},{"label":"atoi(const char *__nptr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858batoi","filterText":"atoi","insertText":"atoi(${1:const char *__nptr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atoi(${1:const char *__nptr})"}},{"label":"ADC_0db","kind":20,"detail":"adc_attenuation_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`"},"sortText":"40500923ADC_0db","filterText":"ADC_0db","insertText":"ADC_0db","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ADC_0db"}},{"label":"ADC_11db","kind":20,"detail":"adc_attenuation_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`"},"sortText":"40500923ADC_11db","filterText":"ADC_11db","insertText":"ADC_11db","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ADC_11db"}},{"label":"ADC_2_5db","kind":20,"detail":"adc_attenuation_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`"},"sortText":"40500923ADC_2_5db","filterText":"ADC_2_5db","insertText":"ADC_2_5db","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ADC_2_5db"}},{"label":"ADC_6db","kind":20,"detail":"adc_attenuation_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`"},"sortText":"40500923ADC_6db","filterText":"ADC_6db","insertText":"ADC_6db","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ADC_6db"}},{"label":"APB_AFTER_CHANGE","kind":20,"detail":"apb_change_ev_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`"},"sortText":"40500923APB_AFTER_CHANGE","filterText":"APB_AFTER_CHANGE","insertText":"APB_AFTER_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"APB_AFTER_CHANGE"}},{"label":"APB_BEFORE_CHANGE","kind":20,"detail":"apb_change_ev_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`"},"sortText":"40500923APB_BEFORE_CHANGE","filterText":"APB_BEFORE_CHANGE","insertText":"APB_BEFORE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"APB_BEFORE_CHANGE"}},{"label":"Adafruit_ISM330DHCX","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_ISM330DHCX.h\"`  \n@brief Class that stores state and functions for interacting with the ISM330DHCX I2C Digital Potentiometer"},"sortText":"40500923Adafruit_ISM330DHCX","filterText":"Adafruit_ISM330DHCX","insertText":"Adafruit_ISM330DHCX","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_ISM330DHCX"}},{"label":"Adafruit_LSM6DSOX","kind":7,"documentation":{"kind":"markdown","value":"From `\"Adafruit_LSM6DSOX.h\"`  \n@brief Class that stores state and functions for interacting with the LSM6DSOX I2C Digital Potentiometer"},"sortText":"40500923Adafruit_LSM6DSOX","filterText":"Adafruit_LSM6DSOX","insertText":"Adafruit_LSM6DSOX","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Adafruit_LSM6DSOX"}},{"label":"adcAttachPin(uint8_t pin)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nAttach pin to ADC (will also clear any other analog mode that could be on)"},"sortText":"40500923adcAttachPin","filterText":"adcAttachPin","insertText":"adcAttachPin(${1:uint8_t pin})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"adcAttachPin(${1:uint8_t pin})"}},{"label":"adc_attenuation_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`"},"sortText":"40500923adc_attenuation_t","filterText":"adc_attenuation_t","insertText":"adc_attenuation_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"adc_attenuation_t"}},{"label":"addApbChangeCallback(void *arg, apb_change_cb_t cb)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`"},"sortText":"40500923addApbChangeCallback","filterText":"addApbChangeCallback","insertText":"addApbChangeCallback(${1:void *arg}, ${2:apb_change_cb_t cb})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"addApbChangeCallback(${1:void *arg}, ${2:apb_change_cb_t cb})"}},{"label":"analogReadMilliVolts(uint8_t pin)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nGet MilliVolts value for pin"},"sortText":"40500923analogReadMilliVolts","filterText":"analogReadMilliVolts","insertText":"analogReadMilliVolts(${1:uint8_t pin})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogReadMilliVolts(${1:uint8_t pin})"}},{"label":"analogReadResolution(uint8_t bits)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSet the resolution of analogRead return values. Default is 12 bits (range from 0 to 4096).  \nIf between 9 and 12, it will equal the set hardware resolution, else value will be shifted.  \nRange is 1 - 16  \nNote: compatibility with Arduino SAM"},"sortText":"40500923analogReadResolution","filterText":"analogReadResolution","insertText":"analogReadResolution(${1:uint8_t bits})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogReadResolution(${1:uint8_t bits})"}},{"label":"analogSetAttenuation(adc_attenuation_t attenuation)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSet the attenuation for all channels Default is 11db"},"sortText":"40500923analogSetAttenuation","filterText":"analogSetAttenuation","insertText":"analogSetAttenuation(${1:adc_attenuation_t attenuation})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogSetAttenuation(${1:adc_attenuation_t attenuation})"}},{"label":"analogSetClockDiv(uint8_t clockDiv)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSet the divider for the ADC clock.  \nDefault is 1 Range is 1 - 255"},"sortText":"40500923analogSetClockDiv","filterText":"analogSetClockDiv","insertText":"analogSetClockDiv(${1:uint8_t clockDiv})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogSetClockDiv(${1:uint8_t clockDiv})"}},{"label":"analogSetPinAttenuation(uint8_t pin, adc_attenuation_t attenuation)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSet the attenuation for particular pin Default is 11db"},"sortText":"40500923analogSetPinAttenuation","filterText":"analogSetPinAttenuation","insertText":"analogSetPinAttenuation(${1:uint8_t pin}, ${2:adc_attenuation_t attenuation})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogSetPinAttenuation(${1:uint8_t pin}, ${2:adc_attenuation_t attenuation})"}},{"label":"analogSetVRefPin(uint8_t pin)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSet pin to use for ADC calibration if the esp is not already calibrated (25, 26 or 27)"},"sortText":"40500923analogSetVRefPin","filterText":"analogSetVRefPin","insertText":"analogSetVRefPin(${1:uint8_t pin})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogSetVRefPin(${1:uint8_t pin})"}},{"label":"analogSetWidth(uint8_t bits)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-adc.h\"`  \nSets the sample bits and read resolution Default is 12bit (0 - 4095) Range is 9 - 12"},"sortText":"40500923analogSetWidth","filterText":"analogSetWidth","insertText":"analogSetWidth(${1:uint8_t bits})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"analogSetWidth(${1:uint8_t bits})"}},{"label":"apb_change_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`"},"sortText":"40500923apb_change_cb_t","filterText":"apb_change_cb_t","insertText":"apb_change_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"apb_change_cb_t"}},{"label":"apb_change_ev_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`"},"sortText":"40500923apb_change_ev_t","filterText":"apb_change_ev_t","insertText":"apb_change_ev_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"apb_change_ev_t"}},{"label":"attachInterrupt(uint8_t pin, void (*)(), int mode)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-gpio.h\"`"},"sortText":"40500923attachInterrupt","filterText":"attachInterrupt","insertText":"attachInterrupt(${1:uint8_t pin}, ${2:void (*)()}, ${3:int mode})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"attachInterrupt(${1:uint8_t pin}, ${2:void (*)()}, ${3:int mode})"}},{"label":"attachInterruptArg(uint8_t pin, void (*)(void *), void *arg, int mode)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-gpio.h\"`"},"sortText":"40500923attachInterruptArg","filterText":"attachInterruptArg","insertText":"attachInterruptArg(${1:uint8_t pin}, ${2:void (*)(void *)}, ${3:void *arg}, ${4:int mode})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"attachInterruptArg(${1:uint8_t pin}, ${2:void (*)(void *)}, ${3:void *arg}, ${4:int mode})"}},{"label":"AWAKE","kind":20,"detail":"SLEEP_MODE","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \nCPU ON"},"sortText":"405d8e68AWAKE","filterText":"AWAKE","insertText":"AWAKE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"AWAKE"}},{"label":"acosh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68acosh","filterText":"acosh","insertText":"acosh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"acosh(${1:double})"}},{"label":"acoshl(long double)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68acoshl","filterText":"acoshl","insertText":"acoshl(${1:long double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"acoshl(${1:long double})"}},{"label":"acosl(long double)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68acosl","filterText":"acosl","insertText":"acosl(${1:long double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"acosl(${1:long double})"}},{"label":"asin(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68asin","filterText":"asin","insertText":"asin(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asin(${1:double})"}},{"label":"asinf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68asinf","filterText":"asinf","insertText":"asinf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asinf(${1:float})"}},{"label":"asinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68asinhf","filterText":"asinhf","insertText":"asinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asinhf(${1:float})"}},{"label":"asinl(long double)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68asinl","filterText":"asinl","insertText":"asinl(${1:long double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asinl(${1:long double})"}},{"label":"atan(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68atan","filterText":"atan","insertText":"atan(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atan(${1:double})"}},{"label":"atan2f(float, float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68atan2f","filterText":"atan2f","insertText":"atan2f(${1:float}, ${2:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atan2f(${1:float}, ${2:float})"}},{"label":"atan2l(long double, long double)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68atan2l","filterText":"atan2l","insertText":"atan2l(${1:long double}, ${2:long double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atan2l(${1:long double}, ${2:long double})"}},{"label":"atanf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`  \nSingle precision versions of ANSI functions."},"sortText":"405d8e68atanf","filterText":"atanf","insertText":"atanf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atanf(${1:float})"}},{"label":"atanhl(long double)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68atanhl","filterText":"atanhl","insertText":"atanhl(${1:long double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"atanhl(${1:long double})"}},{"label":"std::abs(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3abs","filterText":"abs","insertText":"std::abs(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::abs(${1:long double __x})"}},{"label":"std::acos(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3acos","filterText":"acos","insertText":"std::acos(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::acos(${1:long double __x})"}},{"label":"std::asin()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3asin","filterText":"asin","insertText":"std::asin($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::asin($0)"}},{"label":"std::atan2()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3atan2","filterText":"atan2","insertText":"std::atan2($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::atan2($0)"}},{"label":"std::atanh(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3atanh","filterText":"atanh","insertText":"std::atanh(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::atanh(${1:long double __x})"}},{"label":"asctime(const struct tm *_tblock)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"time.h\"`"},"sortText":"4068a03fasctime","filterText":"asctime","insertText":"asctime(${1:const struct tm *_tblock})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asctime(${1:const struct tm *_tblock})"}},{"label":"asctime_r(const struct tm *, char *)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"time.h\"`"},"sortText":"4068a03fasctime_r","filterText":"asctime_r","insertText":"asctime_r(${1:const struct tm *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"asctime_r(${1:const struct tm *}, ${2:char *})"}},{"label":"std::asinh","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddasinh","filterText":"asinh","insertText":"std::asinh","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::asinh"}},{"label":"std::atan2","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddatan2","filterText":"atan2","insertText":"std::atan2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::atan2"}},{"label":"std::atanh","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddatanh","filterText":"atanh","insertText":"std::atanh","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::atanh"}},{"label":"std::atanhl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddatanhl","filterText":"atanhl","insertText":"std::atanhl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::atanhl"}},{"label":"access(const char *__path, int __amode)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066access","filterText":"access","insertText":"access(${1:const char *__path}, ${2:int __amode})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"access(${1:const char *__path}, ${2:int __amode})"}},{"label":"alarm(unsigned int __secs)","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066alarm","filterText":"alarm","insertText":"alarm(${1:unsigned int __secs})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"alarm(${1:unsigned int __secs})"}},{"label":" ARDUINO","kind":1,"sortText":"40800000ARDUINO","filterText":"ARDUINO","insertText":"ARDUINO","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ARDUINO"}},{"label":" ARDUINO_ARCH_ESP32","kind":1,"sortText":"40800000ARDUINO_ARCH_ESP32","filterText":"ARDUINO_ARCH_ESP32","insertText":"ARDUINO_ARCH_ESP32","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ARDUINO_ARCH_ESP32"}},{"label":" ARDUINO_BOARD","kind":1,"sortText":"40800000ARDUINO_BOARD","filterText":"ARDUINO_BOARD","insertText":"ARDUINO_BOARD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ARDUINO_BOARD"}},{"label":" ARDUINO_LOLIN32","kind":1,"sortText":"40800000ARDUINO_LOLIN32","filterText":"ARDUINO_LOLIN32","insertText":"ARDUINO_LOLIN32","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ARDUINO_LOLIN32"}},{"label":" ARDUINO_VARIANT","kind":1,"sortText":"40800000ARDUINO_VARIANT","filterText":"ARDUINO_VARIANT","insertText":"ARDUINO_VARIANT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"ARDUINO_VARIANT"}},{"label":"std::abs()","kind":3,"detail":"[3 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccstdlib\u003e`"},"sortText":"4083b5beabs","filterText":"abs","insertText":"std::abs($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::abs($0)"}},{"label":"std::add_const\u003ctypename _Tp\u003e","kind":22,"documentation":{"kind":"markdown","value":"From `\u003ctype_traits\u003e`  \nadd_const"},"sortText":"4083b5beadd_const","filterText":"add_const","insertText":"std::add_const\u003c${1:typename _Tp}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::add_const\u003c${1:typename _Tp}\u003e"}},{"label":"std::add_lvalue_reference\u003ctypename _Tp\u003e","kind":22,"documentation":{"kind":"markdown","value":"From `\u003ctype_traits\u003e`  \nadd_lvalue_reference"},"sortText":"4083b5beadd_lvalue_reference","filterText":"add_lvalue_reference","insertText":"std::add_lvalue_reference\u003c${1:typename _Tp}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::add_lvalue_reference\u003c${1:typename _Tp}\u003e"}},{"label":"std::aligned_union\u003csize_t _Len, typename _Types\u003e","kind":22,"documentation":{"kind":"markdown","value":"From `\u003ctype_traits\u003e`  \n@brief Provide aligned storage for types.  \n[meta.trans.other]  \nProvides aligned storage for any of the provided types of at least size \\_Len.  \n@see aligned_storage"},"sortText":"4083b5bealigned_union","filterText":"aligned_union","insertText":"std::aligned_union\u003c${1:size_t _Len}, ${2:typename _Types}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::aligned_union\u003c${1:size_t _Len}, ${2:typename _Types}\u003e"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'A'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 464

{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"message":"Use of undeclared identifier 'A'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":18,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":17}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":18},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":19},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"S"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":19,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":3},"context":{"triggerKind":1}}}
>>>
Content-Length: 41264

{"id":19,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Serial"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"size_t"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPlotter()"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STICK_PARITY_EN"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sketchSize_t"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SLEEP_MODE"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":3}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'S'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":20},"contentChanges":[{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":20,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":4},"context":{"triggerKind":3}}}
>>>
Content-Length: 48378

{"id":20,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPlotter()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_vec_t"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_type_t"}},{"label":" HardwareSerial","kind":7,"sortText":"4017ae13HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"HardwareSerial"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send_cb_t"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"402cccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"HardwareSerial($0)"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SemaphoreHandle_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"seed48(${1:unsigned short *})"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialEventRun()"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":21},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"i"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":21,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":5},"context":{"triggerKind":3}}}
>>>
Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":4}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}Content-Length: 21084

{"id":21,"result":{"isIncomplete":false,"items":[{"label":" sei()","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"4028495fsei","filterText":"sei","insertText":"sei()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"sei()"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40956184system_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40956184system_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"system_event_info_t"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"40ba588fset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"std::set_intersection($0)"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40efcf5cSERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"SERVER_IDENTIFIER"}},{"label":"ets_set_idle_cb(ets_idle_cb_t func, void *arg)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/ets_sys.h\"`  \n@brief Set the Idle callback, when Tasks are processed, will call the callback before CPU goto sleep.  \n@param ets_idle_cb_t func : The callback function.  \n@param void \\*arg : Argument of the callback.  \n@return None"},"sortText":"40f8a156ets_set_idle_cb","filterText":"ets_set_idle_cb","insertText":"ets_set_idle_cb(${1:ets_idle_cb_t func}, ${2:void *arg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"ets_set_idle_cb(${1:ets_idle_cb_t func}, ${2:void *arg})"}},{"label":"xthal_set_icacheattr(unsigned int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_icacheattr","filterText":"xthal_set_icacheattr","insertText":"xthal_set_icacheattr(${1:unsigned int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_icacheattr(${1:unsigned int})"}},{"label":"xthal_set_int_vpri(int intnum, int vpri)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nSet/get virtual priority of an interrupt:"},"sortText":"40f8a156xthal_set_int_vpri","filterText":"xthal_set_int_vpri","insertText":"xthal_set_int_vpri(${1:int intnum}, ${2:int vpri})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_int_vpri(${1:int intnum}, ${2:int vpri})"}},{"label":"xthal_set_intclear(unsigned int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_intclear","filterText":"xthal_set_intclear","insertText":"xthal_set_intclear(${1:unsigned int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_intclear(${1:unsigned int})"}},{"label":"xthal_set_intenable(unsigned int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_intenable","filterText":"xthal_set_intenable","insertText":"xthal_set_intenable(${1:unsigned int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_intenable(${1:unsigned int})"}},{"label":"xthal_set_intset(unsigned int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_intset","filterText":"xthal_set_intset","insertText":"xthal_set_intset(${1:unsigned int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xthal_set_intset(${1:unsigned int})"}},{"label":"xt_set_intclear(unsigned int arg)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"freertos/xtensa_api.h\"`  \n\\------------------------------------------------------------------------------- Call this function to clear the specified (s/w or edge-triggered) interrupt.  \n\\-------------------------------------------------------------------------------"},"sortText":"4103b5bdxt_set_intclear","filterText":"xt_set_intclear","insertText":"xt_set_intclear(${1:unsigned int arg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xt_set_intclear(${1:unsigned int arg})"}},{"label":"xt_set_interrupt_handler(int n, xt_handler f, void *arg)","kind":3,"detail":"xt_handler","documentation":{"kind":"markdown","value":"From `\"freertos/xtensa_api.h\"`  \n\\------------------------------------------------------------------------------- Call this function to set a handler for the specified interrupt. The handler will be installed on the core that calls this function.  \nn - Interrupt number.  \nf - Handler function address, NULL to uninstall handler.  \narg - Argument to be passed to handler.  \n\\-------------------------------------------------------------------------------"},"sortText":"4103b5bdxt_set_interrupt_handler","filterText":"xt_set_interrupt_handler","insertText":"xt_set_interrupt_handler(${1:int n}, ${2:xt_handler f}, ${3:void *arg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xt_set_interrupt_handler(${1:int n}, ${2:xt_handler f}, ${3:void *arg})"}},{"label":"xt_set_intset(unsigned int arg)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"freertos/xtensa_api.h\"`  \n\\------------------------------------------------------------------------------- Call this function to set the specified (s/w) interrupt.  \n\\-------------------------------------------------------------------------------"},"sortText":"4103b5bdxt_set_intset","filterText":"xt_set_intset","insertText":"xt_set_intset(${1:unsigned int arg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"xt_set_intset(${1:unsigned int arg})"}},{"label":"gpio_set_intr_type(gpio_num_t gpio_num, gpio_int_type_t intr_type)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief GPIO set interrupt trigger type  \n@param gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);  \n@param intr_type Interrupt type, select from gpio_int_type_t  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_INVALID_ARG Parameter error"},"sortText":"4112d0aagpio_set_intr_type","filterText":"gpio_set_intr_type","insertText":"gpio_set_intr_type(${1:gpio_num_t gpio_num}, ${2:gpio_int_type_t intr_type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"gpio_set_intr_type(${1:gpio_num_t gpio_num}, ${2:gpio_int_type_t intr_type})"}},{"label":"esp_intr_set_in_iram(intr_handle_t handle, bool is_in_iram)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_intr_alloc.h\"`  \n@brief Set the \"in IRAM\" status of the handler.  \n@note Does not work on shared interrupts.  \n@param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus  \n@param is_in_iram Whether the handler associated with this handle resides in IRAM.  \nHandlers residing in IRAM can be called when cache is disabled.  \n@return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.  \nESP_OK otherwise"},"sortText":"41156184esp_intr_set_in_iram","filterText":"esp_intr_set_in_iram","insertText":"esp_intr_set_in_iram(${1:intr_handle_t handle}, ${2:bool is_in_iram})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_intr_set_in_iram(${1:intr_handle_t handle}, ${2:bool is_in_iram})"}},{"label":"esp_wifi_set_inactive_time(wifi_interface_t ifx, uint16_t sec)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_wifi.h\"`  \n@brief Set the inactive time of the ESP32 STA or AP  \n@attention 1. For Station, If the station does not receive a beacon frame from the connected SoftAP during the inactive time,  \ndisconnect from SoftAP. Default 6s.  \n@attention 2. For SoftAP, If the softAP doesn't receive any data from the connected STA during inactive time,  \nthe softAP will force deauth the STA. Default is 300s.  \n@attention 3. The inactive time configuration is not stored into flash  \n@param ifx interface to be configured.  \n@param sec Inactive time. Unit seconds.  \n@return  \n\\- ESP_OK: succeed  \n\\- ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init  \n\\- ESP_ERR_WIFI_NOT_STARTED: WiFi is not started by esp_wifi_start  \n\\- ESP_ERR_WIFI_ARG: invalid argument, For Station, if sec is less than 3. For SoftAP, if sec is less than 10."},"sortText":"41156184esp_wifi_set_inactive_time","filterText":"esp_wifi_set_inactive_time","insertText":"esp_wifi_set_inactive_time(${1:wifi_interface_t ifx}, ${2:uint16_t sec})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"esp_wifi_set_inactive_time(${1:wifi_interface_t ifx}, ${2:uint16_t sec})"}},{"label":"adc_set_i2s_data_source(adc_i2s_source_t src)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Set I2S data source  \n@param src I2S DMA data source, I2S DMA can get data from digital signals or from ADC.  \n@return  \n\\- ESP_OK success"},"sortText":"413198efadc_set_i2s_data_source","filterText":"adc_set_i2s_data_source","insertText":"adc_set_i2s_data_source(${1:adc_i2s_source_t src})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"adc_set_i2s_data_source(${1:adc_i2s_source_t src})"}},{"label":"dhcp_search_ip_on_mac(u8_t *mac, ip4_addr_t *ip)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver.h\"`"},"sortText":"41427db5dhcp_search_ip_on_mac","filterText":"dhcp_search_ip_on_mac","insertText":"dhcp_search_ip_on_mac(${1:u8_t *mac}, ${2:ip4_addr_t *ip})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"dhcp_search_ip_on_mac(${1:u8_t *mac}, ${2:ip4_addr_t *ip})"}},{"label":"nvs_set_i16(nvs_handle handle, const char *key, int16_t value)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs.h\"`"},"sortText":"4151f901nvs_set_i16","filterText":"nvs_set_i16","insertText":"nvs_set_i16(${1:nvs_handle handle}, ${2:const char *key}, ${3:int16_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_set_i16(${1:nvs_handle handle}, ${2:const char *key}, ${3:int16_t value})"}},{"label":"nvs_set_i32(nvs_handle handle, const char *key, int32_t value)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs.h\"`"},"sortText":"4151f901nvs_set_i32","filterText":"nvs_set_i32","insertText":"nvs_set_i32(${1:nvs_handle handle}, ${2:const char *key}, ${3:int32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_set_i32(${1:nvs_handle handle}, ${2:const char *key}, ${3:int32_t value})"}},{"label":"nvs_set_i64(nvs_handle handle, const char *key, int64_t value)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs.h\"`"},"sortText":"4151f901nvs_set_i64","filterText":"nvs_set_i64","insertText":"nvs_set_i64(${1:nvs_handle handle}, ${2:const char *key}, ${3:int64_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_set_i64(${1:nvs_handle handle}, ${2:const char *key}, ${3:int64_t value})"}},{"label":"nvs_set_i8(nvs_handle handle, const char *key, int8_t value)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs.h\"`  \n@{  \n@brief set value for given key  \nThis family of functions set value for the key, given its name. Note that actual storage will not be updated until nvs_commit function is called.  \n@param[in] handle Handle obtained from nvs_open function.  \nHandles that were opened read only cannot be used.  \n@param[in] key Key name. Maximal length is determined by the underlying implementation, but is guaranteed to be at least 15 characters. Shouldn't be empty.  \n@param[in] value The value to set.  \nFor strings, the maximum length (including null character) is 4000 bytes.  \n@return  \n\\- ESP_OK if value was set successfully  \n\\- ESP_ERR_NVS_INVALID_HANDLE if handle has been closed or is NULL  \n\\- ESP_ERR_NVS_READ_ONLY if storage handle was opened as read only  \n\\- ESP_ERR_NVS_INVALID_NAME if key name doesn't satisfy constraints  \n\\- ESP_ERR_NVS_NOT_ENOUGH_SPACE if there is not enough space in the underlying storage to save the value  \n\\- ESP_ERR_NVS_REMOVE_FAILED if the value wasn't updated because flash write operation has failed. The value was written however, and update will be finished after re-initialization of nvs, provided that flash operation doesn't fail again.  \n\\- ESP_ERR_NVS_VALUE_TOO_LONG if the string value is too long"},"sortText":"4151f901nvs_set_i8","filterText":"nvs_set_i8","insertText":"nvs_set_i8(${1:nvs_handle handle}, ${2:const char *key}, ${3:int8_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_set_i8(${1:nvs_handle handle}, ${2:const char *key}, ${3:int8_t value})"}},{"label":"tcpip_adapter_set_ip_info(tcpip_adapter_if_t tcpip_if, const tcpip_adapter_ip_info_t *ip_info)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \n@brief Set interface's IP address information  \nThis function is mainly used to set a static IP on an interface.  \nIf the interface is up, the new IP information is set directly in the TCP/IP stack.  \nThe copy of IP information kept in the TCP/IP adapter library is also updated (this copy is returned if the IP is queried while the interface is still down.)  \n@note DHCP client/server must be stopped before setting new IP information.  \n@note Calling this interface for the Wi-Fi STA or Ethernet interfaces may generate a SYSTEM_EVENT_STA_GOT_IP or SYSTEM_EVENT_ETH_GOT_IP event.  \n@param[in] tcpip_if Interface to set IP information  \n@param[in] ip_info IP information to set on the specified interface  \n@return  \n\\- ESP_OK  \n\\- ESP_ERR_TCPIP_ADAPTER_INVALID_PARAMS  \n\\- ESP_ERR_TCPIP_ADAPTER_DHCP_NOT_STOPPED If DHCP server or client is still running"},"sortText":"41604ec4tcpip_adapter_set_ip_info","filterText":"tcpip_adapter_set_ip_info","insertText":"tcpip_adapter_set_ip_info(${1:tcpip_adapter_if_t tcpip_if}, ${2:const tcpip_adapter_ip_info_t *ip_info})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"tcpip_adapter_set_ip_info(${1:tcpip_adapter_if_t tcpip_if}, ${2:const tcpip_adapter_ip_info_t *ip_info})"}},{"label":"sys_thread_sem_init()","kind":3,"detail":"sys_sem_t *","documentation":{"kind":"markdown","value":"From `\"arch/sys_arch.h\"`"},"sortText":"41717206sys_thread_sem_init","filterText":"sys_thread_sem_init","insertText":"sys_thread_sem_init()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"sys_thread_sem_init()"}},{"label":"nvs_flash_secure_init(nvs_sec_cfg_t *cfg)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs_flash.h\"`  \n@brief Initialize the default NVS partition.  \nThis API initialises the default NVS partition. The default NVS partition is the one that is labeled \"nvs\" in the partition table.  \n@param[in] cfg Security configuration (keys) to be used for NVS encryption/decryption.  \nIf cfg is NULL, no encryption is used.  \n@return  \n\\- ESP_OK if storage was successfully initialized.  \n\\- ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)  \n\\- ESP_ERR_NOT_FOUND if no partition with label \"nvs\" is found in the partition table  \n\\- one of the error codes from the underlying flash storage driver"},"sortText":"4174c735nvs_flash_secure_init","filterText":"nvs_flash_secure_init","insertText":"nvs_flash_secure_init(${1:nvs_sec_cfg_t *cfg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_flash_secure_init(${1:nvs_sec_cfg_t *cfg})"}},{"label":"nvs_flash_secure_init_partition(const char *partition_label, nvs_sec_cfg_t *cfg)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"nvs_flash.h\"`  \n@brief Initialize NVS flash storage for the specified partition.  \n@param[in] partition_label Label of the partition. Note that internally a reference to passed value is kept and it should be accessible for future operations  \n@param[in] cfg Security configuration (keys) to be used for NVS encryption/decryption.  \nIf cfg is null, no encryption/decryption is used.  \n@return  \n\\- ESP_OK if storage was successfully initialized.  \n\\- ESP_ERR_NVS_NO_FREE_PAGES if the NVS storage contains no empty pages (which may happen if NVS partition was truncated)  \n\\- ESP_ERR_NOT_FOUND if specified partition is not found in the partition table  \n\\- one of the error codes from the underlying flash storage driver"},"sortText":"4174c735nvs_flash_secure_init_partition","filterText":"nvs_flash_secure_init_partition","insertText":"nvs_flash_secure_init_partition(${1:const char *partition_label}, ${2:nvs_sec_cfg_t *cfg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"nvs_flash_secure_init_partition(${1:const char *partition_label}, ${2:nvs_sec_cfg_t *cfg})"}},{"label":"std::__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","kind":3,"detail":"_OutputIterator","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`"},"sortText":"42cb81c7__set_intersection","filterText":"__set_intersection","insertText":"std::__set_intersection(${1:_InputIterator1 __first1}, ${2:_InputIterator1 __last1}, ${3:_InputIterator2 __first2}, ${4:_InputIterator2 __last2}, ${5:_OutputIterator __result}, ${6:_Compare __comp})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":5}},"newText":"std::__set_intersection(${1:_InputIterator1 __first1}, ${2:_InputIterator1 __last1}, ${3:_InputIterator2 __first2}, ${4:_InputIterator2 __last2}, ${5:_OutputIterator __result}, ${6:_Compare __comp})"}}]},"jsonrpc":"2.0"}Content-Length: 731

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":5}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Sei'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":22},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 241

{"jsonrpc":"2.0","id":22,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":4},"context":{"triggerKind":1}}}
>>>
Content-Length: 48378

{"id":22,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPlotter()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_vec_t"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sensors_type_t"}},{"label":" HardwareSerial","kind":7,"sortText":"4017ae13HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"HardwareSerial"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send_cb_t"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"402cccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"HardwareSerial($0)"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SemaphoreHandle_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"seed48(${1:unsigned short *})"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"serialEventRun()"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":4}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":23},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":4}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":24},"contentChanges":[{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":23,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 11741

{"id":23,"result":{"isIncomplete":false,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fab0a3dHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fbe6666HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"serialEventRun()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40d0bb9dSERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40eb4dd7SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERVER_IDENTIFIER"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"SERIAL_8O2"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41240b6buartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":6}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":25},"contentChanges":[{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 732

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Seri'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":26},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 1112

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":7}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":24,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":26}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":27},"contentChanges":[{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"rangeLength":0,"text":"."}]}}Content-Length: 264

{"jsonrpc":"2.0","id":25,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":9},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 8330

{"id":25,"result":{"isIncomplete":false,"items":[{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"availableForWrite()"}},{"label":" baudRate()","kind":2,"detail":"uint32_t","sortText":"3ee51eb8baudRate","filterText":"baudRate","insertText":"baudRate()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"baudRate()"}},{"label":" begin(unsigned long baud, uint32_t config = SERIAL_8N1, int8_t rxPin = -1, int8_t txPin = -1, bool invert = false, unsigned long timeout_ms = 20000UL)","kind":2,"detail":"void","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"begin(${1:unsigned long baud})"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"flush($0)"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8read","filterText":"read","insertText":"read($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"read($0)"}},{"label":" setDebugOutput(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setDebugOutput","filterText":"setDebugOutput","insertText":"setDebugOutput(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"setDebugOutput(${1:bool})"}},{"label":" setRxBufferSize(size_t)","kind":2,"detail":"size_t","sortText":"3ee51eb8setRxBufferSize","filterText":"setRxBufferSize","insertText":"setRxBufferSize(${1:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"setRxBufferSize(${1:size_t})"}},{"label":" setRxInvert(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setRxInvert","filterText":"setRxInvert","insertText":"setRxInvert(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"setRxInvert(${1:bool})"}},{"label":" updateBaudRate(unsigned long baud)","kind":2,"detail":"void","sortText":"3ee51eb8updateBaudRate","filterText":"updateBaudRate","insertText":"updateBaudRate(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"updateBaudRate(${1:unsigned long baud})"}},{"label":" write()","kind":2,"detail":"[8 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"write($0)"}},{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3ef61ddaprint","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3efe9590println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"println($0)"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"clearWriteError()"}},{"label":" find()","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"find($0)"}},{"label":" findUntil()","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"getWriteError()"}},{"label":" parseFloat()","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"parseFloat()"}},{"label":" parseInt()","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"parseInt()"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f651eb8printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"printf(${1:const char *format, ...})"}},{"label":" readBytes()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"readBytes($0)"}},{"label":" readBytesUntil()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"readBytesUntil($0)"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":9},"end":{"line":271,"character":9}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 725

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_unqualified_id","source":"clang","message":"Expected unqualified-id"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":26,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":27}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":28},"contentChanges":[{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"rangeLength":0,"text":"p"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":29},"contentChanges":[{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":10}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 930

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":10}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'p' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":30},"contentChanges":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 931

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":11}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 932

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":12}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pre' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":31},"contentChanges":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":12}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 931

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":11}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 466

{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":11}},"message":"No member named 'pr' in 'HardwareSerial'","severity":1,"code":"no_member","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":27,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":32},"contentChanges":[{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":33},"contentChanges":[{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":10}},"rangeLength":1,"text":""}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":34},"contentChanges":[{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":9}},"rangeLength":1,"text":""}]}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":35},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 1112

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":7}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":36},"contentChanges":[{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 732

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Seri'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":37},"contentChanges":[{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 731

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":5}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Ser'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":38},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":4}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":39},"contentChanges":[{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'S'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":40},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":40}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":41},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":2}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":28,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":41}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":42},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":1}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 1335

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":29},"end":{"line":239,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":246,"character":12},"end":{"line":246,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":278,"character":11},"end":{"line":278,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:318:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":42}}}Content-Length: 282

{"jsonrpc":"2.0","id":29,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":214,"character":7},"end":{"line":214,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":29,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 282

{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":214,"character":7},"end":{"line":214,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":30,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":43},"contentChanges":[{"range":{"start":{"line":214,"character":2},"end":{"line":214,"character":2}},"rangeLength":0,"text":"// "}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":214,"character":10},"end":{"line":214,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":31,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":43}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":44},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"  "}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":44}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":45},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"S"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":32,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":5},"context":{"triggerKind":1}}}
>>>
Content-Length: 41264

{"id":32,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"Serial"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"size_t"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"serialPlotter()"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"STICK_PARITY_EN"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sketchSize_t"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SLEEP_MODE"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":5}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'S'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":46},"contentChanges":[{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"e"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":33,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 48378

{"id":33,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"serialPlotter()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sensors_vec_t"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sensors_type_t"}},{"label":" HardwareSerial","kind":7,"sortText":"4017ae13HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"HardwareSerial"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"esp_now_send_cb_t"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"402cccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"HardwareSerial($0)"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SemaphoreHandle_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"seed48(${1:unsigned short *})"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"serialEventRun()"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":47},"contentChanges":[{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"r"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":34,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":7},"context":{"triggerKind":3}}}
>>>
Content-Length: 45779

{"id":34,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fcb4e81HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fdbbbbbHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"Server"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"serialEventRun()"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"4078a156set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"set_rtc_memory_crc()"}},{"label":"spi_flash_erase_range(size_t start_address, size_t size)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase a range of flash sectors  \n@param start_address Address where erase operation has to start.  \nMust be 4kB-aligned  \n@param size Size of erased range, in bytes. Must be divisible by 4kB.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_range","filterText":"spi_flash_erase_range","insertText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})"}},{"label":"spi_flash_erase_sector(size_t sector)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase the Flash sector.  \n@param sector Sector number, the count starts at sector 0, 4KB per sector.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_sector","filterText":"spi_flash_erase_sector","insertText":"spi_flash_erase_sector(${1:size_t sector})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"spi_flash_erase_sector(${1:size_t sector})"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40b2b554system_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"WiFiServer","kind":7,"documentation":{"kind":"markdown","value":"From `\"WiFiServer.h\"`"},"sortText":"40b8812dWiFiServer","filterText":"WiFiServer","insertText":"WiFiServer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"WiFiServer"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40cbc334SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERVER_IDENTIFIER"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40cc3d24SERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"xthal_set_region_attribute(void *addr, unsigned int size, unsigned int cattr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset cache attribute (access modes) for a range of memory"},"sortText":"40f8a156xthal_set_region_attribute","filterText":"xthal_set_region_attribute","insertText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})"}},{"label":"xthal_set_region_translation(void *vaddr, void *paddr, unsigned int size, unsigned int cache_atr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation","filterText":"xthal_set_region_translation","insertText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})"}},{"label":"xthal_set_region_translation_raw(void *vaddr, void *paddr, unsigned int cattr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation_raw","filterText":"xthal_set_region_translation_raw","insertText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SERIAL_8O2"}},{"label":" esp_dport_access_sequence_reg_read(uint32_t reg)","kind":3,"detail":"uint32_t","sortText":"40fc06daesp_dport_access_sequence_reg_read","filterText":"esp_dport_access_sequence_reg_read","insertText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})"}},{"label":"gpio_install_isr_service(int intr_alloc_flags)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers.  \nThis function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.  \n@param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG\\_\\* values. See esp_intr_alloc.h for more info.  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_NO_MEM No memory to install this service  \n\\- ESP_ERR_INVALID_STATE ISR service already installed.  \n\\- ESP_ERR_NOT_FOUND No free interrupt found with the specified flags  \n\\- ESP_ERR_INVALID_ARG GPIO error"},"sortText":"4112d0aagpio_install_isr_service","filterText":"gpio_install_isr_service","insertText":"gpio_install_isr_service(${1:int intr_alloc_flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"gpio_install_isr_service(${1:int intr_alloc_flags})"}},{"label":"gpio_uninstall_isr_service()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Uninstall the driver's GPIO ISR service, freeing related resources."},"sortText":"4112d0aagpio_uninstall_isr_service","filterText":"gpio_uninstall_isr_service","insertText":"gpio_uninstall_isr_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"gpio_uninstall_isr_service()"}},{"label":"rmtSetRxThreshold(rmt_obj_t *rmt, uint32_t value)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-rmt.h\"`  \nSetting threshold for Rx completed"},"sortText":"41156184rmtSetRxThreshold","filterText":"rmtSetRxThreshold","insertText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41156184uartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"dns_clear_servers(bool keep_fallback)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"lwip/dns.h\"`"},"sortText":"41172137dns_clear_servers","filterText":"dns_clear_servers","insertText":"dns_clear_servers(${1:bool keep_fallback})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"dns_clear_servers(${1:bool keep_fallback})"}},{"label":"DPORT_SEQUENCE_REG_READ(uint32_t reg)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"soc/dport_access.h\"`  \n@brief Read value from register, NOT SMP-safe version.  \nThis method uses the pre-reading of the APB register before reading the register of the DPORT.  \nThere is not disable/enable interrupt.  \nThe difference from DPORT_REG_READ() is that the user himself must disable interrupts while DPORT reading.  \nThis implementation is useful for reading DORT registers in loop without stall other CPU. Note the usage example.  \nThe recommended way to read registers sequentially without stall other CPU is to use the method esp_dport_read_buffer(buff_out, address, num_words). It allows you to read registers in the buffer.  \n\\\\code{c} // This example shows how to use it.  \n{ // Use curly brackets to limit the visibility of variables in macros DPORT_INTERRUPT_DISABLE/RESTORE.  \nDPORT_INTERRUPT_DISABLE(); // Disable interrupt only on current CPU.  \nfor (i = 0; i \u003c max; ++i) { array[i] = DPORT_SEQUENCE_REG_READ(Address + i * 4); // reading DPORT registers } DPORT_INTERRUPT_RESTORE(); // restore the previous interrupt level }  \n\\\\endcode  \n@param reg Register address  \n@return Value"},"sortText":"411cf05eDPORT_SEQUENCE_REG_READ","filterText":"DPORT_SEQUENCE_REG_READ","insertText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})"}},{"label":"esp_rom_spiflash_erase_area(uint32_t start_addr, uint32_t area_len)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase some sectors.  \nPlease do not call this function in SDK.  \n@param uint32_t start_addr : Start addr to erase, should be sector aligned.  \n@param uint32_t area_len : Length to erase, should be sector aligned.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_area","filterText":"esp_rom_spiflash_erase_area","insertText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})"}},{"label":"esp_rom_spiflash_erase_block(uint32_t block_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a 64KB block of flash Uses SPI flash command D8H.  \nPlease do not call this function in SDK.  \n@param uint32_t block_num : Which block to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_block","filterText":"esp_rom_spiflash_erase_block","insertText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})"}},{"label":"esp_rom_spiflash_erase_chip()","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase whole flash chip.  \nPlease do not call this function in SDK.  \n@param None  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_chip","filterText":"esp_rom_spiflash_erase_chip","insertText":"esp_rom_spiflash_erase_chip()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"esp_rom_spiflash_erase_chip()"}},{"label":"esp_rom_spiflash_erase_sector(uint32_t sector_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a sector of flash.  \nUses SPI flash command 20H.  \nPlease do not call this function in SDK.  \n@param uint32_t sector_num : Which sector to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_sector","filterText":"esp_rom_spiflash_erase_sector","insertText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})"}},{"label":"xthal_tram_pending_to_service()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nTrampoline support functions:"},"sortText":"41276889xthal_tram_pending_to_service","filterText":"xthal_tram_pending_to_service","insertText":"xthal_tram_pending_to_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"xthal_tram_pending_to_service()"}},{"label":"hall_sensor_read()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Read Hall Sensor  \n@note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,  \nthe input of GPIO36 and GPIO39 will be pulled down for about 80ns.  \nWhen enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.  \nPlease refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.  \n@note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure these channels for use as ADC channels.  \n@note The ADC1 module must be enabled by calling adc1_config_width() before calling hall_sensor_read(). ADC1 should be configured for 12 bit readings, as the hall sensor readings are low values and do not cover the full range of the ADC.  \n@return The hall sensor reading."},"sortText":"413198efhall_sensor_read","filterText":"hall_sensor_read","insertText":"hall_sensor_read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"hall_sensor_read()"}},{"label":"lwip_send_r(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_send_r","filterText":"lwip_send_r","insertText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"lwip_sendmsg_r(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendmsg_r","filterText":"lwip_sendmsg_r","insertText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"lwip_sendto_r(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendto_r","filterText":"lwip_sendto_r","insertText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"lwip_setsockopt_r(int s, int level, int optname, const void *optval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_setsockopt_r","filterText":"lwip_setsockopt_r","insertText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})"}},{"label":"COOKIE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334COOKIE_SERVER","filterText":"COOKIE_SERVER","insertText":"COOKIE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"COOKIE_SERVER"}},{"label":"IMPRESS_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334IMPRESS_SERVER","filterText":"IMPRESS_SERVER","insertText":"IMPRESS_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"IMPRESS_SERVER"}},{"label":"LOG_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LOG_SERVER","filterText":"LOG_SERVER","insertText":"LOG_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"LOG_SERVER"}},{"label":"LPR_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LPR_SERVER","filterText":"LPR_SERVER","insertText":"LPR_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"LPR_SERVER"}},{"label":"NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334NAME_SERVER","filterText":"NAME_SERVER","insertText":"NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NAME_SERVER"}},{"label":"NAME_SERVICE_SEARCH","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NAME_SERVICE_SEARCH","filterText":"NAME_SERVICE_SEARCH","insertText":"NAME_SERVICE_SEARCH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NAME_SERVICE_SEARCH"}},{"label":"NDS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NDS_SERVERS","filterText":"NDS_SERVERS","insertText":"NDS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NDS_SERVERS"}},{"label":"NNTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334NNTP_SERVER","filterText":"NNTP_SERVER","insertText":"NNTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NNTP_SERVER"}},{"label":"SMTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334SMTP_SERVER","filterText":"SMTP_SERVER","insertText":"SMTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SMTP_SERVER"}},{"label":"STREETTALK_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334STREETTALK_SERVER","filterText":"STREETTALK_SERVER","insertText":"STREETTALK_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"STREETTALK_SERVER"}},{"label":"SWAP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334SWAP_SERVER","filterText":"SWAP_SERVER","insertText":"SWAP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"SWAP_SERVER"}},{"label":"TFTP_SERVER_NAME","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334TFTP_SERVER_NAME","filterText":"TFTP_SERVER_NAME","insertText":"TFTP_SERVER_NAME","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"TFTP_SERVER_NAME"}},{"label":"TIME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334TIME_SERVER","filterText":"TIME_SERVER","insertText":"TIME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"TIME_SERVER"}},{"label":"DEFAULT_FINGER_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_FINGER_SERVER","filterText":"DEFAULT_FINGER_SERVER","insertText":"DEFAULT_FINGER_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"DEFAULT_FINGER_SERVER"}},{"label":"DEFAULT_IRC_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_IRC_SERVER","filterText":"DEFAULT_IRC_SERVER","insertText":"DEFAULT_IRC_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"DEFAULT_IRC_SERVER"}},{"label":"DEFAULT_WWW_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_WWW_SERVER","filterText":"DEFAULT_WWW_SERVER","insertText":"DEFAULT_WWW_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"DEFAULT_WWW_SERVER"}},{"label":"DOMAIN_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cDOMAIN_NAME_SERVER","filterText":"DOMAIN_NAME_SERVER","insertText":"DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"DOMAIN_NAME_SERVER"}},{"label":"NETWORK_INFORMATION_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVERS","filterText":"NETWORK_INFORMATION_SERVERS","insertText":"NETWORK_INFORMATION_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETWORK_INFORMATION_SERVERS"}},{"label":"NETWORK_INFORMATION_SERVICE_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_SERVERS","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS"}},{"label":"POP3_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cPOP3_SERVER","filterText":"POP3_SERVER","insertText":"POP3_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"POP3_SERVER"}},{"label":"RESOURCE_LOCATION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cRESOURCE_LOCATION_SERVER","filterText":"RESOURCE_LOCATION_SERVER","insertText":"RESOURCE_LOCATION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"RESOURCE_LOCATION_SERVER"}},{"label":"NETWORK_TIME_PROTOCOL_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bNETWORK_TIME_PROTOCOL_SERVERS","filterText":"NETWORK_TIME_PROTOCOL_SERVERS","insertText":"NETWORK_TIME_PROTOCOL_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETWORK_TIME_PROTOCOL_SERVERS"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","kind":20,"detail":"tcpip_adapter_dhcp_option_id_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \nDomain name server"},"sortText":"41e04ec4TCPIP_ADAPTER_DOMAIN_NAME_SERVER","filterText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER"}},{"label":"X_WINDOW_SYSTEM_FONT_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41efcf5cX_WINDOW_SYSTEM_FONT_SERVER","filterText":"X_WINDOW_SYSTEM_FONT_SERVER","insertText":"X_WINDOW_SYSTEM_FONT_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"X_WINDOW_SYSTEM_FONT_SERVER"}},{"label":"ESP_ROM_SPIFLASH_RESULT_ERR","kind":20,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`"},"sortText":"42276889ESP_ROM_SPIFLASH_RESULT_ERR","filterText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"ESP_ROM_SPIFLASH_RESULT_ERR"}},{"label":"system_efuse_read_mac(uint8_t *mac)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Read hardware MAC address.  \nFunction has been renamed to esp_efuse_mac_get_default.  \nThis name will be removed in a future release.  \n@param mac hardware MAC address, length: 6 bytes.  \n@return ESP_OK on success"},"sortText":"42444e03system_efuse_read_mac","filterText":"system_efuse_read_mac","insertText":"system_efuse_read_mac(${1:uint8_t *mac})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"system_efuse_read_mac(${1:uint8_t *mac})"}},{"label":"NETBIOS_OVER_TCP_IP_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"426fcf5cNETBIOS_OVER_TCP_IP_NAME_SERVER","filterText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"NETBIOS_OVER_TCP_IP_NAME_SERVER"}},{"label":"std::__throw_system_error(int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003clist\u003e`"},"sortText":"430300b6__throw_system_error","filterText":"__throw_system_error","insertText":"std::__throw_system_error(${1:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":7}},"newText":"std::__throw_system_error(${1:int})"}}]},"jsonrpc":"2.0"}Content-Length: 731

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":7}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Ser'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":48},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"i"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":35,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":8},"context":{"triggerKind":3}}}
>>>
Content-Length: 11741

{"id":35,"result":{"isIncomplete":false,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fab0a3dHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fbe6666HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"serialEventRun()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40d0bb9dSERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40eb4dd7SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERVER_IDENTIFIER"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"SERIAL_8O2"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41240b6buartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":8}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":49},"contentChanges":[{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 732

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Seri'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":50},"contentChanges":[{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 1112

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":9}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":51},"contentChanges":[{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":10}},"rangeLength":0,"text":"."}]}}Content-Length: 265

{"jsonrpc":"2.0","id":36,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 8386

{"id":36,"result":{"isIncomplete":false,"items":[{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"availableForWrite()"}},{"label":" baudRate()","kind":2,"detail":"uint32_t","sortText":"3ee51eb8baudRate","filterText":"baudRate","insertText":"baudRate()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"baudRate()"}},{"label":" begin(unsigned long baud, uint32_t config = SERIAL_8N1, int8_t rxPin = -1, int8_t txPin = -1, bool invert = false, unsigned long timeout_ms = 20000UL)","kind":2,"detail":"void","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"begin(${1:unsigned long baud})"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"flush($0)"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8read","filterText":"read","insertText":"read($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"read($0)"}},{"label":" setDebugOutput(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setDebugOutput","filterText":"setDebugOutput","insertText":"setDebugOutput(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"setDebugOutput(${1:bool})"}},{"label":" setRxBufferSize(size_t)","kind":2,"detail":"size_t","sortText":"3ee51eb8setRxBufferSize","filterText":"setRxBufferSize","insertText":"setRxBufferSize(${1:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"setRxBufferSize(${1:size_t})"}},{"label":" setRxInvert(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setRxInvert","filterText":"setRxInvert","insertText":"setRxInvert(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"setRxInvert(${1:bool})"}},{"label":" updateBaudRate(unsigned long baud)","kind":2,"detail":"void","sortText":"3ee51eb8updateBaudRate","filterText":"updateBaudRate","insertText":"updateBaudRate(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"updateBaudRate(${1:unsigned long baud})"}},{"label":" write()","kind":2,"detail":"[8 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"write($0)"}},{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3ef61ddaprint","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3efe9590println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"println($0)"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"clearWriteError()"}},{"label":" find()","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"find($0)"}},{"label":" findUntil()","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"getWriteError()"}},{"label":" parseFloat()","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"parseFloat()"}},{"label":" parseInt()","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"parseInt()"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f651eb8printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"printf(${1:const char *format, ...})"}},{"label":" readBytes()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"readBytes($0)"}},{"label":" readBytesUntil()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"readBytesUntil($0)"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":11},"end":{"line":271,"character":11}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 725

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_unqualified_id","source":"clang","message":"Expected unqualified-id"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":52},"contentChanges":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"rangeLength":0,"text":"p"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":53},"contentChanges":[{"range":{"start":{"line":236,"character":12},"end":{"line":236,"character":12}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 931

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":12}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'p' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":54},"contentChanges":[{"range":{"start":{"line":236,"character":13},"end":{"line":236,"character":13}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 933

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":14}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pri' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":55},"contentChanges":[{"range":{"start":{"line":236,"character":14},"end":{"line":236,"character":14}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 934

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prin' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 469

{"jsonrpc":"2.0","id":37,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":15},"end":{"line":236,"character":15}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":15}},"message":"No member named 'prin' in 'HardwareSerial'","severity":1,"code":"no_member","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":37,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":55}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":56},"contentChanges":[{"range":{"start":{"line":236,"character":15},"end":{"line":236,"character":15}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 2651

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":16}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 2186

{"jsonrpc":"2.0","id":38,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":16},"end":{"line":236,"character":16}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":16}},"message":"Reference to non-static member function must be called\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":38,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":56}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":57},"contentChanges":[{"range":{"start":{"line":236,"character":16},"end":{"line":236,"character":16}},"rangeLength":0,"text":"l"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":58},"contentChanges":[{"range":{"start":{"line":236,"character":17},"end":{"line":236,"character":17}},"rangeLength":0,"text":"n"}]}}
>>>
Content-Length: 936

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":17}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'printl' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}Content-Length: 2843

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 2378

{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":39,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":58}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":59},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":0}},"rangeLength":0,"text":"  "}]}}
>>>
Content-Length: 2843

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":60},"contentChanges":[{"range":{"start":{"line":235,"character":2},"end":{"line":235,"character":2}},"rangeLength":0,"text":"  "}]}}
>>>
Content-Length: 2843

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":60}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":61},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":4}},"rangeLength":0,"text":"/"}]}}
>>>
Content-Length: 717

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 452

{"jsonrpc":"2.0","id":40,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"message":"Expected expression","severity":1,"code":"expected_expression","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":40,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":61}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":62},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 2843

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":62}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":63},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":4}},"rangeLength":0,"text":"S"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":41,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":5},"context":{"triggerKind":1}}}
>>>
Content-Length: 41264

{"id":41,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e7f66b8Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Serial"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"size_t"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"serialPlotter()"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STICK_PARITY_EN"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sketchSize_t"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SLEEP_MODE"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 926

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'S'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":64},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"rangeLength":0,"text":"r"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":42,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 7814

{"id":42,"result":{"isIncomplete":false,"items":[{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"srand48(long)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand48","filterText":"srand48","insertText":"srand48(${1:long})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"srand48(${1:long})"}},{"label":"strerror_r(int, char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"406fa427strerror_r","filterText":"strerror_r","insertText":"strerror_r(${1:int}, ${2:char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"strerror_r(${1:int}, ${2:char *}, ${3:size_t})"}},{"label":"strtok_r(char *, const char *, char **)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"406fa427strtok_r","filterText":"strtok_r","insertText":"strtok_r(${1:char *}, ${2:const char *}, ${3:char **})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"strtok_r(${1:char *}, ${2:const char *}, ${3:char **})"}},{"label":"SRCH_MSG_HEAD","kind":20,"detail":"RcvMsgState","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSRCH_MSG_HEAD","filterText":"SRCH_MSG_HEAD","insertText":"SRCH_MSG_HEAD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SRCH_MSG_HEAD"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"408c559bset_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"set_rtc_memory_crc()"}},{"label":"software_reset()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Software Reset digital core.  \nIt is not recommended to use this function in esp-idf, use esp_restart() instead.  \n@param None  \n@return None"},"sortText":"408c559bsoftware_reset","filterText":"software_reset","insertText":"software_reset()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"software_reset()"}},{"label":"software_reset_cpu(int cpu_no)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Software Reset digital core.  \nIt is not recommended to use this function in esp-idf, use esp_restart() instead.  \n@param int cpu_no : The CPU to reset, 0 for PRO CPU, 1 for APP CPU.  \n@return None"},"sortText":"408c559bsoftware_reset_cpu","filterText":"software_reset_cpu","insertText":"software_reset_cpu(${1:int cpu_no})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"software_reset_cpu(${1:int cpu_no})"}},{"label":"std::srand","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccstdlib\u003e`"},"sortText":"409aa539srand","filterText":"srand","insertText":"std::srand","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::srand"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"409cf05esoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"soc_reserved_region_t"}},{"label":"SDIO_RESET","kind":20,"detail":"RESET_REASON","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n6, Reset by SLC module, reset digital core"},"sortText":"40b4f201SDIO_RESET","filterText":"SDIO_RESET","insertText":"SDIO_RESET","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SDIO_RESET"}},{"label":"SW_RESET","kind":20,"detail":"RESET_REASON","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n3, Software reset digital core"},"sortText":"40b4f201SW_RESET","filterText":"SW_RESET","insertText":"SW_RESET","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SW_RESET"}},{"label":"std::swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)","kind":3,"detail":"_ForwardIterator2","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Swap the elements of two sequences.  \n@ingroup mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@return An iterator equal to @p first2+(last1-first1).  \nSwaps each element in the range @p [first1,last1) with the corresponding element in the range @p [first2,(last1-first1)).  \nThe ranges must not overlap."},"sortText":"40b4f201swap_ranges","filterText":"swap_ranges","insertText":"std::swap_ranges(${1:_ForwardIterator1 __first1}, ${2:_ForwardIterator1 __last1}, ${3:_ForwardIterator2 __first2})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::swap_ranges(${1:_ForwardIterator1 __first1}, ${2:_ForwardIterator1 __last1}, ${3:_ForwardIterator2 __first2})"}},{"label":"STATIC_ROUTE","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nIP Layer Parameters per Interface"},"sortText":"40f8d266STATIC_ROUTE","filterText":"STATIC_ROUTE","insertText":"STATIC_ROUTE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"STATIC_ROUTE"}},{"label":"system_restart()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@cond  \n@brief Restart system.  \nFunction has been renamed to esp_restart.  \nThis name will be removed in a future release."},"sortText":"422cd7c3system_restart","filterText":"system_restart","insertText":"system_restart()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_restart()"}},{"label":"system_restore()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Reset to default settings.  \nFunction has been deprecated, please use esp_wifi_restore instead.  \nThis name will be removed in a future release."},"sortText":"422cd7c3system_restore","filterText":"system_restore","insertText":"system_restore()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_restore()"}}]},"jsonrpc":"2.0"}Content-Length: 927

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":6}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Sr'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 452

{"jsonrpc":"2.0","id":43,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":6},"end":{"line":235,"character":6}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":6}},"message":"Unknown type name 'Sr'","severity":1,"code":"unknown_typename","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":43,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":64}}}Content-Length: 304

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":65},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 241

{"jsonrpc":"2.0","id":44,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":5},"context":{"triggerKind":1}}}
>>>
Content-Length: 41264

{"id":44,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Serial"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"size_t"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"serialPlotter()"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"400c559bSTICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STICK_PARITY_EN"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sketchSize_t"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SLEEP_MODE"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":5}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 926

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'S'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":66},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"rangeLength":0,"text":"e"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":45,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 48378

{"id":45,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"serialPlotter()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sensors_event_t"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"serialPrint()"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sensors_vec_t"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sensors_type_t"}},{"label":" HardwareSerial","kind":7,"sortText":"4017ae13HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"HardwareSerial"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"esp_now_send_cb_t"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"402cccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"HardwareSerial($0)"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SemaphoreHandle_t"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"seed48(${1:unsigned short *})"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"serialEventRun()"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":67},"contentChanges":[{"range":{"start":{"line":235,"character":6},"end":{"line":235,"character":6}},"rangeLength":0,"text":"r"}]}}Content-Length: 241

{"jsonrpc":"2.0","id":46,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":7},"context":{"triggerKind":3}}}
>>>
Content-Length: 927

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":6}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Se'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 45779

{"id":46,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fcb4e81HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fdbbbbbHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"Serial2"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"Server"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"serialEventRun()"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"4078a156set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"set_rtc_memory_crc()"}},{"label":"spi_flash_erase_range(size_t start_address, size_t size)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase a range of flash sectors  \n@param start_address Address where erase operation has to start.  \nMust be 4kB-aligned  \n@param size Size of erased range, in bytes. Must be divisible by 4kB.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_range","filterText":"spi_flash_erase_range","insertText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})"}},{"label":"spi_flash_erase_sector(size_t sector)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase the Flash sector.  \n@param sector Sector number, the count starts at sector 0, 4KB per sector.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_sector","filterText":"spi_flash_erase_sector","insertText":"spi_flash_erase_sector(${1:size_t sector})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"spi_flash_erase_sector(${1:size_t sector})"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40b2b554system_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"WiFiServer","kind":7,"documentation":{"kind":"markdown","value":"From `\"WiFiServer.h\"`"},"sortText":"40b8812dWiFiServer","filterText":"WiFiServer","insertText":"WiFiServer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"WiFiServer"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40cbc334SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERVER_IDENTIFIER"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40cc3d24SERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"xthal_set_region_attribute(void *addr, unsigned int size, unsigned int cattr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset cache attribute (access modes) for a range of memory"},"sortText":"40f8a156xthal_set_region_attribute","filterText":"xthal_set_region_attribute","insertText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})"}},{"label":"xthal_set_region_translation(void *vaddr, void *paddr, unsigned int size, unsigned int cache_atr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation","filterText":"xthal_set_region_translation","insertText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})"}},{"label":"xthal_set_region_translation_raw(void *vaddr, void *paddr, unsigned int cattr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation_raw","filterText":"xthal_set_region_translation_raw","insertText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fab196SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SERIAL_8O2"}},{"label":" esp_dport_access_sequence_reg_read(uint32_t reg)","kind":3,"detail":"uint32_t","sortText":"40fc06daesp_dport_access_sequence_reg_read","filterText":"esp_dport_access_sequence_reg_read","insertText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})"}},{"label":"gpio_install_isr_service(int intr_alloc_flags)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers.  \nThis function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.  \n@param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG\\_\\* values. See esp_intr_alloc.h for more info.  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_NO_MEM No memory to install this service  \n\\- ESP_ERR_INVALID_STATE ISR service already installed.  \n\\- ESP_ERR_NOT_FOUND No free interrupt found with the specified flags  \n\\- ESP_ERR_INVALID_ARG GPIO error"},"sortText":"4112d0aagpio_install_isr_service","filterText":"gpio_install_isr_service","insertText":"gpio_install_isr_service(${1:int intr_alloc_flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"gpio_install_isr_service(${1:int intr_alloc_flags})"}},{"label":"gpio_uninstall_isr_service()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Uninstall the driver's GPIO ISR service, freeing related resources."},"sortText":"4112d0aagpio_uninstall_isr_service","filterText":"gpio_uninstall_isr_service","insertText":"gpio_uninstall_isr_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"gpio_uninstall_isr_service()"}},{"label":"rmtSetRxThreshold(rmt_obj_t *rmt, uint32_t value)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-rmt.h\"`  \nSetting threshold for Rx completed"},"sortText":"41156184rmtSetRxThreshold","filterText":"rmtSetRxThreshold","insertText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41156184uartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"dns_clear_servers(bool keep_fallback)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"lwip/dns.h\"`"},"sortText":"41172137dns_clear_servers","filterText":"dns_clear_servers","insertText":"dns_clear_servers(${1:bool keep_fallback})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"dns_clear_servers(${1:bool keep_fallback})"}},{"label":"DPORT_SEQUENCE_REG_READ(uint32_t reg)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"soc/dport_access.h\"`  \n@brief Read value from register, NOT SMP-safe version.  \nThis method uses the pre-reading of the APB register before reading the register of the DPORT.  \nThere is not disable/enable interrupt.  \nThe difference from DPORT_REG_READ() is that the user himself must disable interrupts while DPORT reading.  \nThis implementation is useful for reading DORT registers in loop without stall other CPU. Note the usage example.  \nThe recommended way to read registers sequentially without stall other CPU is to use the method esp_dport_read_buffer(buff_out, address, num_words). It allows you to read registers in the buffer.  \n\\\\code{c} // This example shows how to use it.  \n{ // Use curly brackets to limit the visibility of variables in macros DPORT_INTERRUPT_DISABLE/RESTORE.  \nDPORT_INTERRUPT_DISABLE(); // Disable interrupt only on current CPU.  \nfor (i = 0; i \u003c max; ++i) { array[i] = DPORT_SEQUENCE_REG_READ(Address + i * 4); // reading DPORT registers } DPORT_INTERRUPT_RESTORE(); // restore the previous interrupt level }  \n\\\\endcode  \n@param reg Register address  \n@return Value"},"sortText":"411cf05eDPORT_SEQUENCE_REG_READ","filterText":"DPORT_SEQUENCE_REG_READ","insertText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})"}},{"label":"esp_rom_spiflash_erase_area(uint32_t start_addr, uint32_t area_len)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase some sectors.  \nPlease do not call this function in SDK.  \n@param uint32_t start_addr : Start addr to erase, should be sector aligned.  \n@param uint32_t area_len : Length to erase, should be sector aligned.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_area","filterText":"esp_rom_spiflash_erase_area","insertText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})"}},{"label":"esp_rom_spiflash_erase_block(uint32_t block_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a 64KB block of flash Uses SPI flash command D8H.  \nPlease do not call this function in SDK.  \n@param uint32_t block_num : Which block to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_block","filterText":"esp_rom_spiflash_erase_block","insertText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})"}},{"label":"esp_rom_spiflash_erase_chip()","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase whole flash chip.  \nPlease do not call this function in SDK.  \n@param None  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_chip","filterText":"esp_rom_spiflash_erase_chip","insertText":"esp_rom_spiflash_erase_chip()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"esp_rom_spiflash_erase_chip()"}},{"label":"esp_rom_spiflash_erase_sector(uint32_t sector_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a sector of flash.  \nUses SPI flash command 20H.  \nPlease do not call this function in SDK.  \n@param uint32_t sector_num : Which sector to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_sector","filterText":"esp_rom_spiflash_erase_sector","insertText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})"}},{"label":"xthal_tram_pending_to_service()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nTrampoline support functions:"},"sortText":"41276889xthal_tram_pending_to_service","filterText":"xthal_tram_pending_to_service","insertText":"xthal_tram_pending_to_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"xthal_tram_pending_to_service()"}},{"label":"hall_sensor_read()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Read Hall Sensor  \n@note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,  \nthe input of GPIO36 and GPIO39 will be pulled down for about 80ns.  \nWhen enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.  \nPlease refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.  \n@note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure these channels for use as ADC channels.  \n@note The ADC1 module must be enabled by calling adc1_config_width() before calling hall_sensor_read(). ADC1 should be configured for 12 bit readings, as the hall sensor readings are low values and do not cover the full range of the ADC.  \n@return The hall sensor reading."},"sortText":"413198efhall_sensor_read","filterText":"hall_sensor_read","insertText":"hall_sensor_read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"hall_sensor_read()"}},{"label":"lwip_send_r(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_send_r","filterText":"lwip_send_r","insertText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"lwip_sendmsg_r(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendmsg_r","filterText":"lwip_sendmsg_r","insertText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"lwip_sendto_r(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendto_r","filterText":"lwip_sendto_r","insertText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"lwip_setsockopt_r(int s, int level, int optname, const void *optval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_setsockopt_r","filterText":"lwip_setsockopt_r","insertText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})"}},{"label":"COOKIE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334COOKIE_SERVER","filterText":"COOKIE_SERVER","insertText":"COOKIE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"COOKIE_SERVER"}},{"label":"IMPRESS_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334IMPRESS_SERVER","filterText":"IMPRESS_SERVER","insertText":"IMPRESS_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"IMPRESS_SERVER"}},{"label":"LOG_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LOG_SERVER","filterText":"LOG_SERVER","insertText":"LOG_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"LOG_SERVER"}},{"label":"LPR_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LPR_SERVER","filterText":"LPR_SERVER","insertText":"LPR_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"LPR_SERVER"}},{"label":"NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334NAME_SERVER","filterText":"NAME_SERVER","insertText":"NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NAME_SERVER"}},{"label":"NAME_SERVICE_SEARCH","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NAME_SERVICE_SEARCH","filterText":"NAME_SERVICE_SEARCH","insertText":"NAME_SERVICE_SEARCH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NAME_SERVICE_SEARCH"}},{"label":"NDS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NDS_SERVERS","filterText":"NDS_SERVERS","insertText":"NDS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NDS_SERVERS"}},{"label":"NNTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334NNTP_SERVER","filterText":"NNTP_SERVER","insertText":"NNTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NNTP_SERVER"}},{"label":"SMTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334SMTP_SERVER","filterText":"SMTP_SERVER","insertText":"SMTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SMTP_SERVER"}},{"label":"STREETTALK_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334STREETTALK_SERVER","filterText":"STREETTALK_SERVER","insertText":"STREETTALK_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"STREETTALK_SERVER"}},{"label":"SWAP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334SWAP_SERVER","filterText":"SWAP_SERVER","insertText":"SWAP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"SWAP_SERVER"}},{"label":"TFTP_SERVER_NAME","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334TFTP_SERVER_NAME","filterText":"TFTP_SERVER_NAME","insertText":"TFTP_SERVER_NAME","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"TFTP_SERVER_NAME"}},{"label":"TIME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334TIME_SERVER","filterText":"TIME_SERVER","insertText":"TIME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"TIME_SERVER"}},{"label":"DEFAULT_FINGER_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_FINGER_SERVER","filterText":"DEFAULT_FINGER_SERVER","insertText":"DEFAULT_FINGER_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"DEFAULT_FINGER_SERVER"}},{"label":"DEFAULT_IRC_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_IRC_SERVER","filterText":"DEFAULT_IRC_SERVER","insertText":"DEFAULT_IRC_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"DEFAULT_IRC_SERVER"}},{"label":"DEFAULT_WWW_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_WWW_SERVER","filterText":"DEFAULT_WWW_SERVER","insertText":"DEFAULT_WWW_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"DEFAULT_WWW_SERVER"}},{"label":"DOMAIN_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cDOMAIN_NAME_SERVER","filterText":"DOMAIN_NAME_SERVER","insertText":"DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"DOMAIN_NAME_SERVER"}},{"label":"NETWORK_INFORMATION_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVERS","filterText":"NETWORK_INFORMATION_SERVERS","insertText":"NETWORK_INFORMATION_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETWORK_INFORMATION_SERVERS"}},{"label":"NETWORK_INFORMATION_SERVICE_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_SERVERS","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS"}},{"label":"POP3_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cPOP3_SERVER","filterText":"POP3_SERVER","insertText":"POP3_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"POP3_SERVER"}},{"label":"RESOURCE_LOCATION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cRESOURCE_LOCATION_SERVER","filterText":"RESOURCE_LOCATION_SERVER","insertText":"RESOURCE_LOCATION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"RESOURCE_LOCATION_SERVER"}},{"label":"NETWORK_TIME_PROTOCOL_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bNETWORK_TIME_PROTOCOL_SERVERS","filterText":"NETWORK_TIME_PROTOCOL_SERVERS","insertText":"NETWORK_TIME_PROTOCOL_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETWORK_TIME_PROTOCOL_SERVERS"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","kind":20,"detail":"tcpip_adapter_dhcp_option_id_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \nDomain name server"},"sortText":"41e04ec4TCPIP_ADAPTER_DOMAIN_NAME_SERVER","filterText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER"}},{"label":"X_WINDOW_SYSTEM_FONT_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41efcf5cX_WINDOW_SYSTEM_FONT_SERVER","filterText":"X_WINDOW_SYSTEM_FONT_SERVER","insertText":"X_WINDOW_SYSTEM_FONT_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"X_WINDOW_SYSTEM_FONT_SERVER"}},{"label":"ESP_ROM_SPIFLASH_RESULT_ERR","kind":20,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`"},"sortText":"42276889ESP_ROM_SPIFLASH_RESULT_ERR","filterText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"ESP_ROM_SPIFLASH_RESULT_ERR"}},{"label":"system_efuse_read_mac(uint8_t *mac)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Read hardware MAC address.  \nFunction has been renamed to esp_efuse_mac_get_default.  \nThis name will be removed in a future release.  \n@param mac hardware MAC address, length: 6 bytes.  \n@return ESP_OK on success"},"sortText":"42444e03system_efuse_read_mac","filterText":"system_efuse_read_mac","insertText":"system_efuse_read_mac(${1:uint8_t *mac})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"system_efuse_read_mac(${1:uint8_t *mac})"}},{"label":"NETBIOS_OVER_TCP_IP_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"426fcf5cNETBIOS_OVER_TCP_IP_NAME_SERVER","filterText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"NETBIOS_OVER_TCP_IP_NAME_SERVER"}},{"label":"std::__throw_system_error(int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003clist\u003e`"},"sortText":"430300b6__throw_system_error","filterText":"__throw_system_error","insertText":"std::__throw_system_error(${1:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":7}},"newText":"std::__throw_system_error(${1:int})"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":68},"contentChanges":[{"range":{"start":{"line":235,"character":7},"end":{"line":235,"character":7}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 928

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":7}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Ser'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 241

{"jsonrpc":"2.0","id":47,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":8},"context":{"triggerKind":3}}}
>>>
Content-Length: 11741

{"id":47,"result":{"isIncomplete":false,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e818f3aSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3eeffa26serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3f13a2a3serialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fab0a3dHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fbe6666HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bSerial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"403f858bserialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"serialEventRun()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40d0bb9dSERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40eb4dd7SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERVER_IDENTIFIER"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40fe06c0SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"SERIAL_8O2"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41240b6buartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":4},"end":{"line":270,"character":8}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}}]},"jsonrpc":"2.0"}Content-Length: 929

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":8}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'Seri'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":69},"contentChanges":[{"range":{"start":{"line":235,"character":8},"end":{"line":235,"character":8}},"rangeLength":0,"text":"a"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":70},"contentChanges":[{"range":{"start":{"line":235,"character":9},"end":{"line":235,"character":9}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 3410

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":9}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":48,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":48,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":70}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":71},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"rangeLength":0,"text":"P"}]}}
>>>
Content-Length: 933

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":11}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'SerialP'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":72},"contentChanges":[{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":11}},"rangeLength":0,"text":"r"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":73},"contentChanges":[{"range":{"start":{"line":235,"character":12},"end":{"line":235,"character":12}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 934

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":12}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'SerialPr'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 935

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":13}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'SerialPri'"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"severity":1,"code":"expected_semi_declaration","source":"clang","message":"Expected ';' at end of declaration (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":74},"contentChanges":[{"range":{"start":{"line":235,"character":13},"end":{"line":235,"character":13}},"rangeLength":0,"text":"n"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":75},"contentChanges":[{"range":{"start":{"line":235,"character":14},"end":{"line":235,"character":14}},"rangeLength":0,"text":"g"}]}}
>>>
Content-Length: 3596

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":14}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'SerialPrin'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here"},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"severity":3,"message":"'serialPrint' declared here\n\nEsp_Master.ino.cpp:271:5: error: use of undeclared identifier 'SerialPrin'; did you mean 'serialPrint'?"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3598

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here"},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"severity":3,"message":"'serialPrint' declared here\n\nEsp_Master.ino.cpp:271:5: error: use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'?"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":76},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":":"}]}}Content-Length: 265

{"jsonrpc":"2.0","id":49,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":16},"context":{"triggerKind":2,"triggerCharacter":":"}}}
>>>
Content-Length: 68

{"id":49,"result":{"isIncomplete":false,"items":[]},"jsonrpc":"2.0"}Content-Length: 2843

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":50,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":50,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":76}}}Content-Length: 284

{"jsonrpc":"2.0","id":51,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":51,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":77},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 3598

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here"},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"severity":3,"message":"'serialPrint' declared here\n\nEsp_Master.ino.cpp:271:5: error: use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'?"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":78},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"()"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":79},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":17}},"rangeLength":1,"text":")"}]}}Content-Length: 288

{"jsonrpc":"2.0","id":52,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":17},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 3598

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here"},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"severity":3,"message":"'serialPrint' declared here\n\nEsp_Master.ino.cpp:271:5: error: use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'?"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 92

{"id":52,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":79}}}Content-Length: 284

{"jsonrpc":"2.0","id":53,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":53,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":54,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":15}}}
>>>
Content-Length: 306

{"id":54,"result":[{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"kind":1},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"kind":1},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 593

{"jsonrpc":"2.0","id":55,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":12},"end":{"line":235,"character":12}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"message":"Use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here","severity":1,"code":"undeclared_var_use_suggest","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":55,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 593

{"jsonrpc":"2.0","id":56,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":11}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":15}},"message":"Use of undeclared identifier 'SerialPring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here","severity":1,"code":"undeclared_var_use_suggest","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":56,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":80},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":11}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 3596

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":14}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Serialring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here"},{"range":{"start":{"line":106,"character":5},"end":{"line":106,"character":16}},"severity":3,"message":"'serialPrint' declared here\n\nEsp_Master.ino.cpp:271:5: error: use of undeclared identifier 'Serialring'; did you mean 'serialPrint'?"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 592

{"jsonrpc":"2.0","id":57,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":14}},"message":"Use of undeclared identifier 'Serialring'; did you mean 'serialPrint'? (fix available)\n\nEsp_Master.ino.cpp:142:6: note: 'serialPrint' declared here","severity":1,"code":"undeclared_var_use_suggest","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":57,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":80}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":81},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"rangeLength":0,"text":"."}]}}Content-Length: 265

{"jsonrpc":"2.0","id":58,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 8386

{"id":58,"result":{"isIncomplete":false,"items":[{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"availableForWrite()"}},{"label":" baudRate()","kind":2,"detail":"uint32_t","sortText":"3ee51eb8baudRate","filterText":"baudRate","insertText":"baudRate()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"baudRate()"}},{"label":" begin(unsigned long baud, uint32_t config = SERIAL_8N1, int8_t rxPin = -1, int8_t txPin = -1, bool invert = false, unsigned long timeout_ms = 20000UL)","kind":2,"detail":"void","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"begin(${1:unsigned long baud})"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"flush($0)"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8read","filterText":"read","insertText":"read($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"read($0)"}},{"label":" setDebugOutput(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setDebugOutput","filterText":"setDebugOutput","insertText":"setDebugOutput(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"setDebugOutput(${1:bool})"}},{"label":" setRxBufferSize(size_t)","kind":2,"detail":"size_t","sortText":"3ee51eb8setRxBufferSize","filterText":"setRxBufferSize","insertText":"setRxBufferSize(${1:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"setRxBufferSize(${1:size_t})"}},{"label":" setRxInvert(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setRxInvert","filterText":"setRxInvert","insertText":"setRxInvert(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"setRxInvert(${1:bool})"}},{"label":" updateBaudRate(unsigned long baud)","kind":2,"detail":"void","sortText":"3ee51eb8updateBaudRate","filterText":"updateBaudRate","insertText":"updateBaudRate(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"updateBaudRate(${1:unsigned long baud})"}},{"label":" write()","kind":2,"detail":"[8 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"write($0)"}},{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3ef61ddaprint","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3efe9590println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"println($0)"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"clearWriteError()"}},{"label":" find()","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"find($0)"}},{"label":" findUntil()","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"getWriteError()"}},{"label":" parseFloat()","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"parseFloat()"}},{"label":" parseInt()","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"parseInt()"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f651eb8printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"printf(${1:const char *format, ...})"}},{"label":" readBytes()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"readBytes($0)"}},{"label":" readBytesUntil()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"readBytesUntil($0)"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 3232

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'ring' in 'HardwareSerial'"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":82},"contentChanges":[{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":11}},"rangeLength":0,"text":"p"}]}}
>>>
Content-Length: 3233

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":16}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pring' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 470

{"jsonrpc":"2.0","id":59,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":12},"end":{"line":235,"character":12}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":16}},"message":"No member named 'pring' in 'HardwareSerial'","severity":1,"code":"no_member","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":59,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":82}}}Content-Length: 221

{"jsonrpc":"2.0","id":60,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":13}}}
>>>
Content-Length: 37

{"id":60,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 470

{"jsonrpc":"2.0","id":61,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":16}},"message":"No member named 'pring' in 'HardwareSerial'","severity":1,"code":"no_member","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":61,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":83},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":84},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"r"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":62,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":16},"context":{"triggerKind":1}}}
>>>
Content-Length: 3232

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prin' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 68

{"id":62,"result":{"isIncomplete":false,"items":[]},"jsonrpc":"2.0"}Content-Length: 3233

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":16}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prinr' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":63,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":63,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":84}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":85},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":18}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 3233

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":16}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prinr' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":86},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":87},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 3232

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prin' in 'HardwareSerial'"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 242

{"jsonrpc":"2.0","id":64,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":16},"context":{"triggerKind":1}}}
>>>
Content-Length: 950

{"id":64,"result":{"isIncomplete":false,"items":[{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3e761ddaprint","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":16}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3efe9590println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":16}},"newText":"println($0)"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f651eb8printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":16}},"newText":"printf(${1:const char *format, ...})"}}]},"jsonrpc":"2.0"}Content-Length: 4949

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":16}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: possible target for call"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 2186

{"jsonrpc":"2.0","id":65,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":16}},"message":"Reference to non-static member function must be called\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":65,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":87}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":88},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"rangeLength":0,"text":"()"}]}}Content-Length: 288

{"jsonrpc":"2.0","id":66,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":17},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 5717

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":16}},"severity":1,"code":"ovl_no_viable_member_function_in_call","source":"clang","message":"No matching member function for call to 'print'\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: candidate function not viable: requires at least argument 'timeinfo', but no arguments were provided"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 182

{"id":66,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 310

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":89},"contentChanges":[{"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":17}},"rangeLength":0,"text":"\"\""}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":90},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":19}},"rangeLength":1,"text":"\""}]}}Content-Length: 284

{"jsonrpc":"2.0","id":67,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":67,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":90}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":91},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"rangeLength":0,"text":"O"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":68,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":19},"end":{"line":235,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":68,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":92},"contentChanges":[{"range":{"start":{"line":235,"character":19},"end":{"line":235,"character":19}},"rangeLength":0,"text":"v"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":93},"contentChanges":[{"range":{"start":{"line":235,"character":20},"end":{"line":235,"character":20}},"rangeLength":0,"text":"e"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":94},"contentChanges":[{"range":{"start":{"line":235,"character":21},"end":{"line":235,"character":21}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":69,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":22},"end":{"line":235,"character":22}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":69,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":94}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":95},"contentChanges":[{"range":{"start":{"line":235,"character":22},"end":{"line":235,"character":22}},"rangeLength":0,"text":"f"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":96},"contentChanges":[{"range":{"start":{"line":235,"character":23},"end":{"line":235,"character":23}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":97},"contentChanges":[{"range":{"start":{"line":235,"character":24},"end":{"line":235,"character":24}},"rangeLength":0,"text":"o"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":98},"contentChanges":[{"range":{"start":{"line":235,"character":25},"end":{"line":235,"character":25}},"rangeLength":0,"text":"w"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":99},"contentChanges":[{"range":{"start":{"line":235,"character":26},"end":{"line":235,"character":26}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":70,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":27},"end":{"line":235,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":70,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 177

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":99}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":100},"contentChanges":[{"range":{"start":{"line":235,"character":27},"end":{"line":235,"character":27}},"rangeLength":0,"text":"S"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":101},"contentChanges":[{"range":{"start":{"line":235,"character":28},"end":{"line":235,"character":28}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":102},"contentChanges":[{"range":{"start":{"line":235,"character":29},"end":{"line":235,"character":29}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":103},"contentChanges":[{"range":{"start":{"line":235,"character":30},"end":{"line":235,"character":30}},"rangeLength":0,"text":"c"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":104},"contentChanges":[{"range":{"start":{"line":235,"character":31},"end":{"line":235,"character":31}},"rangeLength":0,"text":"k"}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":71,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":32},"end":{"line":235,"character":32}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":71,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":104}}}Content-Length: 284

{"jsonrpc":"2.0","id":72,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":72,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":73,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":73,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":74,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":74,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":105},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":105}}}Content-Length: 284

{"jsonrpc":"2.0","id":75,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":33},"end":{"line":235,"character":33}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":75,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":106},"contentChanges":[{"range":{"start":{"line":235,"character":33},"end":{"line":235,"character":33}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":107},"contentChanges":[{"range":{"start":{"line":235,"character":34},"end":{"line":235,"character":34}},"rangeLength":0,"text":":"}]}}Content-Length: 265

{"jsonrpc":"2.0","id":76,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":35},"context":{"triggerKind":2,"triggerCharacter":":"}}}
>>>
Content-Length: 68

{"id":76,"result":{"isIncomplete":false,"items":[]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":77,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":18}}}
>>>
Content-Length: 217

{"id":77,"result":[{"range":{"start":{"line":116,"character":9},"end":{"line":116,"character":16}},"kind":1},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":18}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":107}}}Content-Length: 2378

{"jsonrpc":"2.0","id":78,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":78,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":108},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"rangeLength":0,"text":"*"}]}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":109},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"rangeLength":0,"text":"()"}]}}
>>>
Content-Length: 920

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 288

{"jsonrpc":"2.0","id":79,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":20},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 922

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":21}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"}]},"jsonrpc":"2.0"}Content-Length: 92

{"id":79,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}
<<<
Content-Length: 456

{"jsonrpc":"2.0","id":80,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":20}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":21}},"message":"Expected expression","severity":1,"code":"expected_expression","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":80,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":109}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":110},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":21}},"rangeLength":2,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":111},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":19}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 920

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"}]},"jsonrpc":"2.0"}Content-Length: 3046

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 2378

{"jsonrpc":"2.0","id":81,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":18}},"message":"Reference to non-static member function must be called; did you mean to call it with no arguments? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:96:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:97:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:98:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:99:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:100:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:101:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:102:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:103:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:104:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:105:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:106:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:107:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:108:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:109:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:110:12:\nnote: possible target for call","severity":1,"code":"bound_member_function","source":"clang"}]}}}
>>>
Content-Length: 189

{"id":81,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":112},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"rangeLength":0,"text":"()"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":113},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":20}},"rangeLength":1,"text":")"}]}}Content-Length: 288

{"jsonrpc":"2.0","id":82,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":20},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 951

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 92

{"id":82,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":83,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":20}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":83,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":113}}}Content-Length: 284

{"jsonrpc":"2.0","id":84,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":84,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":85,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":20}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":85,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":86,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":10}}}
>>>
Content-Length: 39

{"id":86,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":87,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":87,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":114},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"rangeLength":0,"text":"u"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":88,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":20},"context":{"triggerKind":1}}}
>>>
Content-Length: 56470

{"id":88,"result":{"isIncomplete":true,"items":[{"label":"uint8_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"3e4cb213uint8_t","filterText":"uint8_t","insertText":"uint8_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint8_t"}},{"label":"uint32_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"3ec62f9fuint32_t","filterText":"uint32_t","insertText":"uint32_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint32_t"}},{"label":"uint16_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"3ee12708uint16_t","filterText":"uint16_t","insertText":"uint16_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint16_t"}},{"label":" union","kind":14,"sortText":"3f000000union","filterText":"union","insertText":"union","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"union"}},{"label":" unsigned","kind":14,"sortText":"3f000000unsigned","filterText":"unsigned","insertText":"unsigned","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"unsigned"}},{"label":"u32_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"arch/cc.h\"`"},"sortText":"3f0f35dfu32_t","filterText":"u32_t","insertText":"u32_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"u32_t"}},{"label":" ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"Simplified macro for receiving task notification.  \nconfigUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.  \nWhen configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).  \nEvents can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.  \nA notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.  \nulTaskNotifyTake() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the equivalent action that instead uses a task notification is ulTaskNotifyTake().  \nWhen a task is using its notification value as a binary or counting semaphore other tasks should send notifications to it using the xTaskNotifyGive() macro, or xTaskNotify() function with the eAction parameter set to eIncrement.  \nulTaskNotifyTake() can either clear the task's notification value to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the task's notification value on exit, in which case the notification value acts like a counting semaphore.  \nA task can use ulTaskNotifyTake() to [optionally] block to wait for a the task's notification value to be non-zero. The task does not consume any CPU time while it is in the Blocked state.  \nWhere as xTaskNotifyWait() will return when a notification is pending,  \nulTaskNotifyTake() will return when the task's notification value is not zero.  \nSee http://www.FreeRTOS.org/RTOS-task-notifications.html for details.  \n@param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's notification value is decremented when the function exits. In this way the notification value acts like a counting semaphore. If xClearCountOnExit is not pdFALSE then the task's notification value is cleared to zero when the function exits. In this way the notification value acts like a binary semaphore.  \n@param xTicksToWait The maximum amount of time that the task should wait in the Blocked state for the task's notification value to be greater than zero,  \nshould the count not already be greater than zero when ulTaskNotifyTake() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks,  \nthe macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.  \n@return The task's notification count before it is either cleared to zero or decremented (see the xClearCountOnExit parameter).  \n\\\\ingroup TaskNotifications"},"sortText":"3fefa429ulTaskNotifyTake","filterText":"ulTaskNotifyTake","insertText":"ulTaskNotifyTake(${1:BaseType_t xClearCountOnExit}, ${2:TickType_t xTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ulTaskNotifyTake(${1:BaseType_t xClearCountOnExit}, ${2:TickType_t xTicksToWait})"}},{"label":" uxTaskGetNumberOfTasks()","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get current number of tasks  \n@return The number of tasks that the real time kernel is currently managing.  \nThis includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count.  \n\\\\ingroup TaskUtils"},"sortText":"3fefa429uxTaskGetNumberOfTasks","filterText":"uxTaskGetNumberOfTasks","insertText":"uxTaskGetNumberOfTasks()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskGetNumberOfTasks()"}},{"label":" uxTaskGetSnapshotAll(TaskSnapshot_t *const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t *const pxTcbSz)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"This function fills array with TaskSnapshot_t structures for every task in the system.  \nUsed by core dump facility to get snapshots of all tasks in the system.  \nOnly available when configENABLE_TASK_SNAPSHOT is set to 1.  \n@param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.  \n@param uxArraySize Size of tasks snapshots array.  \n@param pxTcbSz Pointer to store size of TCB.  \n@return Number of elements stored in array."},"sortText":"3fefa429uxTaskGetSnapshotAll","filterText":"uxTaskGetSnapshotAll","insertText":"uxTaskGetSnapshotAll(${1:TaskSnapshot_t *const pxTaskSnapshotArray}, ${2:const UBaseType_t uxArraySize}, ${3:UBaseType_t *const pxTcbSz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskGetSnapshotAll(${1:TaskSnapshot_t *const pxTaskSnapshotArray}, ${2:const UBaseType_t uxArraySize}, ${3:UBaseType_t *const pxTcbSz})"}},{"label":" uxTaskGetStackHighWaterMark(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Returns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created."},"sortText":"3fefa429uxTaskGetStackHighWaterMark","filterText":"uxTaskGetStackHighWaterMark","insertText":"uxTaskGetStackHighWaterMark(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskGetStackHighWaterMark(${1:TaskHandle_t xTask})"}},{"label":" uxTaskGetSystemState(TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get the state of tasks in the system.  \nconfigUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for uxTaskGetSystemState() to be available.  \nuxTaskGetSystemState() populates an TaskStatus_t structure for each task in the system. TaskStatus_t structures contain, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. See the TaskStatus_t structure definition in this file for the full member list.  \n@note This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.  \n@param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.  \nThe array must contain at least one TaskStatus_t structure for each task that is under the control of the RTOS. The number of tasks under the control of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.  \n@param uxArraySize The size of the array pointed to by the pxTaskStatusArray parameter. The size is specified as the number of indexes in the array, or the number of TaskStatus_t structures contained in the array, not by the number of bytes in the array.  \n@param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in FreeRTOSConfig.h then \\*pulTotalRunTime is set by uxTaskGetSystemState() to the total run time (as defined by the run time stats clock, see http://www.freertos.org/rtos-run-time-stats.html) since the target booted.  \npulTotalRunTime can be set to NULL to omit the total run time information.  \n@return The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.  \nExample usage:  \n@code{c} // This example demonstrates how a human readable table of run time stats // information is generated from raw data provided by uxTaskGetSystemState().  \n// The human readable table is written to pcWriteBuffer void vTaskGetRunTimeStats( char \\*pcWriteBuffer ) { TaskStatus_t \\*pxTaskStatusArray;  \nvolatile UBaseType_t uxArraySize, x;  \nuint32_t ulTotalRunTime, ulStatsAsPercentage;  \n// Make sure the write buffer does not contain a string.  \n\\*pcWriteBuffer = 0x00;  \n// Take a snapshot of the number of tasks in case it changes while this // function is executing.  \nuxArraySize = uxTaskGetNumberOfTasks();  \n// Allocate a TaskStatus_t structure for each task. An array could be // allocated statically at compile time.  \npxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );  \nif( pxTaskStatusArray != NULL ) { // Generate raw status information about each task.  \nuxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, \u0026ulTotalRunTime );  \n// For percentage calculations.  \nulTotalRunTime /= 100UL;  \n// Avoid divide by zero errors.  \nif( ulTotalRunTime \u003e 0 ) { // For each populated position in the pxTaskStatusArray array,  \n// format the raw data as human readable ASCII data for( x = 0; x \u003c uxArraySize; x++ ) { // What percentage of the total run time has the task used?  \n// This will always be rounded down to the nearest integer.  \n// ulTotalRunTimeDiv100 has already been divided by 100.  \nulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;  \nif( ulStatsAsPercentage \u003e 0UL ) { sprintf( pcWriteBuffer, \"%s\\\\t\\\\t%lu\\\\t\\\\t%lu%%\\\\r\\\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );  \n} else { // If the percentage is zero here then the task has // consumed less than 1% of the total run time.  \nsprintf( pcWriteBuffer, \"%s\\\\t\\\\t%lu\\\\t\\\\t\u003c1%%\\\\r\\\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );  \n}  \npcWriteBuffer += strlen( ( char * ) pcWriteBuffer );  \n} }  \n// The array is no longer needed, free the memory it consumes.  \nvPortFree( pxTaskStatusArray );  \n} }  \n@endcode"},"sortText":"3fefa429uxTaskGetSystemState","filterText":"uxTaskGetSystemState","insertText":"uxTaskGetSystemState(${1:TaskStatus_t *const pxTaskStatusArray}, ${2:const UBaseType_t uxArraySize}, ${3:uint32_t *const pulTotalRunTime})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskGetSystemState(${1:TaskStatus_t *const pxTaskStatusArray}, ${2:const UBaseType_t uxArraySize}, ${3:uint32_t *const pulTotalRunTime})"}},{"label":" uxTaskGetTaskNumber(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get the uxTCBNumber assigned to the task referenced by the xTask parameter."},"sortText":"3fefa429uxTaskGetTaskNumber","filterText":"uxTaskGetTaskNumber","insertText":"uxTaskGetTaskNumber(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskGetTaskNumber(${1:TaskHandle_t xTask})"}},{"label":" uxTaskPriorityGet(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Obtain the priority of any task.  \nINCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.  \nSee the configuration section for more information.  \n@param xTask Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.  \n@return The priority of xTask.  \nExample usage:  \n@code{c} void vAFunction( void ) { TaskHandle_t xHandle;  \n// Create a task, storing the handle.  \nxTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, \u0026xHandle );  \n// ...  \n// Use the handle to obtain the priority of the created task.  \n// It was created with tskIDLE_PRIORITY, but may have changed // it itself.  \nif( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY ) { // The task has changed it's priority.  \n}  \n// ...  \n// Is our priority higher than the created task?  \nif( uxTaskPriorityGet( xHandle ) \u003c uxTaskPriorityGet( NULL ) ) { // Our priority (obtained using NULL handle) is higher.  \n} }  \n@endcode  \n\\\\ingroup TaskCtrl"},"sortText":"3fefa429uxTaskPriorityGet","filterText":"uxTaskPriorityGet","insertText":"uxTaskPriorityGet(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskPriorityGet(${1:TaskHandle_t xTask})"}},{"label":" uxTaskPriorityGetFromISR(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"A version of uxTaskPriorityGet() that can be used from an ISR.  \n@param xTask Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.  \n@return The priority of xTask."},"sortText":"3fefa429uxTaskPriorityGetFromISR","filterText":"uxTaskPriorityGetFromISR","insertText":"uxTaskPriorityGetFromISR(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskPriorityGetFromISR(${1:TaskHandle_t xTask})"}},{"label":" uxTaskResetEventItemValue()","kind":3,"detail":"TickType_t","documentation":{"kind":"markdown","value":"THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE. THEY ARE USED BY THE EVENT BITS MODULE."},"sortText":"3fefa429uxTaskResetEventItemValue","filterText":"uxTaskResetEventItemValue","insertText":"uxTaskResetEventItemValue()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxTaskResetEventItemValue()"}},{"label":"uxPortCompareSetExtram(volatile uint32_t *addr, uint32_t compare, uint32_t *set)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"freertos/portable.h\"`"},"sortText":"400c559buxPortCompareSetExtram","filterText":"uxPortCompareSetExtram","insertText":"uxPortCompareSetExtram(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxPortCompareSetExtram(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})"}},{"label":"uint64_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"40221fdauint64_t","filterText":"uint64_t","insertText":"uint64_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint64_t"}},{"label":"uart_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"402bcc2fuart_t","filterText":"uart_t","insertText":"uart_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_t"}},{"label":"UDP","kind":7,"documentation":{"kind":"markdown","value":"From `\"Udp.h\"`"},"sortText":"403f858bUDP","filterText":"UDP","insertText":"UDP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UDP"}},{"label":"uint_fast16_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"403f858buint_fast16_t","filterText":"uint_fast16_t","insertText":"uint_fast16_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint_fast16_t"}},{"label":"uint_least8_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"stdint.h\"`"},"sortText":"403f858buint_least8_t","filterText":"uint_least8_t","insertText":"uint_least8_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint_least8_t"}},{"label":"ultoa(unsigned long val, char *s, int radix)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"stdlib_noniso.h\"`"},"sortText":"403f858bultoa","filterText":"ultoa","insertText":"ultoa(${1:unsigned long val}, ${2:char *s}, ${3:int radix})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ultoa(${1:unsigned long val}, ${2:char *s}, ${3:int radix})"}},{"label":"ungetc(int, FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bungetc","filterText":"ungetc","insertText":"ungetc(${1:int}, ${2:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ungetc(${1:int}, ${2:FILE *})"}},{"label":"unsetenv(const char *__string)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bunsetenv","filterText":"unsetenv","insertText":"unsetenv(${1:const char *__string})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"unsetenv(${1:const char *__string})"}},{"label":"utoa(unsigned int, char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858butoa","filterText":"utoa","insertText":"utoa(${1:unsigned int}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"utoa(${1:unsigned int}, ${2:char *}, ${3:int})"}},{"label":"uartAvailable(uart_t *uart)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartAvailable","filterText":"uartAvailable","insertText":"uartAvailable(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartAvailable(${1:uart_t *uart})"}},{"label":"uartAvailableForWrite(uart_t *uart)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartAvailableForWrite","filterText":"uartAvailableForWrite","insertText":"uartAvailableForWrite(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartAvailableForWrite(${1:uart_t *uart})"}},{"label":"uartBegin(uint8_t uart_nr, uint32_t baudrate, uint32_t config, int8_t rxPin, int8_t txPin, uint16_t queueLen, bool inverted)","kind":3,"detail":"uart_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartBegin","filterText":"uartBegin","insertText":"uartBegin(${1:uint8_t uart_nr}, ${2:uint32_t baudrate}, ${3:uint32_t config}, ${4:int8_t rxPin}, ${5:int8_t txPin}, ${6:uint16_t queueLen}, ${7:bool inverted})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartBegin(${1:uint8_t uart_nr}, ${2:uint32_t baudrate}, ${3:uint32_t config}, ${4:int8_t rxPin}, ${5:int8_t txPin}, ${6:uint16_t queueLen}, ${7:bool inverted})"}},{"label":"uartDetectBaudrate(uart_t *uart)","kind":3,"detail":"unsigned long","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartDetectBaudrate","filterText":"uartDetectBaudrate","insertText":"uartDetectBaudrate(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartDetectBaudrate(${1:uart_t *uart})"}},{"label":"uartEnd(uart_t *uart, uint8_t rxPin, uint8_t txPin)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartEnd","filterText":"uartEnd","insertText":"uartEnd(${1:uart_t *uart}, ${2:uint8_t rxPin}, ${3:uint8_t txPin})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartEnd(${1:uart_t *uart}, ${2:uint8_t rxPin}, ${3:uint8_t txPin})"}},{"label":"uartFlush(uart_t *uart)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartFlush","filterText":"uartFlush","insertText":"uartFlush(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartFlush(${1:uart_t *uart})"}},{"label":"uartFlushTxOnly(uart_t *uart, bool txOnly)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartFlushTxOnly","filterText":"uartFlushTxOnly","insertText":"uartFlushTxOnly(${1:uart_t *uart}, ${2:bool txOnly})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartFlushTxOnly(${1:uart_t *uart}, ${2:bool txOnly})"}},{"label":"uartGetBaudRate(uart_t *uart)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartGetBaudRate","filterText":"uartGetBaudRate","insertText":"uartGetBaudRate(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartGetBaudRate(${1:uart_t *uart})"}},{"label":"uartGetDebug()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartGetDebug","filterText":"uartGetDebug","insertText":"uartGetDebug()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartGetDebug()"}},{"label":"uartPeek(uart_t *uart)","kind":3,"detail":"uint8_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartPeek","filterText":"uartPeek","insertText":"uartPeek(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartPeek(${1:uart_t *uart})"}},{"label":"uartRead(uart_t *uart)","kind":3,"detail":"uint8_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartRead","filterText":"uartRead","insertText":"uartRead(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartRead(${1:uart_t *uart})"}},{"label":"uartResizeRxBuffer(uart_t *uart, size_t new_size)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartResizeRxBuffer","filterText":"uartResizeRxBuffer","insertText":"uartResizeRxBuffer(${1:uart_t *uart}, ${2:size_t new_size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartResizeRxBuffer(${1:uart_t *uart}, ${2:size_t new_size})"}},{"label":"uartRxActive(uart_t *uart)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartRxActive","filterText":"uartRxActive","insertText":"uartRxActive(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartRxActive(${1:uart_t *uart})"}},{"label":"uartSetBaudRate(uart_t *uart, uint32_t baud_rate)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartSetBaudRate","filterText":"uartSetBaudRate","insertText":"uartSetBaudRate(${1:uart_t *uart}, ${2:uint32_t baud_rate})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartSetBaudRate(${1:uart_t *uart}, ${2:uint32_t baud_rate})"}},{"label":"uartSetDebug(uart_t *uart)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartSetDebug","filterText":"uartSetDebug","insertText":"uartSetDebug(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartSetDebug(${1:uart_t *uart})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"uartStartDetectBaudrate(uart_t *uart)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartStartDetectBaudrate","filterText":"uartStartDetectBaudrate","insertText":"uartStartDetectBaudrate(${1:uart_t *uart})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartStartDetectBaudrate(${1:uart_t *uart})"}},{"label":"uartWrite(uart_t *uart, uint8_t c)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartWrite","filterText":"uartWrite","insertText":"uartWrite(${1:uart_t *uart}, ${2:uint8_t c})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartWrite(${1:uart_t *uart}, ${2:uint8_t c})"}},{"label":"uartWriteBuf(uart_t *uart, const uint8_t *data, size_t len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uartWriteBuf","filterText":"uartWriteBuf","insertText":"uartWriteBuf(${1:uart_t *uart}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uartWriteBuf(${1:uart_t *uart}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"uart_struct_t","kind":22,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40500923uart_struct_t","filterText":"uart_struct_t","insertText":"uart_struct_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_struct_t"}},{"label":"UART0_TRIG_EN","kind":20,"detail":"WAKEUP_ENABLE","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68UART0_TRIG_EN","filterText":"UART0_TRIG_EN","insertText":"UART0_TRIG_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UART0_TRIG_EN"}},{"label":"UART1_TRIG","kind":20,"detail":"WAKEUP_REASON","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68UART1_TRIG","filterText":"UART1_TRIG","insertText":"UART1_TRIG","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UART1_TRIG"}},{"label":"UART_RCV_TMOUT_INT_FLAG","kind":20,"detail":"UartIntType","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UART_RCV_TMOUT_INT_FLAG","filterText":"UART_RCV_TMOUT_INT_FLAG","insertText":"UART_RCV_TMOUT_INT_FLAG","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UART_RCV_TMOUT_INT_FLAG"}},{"label":"UBaseType_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/portmacro.h\"`"},"sortText":"405d8e68UBaseType_t","filterText":"UBaseType_t","insertText":"UBaseType_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UBaseType_t"}},{"label":"UNDER_WRITE","kind":20,"detail":"RcvMsgBuffState","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UNDER_WRITE","filterText":"UNDER_WRITE","insertText":"UNDER_WRITE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UNDER_WRITE"}},{"label":"UartBautRate","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartBautRate","filterText":"UartBautRate","insertText":"UartBautRate","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartBautRate"}},{"label":"UartDevice","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartDevice","filterText":"UartDevice","insertText":"UartDevice","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartDevice"}},{"label":"UartFlowCtrl","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartFlowCtrl","filterText":"UartFlowCtrl","insertText":"UartFlowCtrl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartFlowCtrl"}},{"label":"UartIntType","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartIntType","filterText":"UartIntType","insertText":"UartIntType","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartIntType"}},{"label":"UartParityMode","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartParityMode","filterText":"UartParityMode","insertText":"UartParityMode","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartParityMode"}},{"label":"UartStopBitsNum","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68UartStopBitsNum","filterText":"UartStopBitsNum","insertText":"UartStopBitsNum","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UartStopBitsNum"}},{"label":"Uart_Init(uint8_t uart_no, uint32_t clock)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Init uart0 or uart1 for UART download booting mode.  \nPlease do not call this function in SDK.  \n@param uint8_t uart_no : 0 for UART0, else for UART1.  \n@param uint32_t clock : clock used by uart module, to adjust baudrate.  \n@return None"},"sortText":"405d8e68Uart_Init","filterText":"Uart_Init","insertText":"Uart_Init(${1:uint8_t uart_no}, ${2:uint32_t clock})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"Uart_Init(${1:uint8_t uart_no}, ${2:uint32_t clock})"}},{"label":"UserFrame","kind":8,"documentation":{"kind":"markdown","value":"From `\"xtensa/xtruntime-frames.h\"`"},"sortText":"405d8e68UserFrame","filterText":"UserFrame","insertText":"UserFrame","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UserFrame"}},{"label":"u_char","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68u_char","filterText":"u_char","insertText":"u_char","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"u_char"}},{"label":"u_int","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68u_int","filterText":"u_int","insertText":"u_int","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"u_int"}},{"label":"u_long","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68u_long","filterText":"u_long","insertText":"u_long","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"u_long"}},{"label":"u_short","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68u_short","filterText":"u_short","insertText":"u_short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"u_short"}},{"label":"uart_baudrate_detect(uint8_t uart_no, uint8_t is_sync)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Init uart0 or uart1 for UART download booting mode.  \nPlease do not call this function in SDK.  \n@param uint8_t uart_no : 0 for UART0, 1 for UART1.  \n@param uint8_t is_sync : 0, only one UART module, easy to detect, wait until detected;  \n1, two UART modules, hard to detect, detect and return.  \n@return None"},"sortText":"405d8e68uart_baudrate_detect","filterText":"uart_baudrate_detect","insertText":"uart_baudrate_detect(${1:uint8_t uart_no}, ${2:uint8_t is_sync})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_baudrate_detect(${1:uint8_t uart_no}, ${2:uint8_t is_sync})"}},{"label":"uart_div_modify(uint8_t uart_no, uint32_t DivLatchValue)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Modify uart baudrate.  \nThis function will reset RX/TX fifo for uart.  \n@param uint8_t uart_no : 0 for UART0, 1 for UART1.  \n@param uint32_t DivLatchValue : (clock \u003c\u003c 4)/baudrate.  \n@return None"},"sortText":"405d8e68uart_div_modify","filterText":"uart_div_modify","insertText":"uart_div_modify(${1:uint8_t uart_no}, ${2:uint32_t DivLatchValue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_div_modify(${1:uint8_t uart_no}, ${2:uint32_t DivLatchValue})"}},{"label":"uart_rx_intr_handler(void *para)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Process uart received information in the interrupt handler.  \nPlease do not call this function in SDK.  \n@param void \\*para : the message receive buffer.  \n@return None"},"sortText":"405d8e68uart_rx_intr_handler","filterText":"uart_rx_intr_handler","insertText":"uart_rx_intr_handler(${1:void *para})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_rx_intr_handler(${1:void *para})"}},{"label":"uart_rx_one_char_block()","kind":3,"detail":"char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Get an input char from message channel, wait until successful.  \nPlease do not call this function in SDK.  \n@param None  \n@return char : input char value."},"sortText":"405d8e68uart_rx_one_char_block","filterText":"uart_rx_one_char_block","insertText":"uart_rx_one_char_block()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_rx_one_char_block()"}},{"label":"uart_rx_readbuff(RcvMsgBuff *pRxBuff, uint8_t *pRxByte)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Get an char from receive buffer.  \nPlease do not call this function in SDK.  \n@param RcvMsgBuff \\*pRxBuff : the pointer to the struct that include receive buffer.  \n@param uint8_t \\*pRxByte : the pointer to store the char.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68uart_rx_readbuff","filterText":"uart_rx_readbuff","insertText":"uart_rx_readbuff(${1:RcvMsgBuff *pRxBuff}, ${2:uint8_t *pRxByte})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_rx_readbuff(${1:RcvMsgBuff *pRxBuff}, ${2:uint8_t *pRxByte})"}},{"label":"uart_tx_flush(uint8_t uart_no)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Wait until uart tx full empty.  \n@param uint8_t uart_no : 0 for UART0, 1 for UART1.  \n@return None."},"sortText":"405d8e68uart_tx_flush","filterText":"uart_tx_flush","insertText":"uart_tx_flush(${1:uint8_t uart_no})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_tx_flush(${1:uint8_t uart_no})"}},{"label":"uart_tx_one_char2(uint8_t TxChar)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Output a char to message exchange channel, wait until fifo not full.  \nPlease do not call this function in SDK.  \n@param None  \n@return OK."},"sortText":"405d8e68uart_tx_one_char2","filterText":"uart_tx_one_char2","insertText":"uart_tx_one_char2(${1:uint8_t TxChar})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_tx_one_char2(${1:uint8_t TxChar})"}},{"label":"uart_tx_wait_idle(uint8_t uart_no)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Wait until uart tx full empty and the last char send ok.  \n@param uart_no : 0 for UART0, 1 for UART1, 2 for UART2  \nThe function defined in ROM code has a bug, so we define the correct version here for compatibility."},"sortText":"405d8e68uart_tx_wait_idle","filterText":"uart_tx_wait_idle","insertText":"uart_tx_wait_idle(${1:uint8_t uart_no})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_tx_wait_idle(${1:uint8_t uart_no})"}},{"label":" ucQueueGetQueueType(QueueHandle_t xQueue)","kind":3,"detail":"uint8_t","sortText":"405d8e68ucQueueGetQueueType","filterText":"ucQueueGetQueueType","insertText":"ucQueueGetQueueType(${1:QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ucQueueGetQueueType(${1:QueueHandle_t xQueue})"}},{"label":"uid_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68uid_t","filterText":"uid_t","insertText":"uid_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uid_t"}},{"label":"uint","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68uint","filterText":"uint","insertText":"uint","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uint"}},{"label":"ulong","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68ulong","filterText":"ulong","insertText":"ulong","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ulong"}},{"label":"useconds_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68useconds_t","filterText":"useconds_t","insertText":"useconds_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"useconds_t"}},{"label":"user_onReceive","kind":8,"documentation":{"kind":"markdown","value":"From `\"Wire.h\"`"},"sortText":"405d8e68user_onReceive","filterText":"user_onReceive","insertText":"user_onReceive","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"user_onReceive"}},{"label":"user_onRequest","kind":8,"documentation":{"kind":"markdown","value":"From `\"Wire.h\"`"},"sortText":"405d8e68user_onRequest","filterText":"user_onRequest","insertText":"user_onRequest","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"user_onRequest"}},{"label":"ushort","kind":8,"documentation":{"kind":"markdown","value":"From `\u003csys/types.h\u003e`"},"sortText":"405d8e68ushort","filterText":"ushort","insertText":"ushort","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ushort"}},{"label":" uxQueueGetQueueNumber(QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","sortText":"405d8e68uxQueueGetQueueNumber","filterText":"uxQueueGetQueueNumber","insertText":"uxQueueGetQueueNumber(${1:QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxQueueGetQueueNumber(${1:QueueHandle_t xQueue})"}},{"label":" uxQueueMessagesWaiting(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Return the number of messages stored in a queue.  \n@param xQueue A handle to the queue being queried.  \n@return The number of messages available in the queue.  \n\\\\ingroup QueueManagement"},"sortText":"405d8e68uxQueueMessagesWaiting","filterText":"uxQueueMessagesWaiting","insertText":"uxQueueMessagesWaiting(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxQueueMessagesWaiting(${1:const QueueHandle_t xQueue})"}},{"label":" uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","sortText":"405d8e68uxQueueMessagesWaitingFromISR","filterText":"uxQueueMessagesWaitingFromISR","insertText":"uxQueueMessagesWaitingFromISR(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxQueueMessagesWaitingFromISR(${1:const QueueHandle_t xQueue})"}},{"label":" uxQueueSpacesAvailable(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Return the number of free spaces available in a queue. This is equal to the number of items that can be sent to the queue before the queue becomes full if no items are removed.  \n@param xQueue A handle to the queue being queried.  \n@return The number of spaces available in the queue.  \n\\\\ingroup QueueManagement"},"sortText":"405d8e68uxQueueSpacesAvailable","filterText":"uxQueueSpacesAvailable","insertText":"uxQueueSpacesAvailable(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uxQueueSpacesAvailable(${1:const QueueHandle_t xQueue})"}},{"label":"UART0","kind":6,"detail":"uart_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/uart_struct.h\"`"},"sortText":"4068a03fUART0","filterText":"UART0","insertText":"UART0","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"UART0"}},{"label":"uart_dev_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/uart_struct.h\"`"},"sortText":"4068a03fuart_dev_t","filterText":"uart_dev_t","insertText":"uart_dev_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"uart_dev_t"}},{"label":"ungetwc(wint_t wc, __FILE *)","kind":3,"detail":"wint_t","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fungetwc","filterText":"ungetwc","insertText":"ungetwc(${1:wint_t wc}, ${2:__FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"ungetwc(${1:wint_t wc}, ${2:__FILE *})"}},{"label":"umask(mode_t __mask)","kind":3,"detail":"mode_t","documentation":{"kind":"markdown","value":"From `\u003csys/stat.h\u003e`"},"sortText":"4071b066umask","filterText":"umask","insertText":"umask(${1:mode_t __mask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"umask(${1:mode_t __mask})"}},{"label":"unlink(const char *__path)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066unlink","filterText":"unlink","insertText":"unlink(${1:const char *__path})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"unlink(${1:const char *__path})"}},{"label":"unlinkat(int, const char *, int)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066unlinkat","filterText":"unlinkat","insertText":"unlinkat(${1:int}, ${2:const char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"unlinkat(${1:int}, ${2:const char *}, ${3:int})"}},{"label":"usleep(useconds_t __useconds)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066usleep","filterText":"usleep","insertText":"usleep(${1:useconds_t __useconds})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"usleep(${1:useconds_t __useconds})"}},{"label":"utimensat(int, const char *, const struct timespec *, int)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/stat.h\u003e`"},"sortText":"4071b066utimensat","filterText":"utimensat","insertText":"utimensat(${1:int}, ${2:const char *}, ${3:const struct timespec *}, ${4:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"utimensat(${1:int}, ${2:const char *}, ${3:const struct timespec *}, ${4:int})"}},{"label":"utimes(const char *__path, const struct timeval *__tvp)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066utimes","filterText":"utimes","insertText":"utimes(${1:const char *__path}, ${2:const struct timeval *__tvp})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"utimes(${1:const char *__path}, ${2:const struct timeval *__tvp})"}},{"label":"std::uncaught_exception()","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \n[18.6.4]/1: 'Returns true after completing evaluation of a throw-expression until either completing initialization of the exception-declaration in the matching handler or entering @c unexpected() due to the throw; or after entering @c terminate() for any reason other than an explicit call to @c terminate(). [Note: This includes stack unwinding [15.2]. end note]'  \n2: 'When @c uncaught_exception() is true, throwing an %exception can result in a call of @c terminate() (15.5.1).'"},"sortText":"4083b5beuncaught_exception","filterText":"uncaught_exception","insertText":"std::uncaught_exception()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::uncaught_exception()"}},{"label":"std::underflow_error","kind":7,"documentation":{"kind":"markdown","value":"From `\u003cstdexcept\u003e`  \nThrown to indicate arithmetic underflow."},"sortText":"4083b5beunderflow_error","filterText":"underflow_error","insertText":"std::underflow_error","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::underflow_error"}},{"label":"std::underlying_type\u003ctypename _Tp\u003e","kind":22,"documentation":{"kind":"markdown","value":"From `\u003ctype_traits\u003e`  \nThe underlying type of an enum."},"sortText":"4083b5beunderlying_type","filterText":"underlying_type","insertText":"std::underlying_type\u003c${1:typename _Tp}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::underlying_type\u003c${1:typename _Tp}\u003e"}},{"label":"std::unexpected()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nThe runtime will call this function if an %exception is thrown which violates the function's %exception specification."},"sortText":"4083b5beunexpected","filterText":"unexpected","insertText":"std::unexpected()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::unexpected()"}},{"label":"std::unexpected_handler","kind":8,"documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nIf you write a replacement %unexpected handler, it must be of this type."},"sortText":"4083b5beunexpected_handler","filterText":"unexpected_handler","insertText":"std::unexpected_handler","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::unexpected_handler"}},{"label":"std::u16streampos","kind":8,"documentation":{"kind":"markdown","value":"From `\u003cios\u003e`  \nFile position for char16_t streams."},"sortText":"4092d0aau16streampos","filterText":"u16streampos","insertText":"std::u16streampos","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::u16streampos"}},{"label":"std::u32streampos","kind":8,"documentation":{"kind":"markdown","value":"From `\u003cios\u003e`  \nFile position for char32_t streams."},"sortText":"4092d0aau32streampos","filterText":"u32streampos","insertText":"std::u32streampos","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::u32streampos"}},{"label":"std::unary_function\u003ctypename _Arg, typename _Result\u003e","kind":22,"documentation":{"kind":"markdown","value":"From `\u003cfunctional\u003e`  \n20.3.1 base classes  \n@defgroup functors Function Objects  \n@ingroup utilities  \nFunction objects, or @e functors, are objects with an @c operator() defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to @a functors, then, generally we include function pointers in the description as well.  \nOften, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.  \nTwo examples taken from the standard itself follow. To perform a by-element addition of two vectors @c a and @c b containing @c double,  \nand put the result in @c a, use  \n\\\\code transform (a.begin(), a.end(), b.begin(), a.begin(), plus\\\u003cdouble\u003e());  \n\\\\endcode To negate every element in @c a, use  \n\\\\code transform(a.begin(), a.end(), a.begin(), negate\\\u003cdouble\u003e());  \n\\\\endcode The addition and negation functions will be inlined directly.  \nThe standard functors are derived from structs named @c unary_function and @c binary_function. These two classes contain nothing but typedefs,  \nto aid in generic (template) programming. If you write your own functors, you might consider doing the same.  \n@{  \nThis is one of the @link functors functor base classes@endlink."},"sortText":"4092d0aaunary_function","filterText":"unary_function","insertText":"std::unary_function\u003c${1:typename _Arg}, ${2:typename _Result}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::unary_function\u003c${1:typename _Arg}, ${2:typename _Result}\u003e"}},{"label":"std::unary_negate\u003ctypename _Predicate\u003e","kind":7,"documentation":{"kind":"markdown","value":"From `\u003cfunctional\u003e`  \n20.3.5 negators  \n@defgroup negators Negators  \n@ingroup functors  \nThe functions @c not1 and @c not2 each take a predicate functor and return an instance of @c unary_negate or  \n@c binary_negate, respectively. These classes are functors whose  \n@c operator() performs the stored predicate function and then returns the negation of the result.  \nFor example, given a vector of integers and a trivial predicate,  \n\\\\code struct IntGreaterThanThree : public std::unary_function\u003cint, bool\u003e { bool operator() (int x) { return x \u003e 3; } };  \nstd::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));  \n\\\\endcode The call to @c find_if will locate the first index (i) of @c v for which \\\u003ccode\u003e!(v[i] \u003e 3)\\\u003c/code\u003e is true.  \nThe not1/unary_negate combination works on predicates taking a single argument. The not2/binary_negate combination works on predicates which take two arguments.  \n@{  \nOne of the @link negators negation functors@endlink."},"sortText":"4092d0aaunary_negate","filterText":"unary_negate","insertText":"std::unary_negate\u003c${1:typename _Predicate}\u003e","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":20}},"newText":"std::unary_negate\u003c${1:typename _Predicate}\u003e"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":115},"contentChanges":[{"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":20}},"rangeLength":0,"text":"x"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":89,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":21},"context":{"triggerKind":3}}}
>>>
Content-Length: 1136

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":20}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'u'"}]},"jsonrpc":"2.0"}Content-Length: 16351

{"id":89,"result":{"isIncomplete":false,"items":[{"label":" uxTaskGetNumberOfTasks()","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get current number of tasks  \n@return The number of tasks that the real time kernel is currently managing.  \nThis includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count.  \n\\\\ingroup TaskUtils"},"sortText":"3fefa429uxTaskGetNumberOfTasks","filterText":"uxTaskGetNumberOfTasks","insertText":"uxTaskGetNumberOfTasks()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskGetNumberOfTasks()"}},{"label":" uxTaskGetSnapshotAll(TaskSnapshot_t *const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t *const pxTcbSz)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"This function fills array with TaskSnapshot_t structures for every task in the system.  \nUsed by core dump facility to get snapshots of all tasks in the system.  \nOnly available when configENABLE_TASK_SNAPSHOT is set to 1.  \n@param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.  \n@param uxArraySize Size of tasks snapshots array.  \n@param pxTcbSz Pointer to store size of TCB.  \n@return Number of elements stored in array."},"sortText":"3fefa429uxTaskGetSnapshotAll","filterText":"uxTaskGetSnapshotAll","insertText":"uxTaskGetSnapshotAll(${1:TaskSnapshot_t *const pxTaskSnapshotArray}, ${2:const UBaseType_t uxArraySize}, ${3:UBaseType_t *const pxTcbSz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskGetSnapshotAll(${1:TaskSnapshot_t *const pxTaskSnapshotArray}, ${2:const UBaseType_t uxArraySize}, ${3:UBaseType_t *const pxTcbSz})"}},{"label":" uxTaskGetStackHighWaterMark(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Returns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created."},"sortText":"3fefa429uxTaskGetStackHighWaterMark","filterText":"uxTaskGetStackHighWaterMark","insertText":"uxTaskGetStackHighWaterMark(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskGetStackHighWaterMark(${1:TaskHandle_t xTask})"}},{"label":" uxTaskGetSystemState(TaskStatus_t *const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t *const pulTotalRunTime)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get the state of tasks in the system.  \nconfigUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for uxTaskGetSystemState() to be available.  \nuxTaskGetSystemState() populates an TaskStatus_t structure for each task in the system. TaskStatus_t structures contain, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. See the TaskStatus_t structure definition in this file for the full member list.  \n@note This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.  \n@param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.  \nThe array must contain at least one TaskStatus_t structure for each task that is under the control of the RTOS. The number of tasks under the control of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.  \n@param uxArraySize The size of the array pointed to by the pxTaskStatusArray parameter. The size is specified as the number of indexes in the array, or the number of TaskStatus_t structures contained in the array, not by the number of bytes in the array.  \n@param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in FreeRTOSConfig.h then \\*pulTotalRunTime is set by uxTaskGetSystemState() to the total run time (as defined by the run time stats clock, see http://www.freertos.org/rtos-run-time-stats.html) since the target booted.  \npulTotalRunTime can be set to NULL to omit the total run time information.  \n@return The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.  \nExample usage:  \n@code{c} // This example demonstrates how a human readable table of run time stats // information is generated from raw data provided by uxTaskGetSystemState().  \n// The human readable table is written to pcWriteBuffer void vTaskGetRunTimeStats( char \\*pcWriteBuffer ) { TaskStatus_t \\*pxTaskStatusArray;  \nvolatile UBaseType_t uxArraySize, x;  \nuint32_t ulTotalRunTime, ulStatsAsPercentage;  \n// Make sure the write buffer does not contain a string.  \n\\*pcWriteBuffer = 0x00;  \n// Take a snapshot of the number of tasks in case it changes while this // function is executing.  \nuxArraySize = uxTaskGetNumberOfTasks();  \n// Allocate a TaskStatus_t structure for each task. An array could be // allocated statically at compile time.  \npxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );  \nif( pxTaskStatusArray != NULL ) { // Generate raw status information about each task.  \nuxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, \u0026ulTotalRunTime );  \n// For percentage calculations.  \nulTotalRunTime /= 100UL;  \n// Avoid divide by zero errors.  \nif( ulTotalRunTime \u003e 0 ) { // For each populated position in the pxTaskStatusArray array,  \n// format the raw data as human readable ASCII data for( x = 0; x \u003c uxArraySize; x++ ) { // What percentage of the total run time has the task used?  \n// This will always be rounded down to the nearest integer.  \n// ulTotalRunTimeDiv100 has already been divided by 100.  \nulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;  \nif( ulStatsAsPercentage \u003e 0UL ) { sprintf( pcWriteBuffer, \"%s\\\\t\\\\t%lu\\\\t\\\\t%lu%%\\\\r\\\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );  \n} else { // If the percentage is zero here then the task has // consumed less than 1% of the total run time.  \nsprintf( pcWriteBuffer, \"%s\\\\t\\\\t%lu\\\\t\\\\t\u003c1%%\\\\r\\\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );  \n}  \npcWriteBuffer += strlen( ( char * ) pcWriteBuffer );  \n} }  \n// The array is no longer needed, free the memory it consumes.  \nvPortFree( pxTaskStatusArray );  \n} }  \n@endcode"},"sortText":"3fefa429uxTaskGetSystemState","filterText":"uxTaskGetSystemState","insertText":"uxTaskGetSystemState(${1:TaskStatus_t *const pxTaskStatusArray}, ${2:const UBaseType_t uxArraySize}, ${3:uint32_t *const pulTotalRunTime})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskGetSystemState(${1:TaskStatus_t *const pxTaskStatusArray}, ${2:const UBaseType_t uxArraySize}, ${3:uint32_t *const pulTotalRunTime})"}},{"label":" uxTaskGetTaskNumber(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Get the uxTCBNumber assigned to the task referenced by the xTask parameter."},"sortText":"3fefa429uxTaskGetTaskNumber","filterText":"uxTaskGetTaskNumber","insertText":"uxTaskGetTaskNumber(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskGetTaskNumber(${1:TaskHandle_t xTask})"}},{"label":" uxTaskPriorityGet(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Obtain the priority of any task.  \nINCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.  \nSee the configuration section for more information.  \n@param xTask Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.  \n@return The priority of xTask.  \nExample usage:  \n@code{c} void vAFunction( void ) { TaskHandle_t xHandle;  \n// Create a task, storing the handle.  \nxTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, \u0026xHandle );  \n// ...  \n// Use the handle to obtain the priority of the created task.  \n// It was created with tskIDLE_PRIORITY, but may have changed // it itself.  \nif( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY ) { // The task has changed it's priority.  \n}  \n// ...  \n// Is our priority higher than the created task?  \nif( uxTaskPriorityGet( xHandle ) \u003c uxTaskPriorityGet( NULL ) ) { // Our priority (obtained using NULL handle) is higher.  \n} }  \n@endcode  \n\\\\ingroup TaskCtrl"},"sortText":"3fefa429uxTaskPriorityGet","filterText":"uxTaskPriorityGet","insertText":"uxTaskPriorityGet(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskPriorityGet(${1:TaskHandle_t xTask})"}},{"label":" uxTaskPriorityGetFromISR(TaskHandle_t xTask)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"A version of uxTaskPriorityGet() that can be used from an ISR.  \n@param xTask Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.  \n@return The priority of xTask."},"sortText":"3fefa429uxTaskPriorityGetFromISR","filterText":"uxTaskPriorityGetFromISR","insertText":"uxTaskPriorityGetFromISR(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskPriorityGetFromISR(${1:TaskHandle_t xTask})"}},{"label":" uxTaskResetEventItemValue()","kind":3,"detail":"TickType_t","documentation":{"kind":"markdown","value":"THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE. THEY ARE USED BY THE EVENT BITS MODULE."},"sortText":"3fefa429uxTaskResetEventItemValue","filterText":"uxTaskResetEventItemValue","insertText":"uxTaskResetEventItemValue()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxTaskResetEventItemValue()"}},{"label":"uxPortCompareSet(volatile uint32_t *addr, uint32_t compare, uint32_t *set)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"freertos/portmacro.h\"`  \nWrapper for the Xtensa compare-and-set instruction. This subroutine will atomically compare  \n\\*addr to 'compare'. If \\*addr == compare, \\*addr is set to \\*set. \\*set is updated with the previous value of \\*addr (either 'compare' or some other value.)  \nWarning: From the ISA docs: in some (unspecified) cases, the s32c1i instruction may return the  \n\\*bitwise inverse\\* of the old mem if the mem wasn't written. This doesn't seem to happen on the ESP32 (portMUX assertions would fail)."},"sortText":"400c559buxPortCompareSet","filterText":"uxPortCompareSet","insertText":"uxPortCompareSet(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxPortCompareSet(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})"}},{"label":"uxPortCompareSetExtram(volatile uint32_t *addr, uint32_t compare, uint32_t *set)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"freertos/portable.h\"`"},"sortText":"400c559buxPortCompareSetExtram","filterText":"uxPortCompareSetExtram","insertText":"uxPortCompareSetExtram(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxPortCompareSetExtram(${1:volatile uint32_t *addr}, ${2:uint32_t compare}, ${3:uint32_t *set})"}},{"label":" uxListRemove(ListItem_t *const pxItemToRemove)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Remove an item from a list. The list item has a pointer to the list that it is in, so only the list item need be passed into the function.  \n@param uxListRemove The item to be removed. The item will remove itself from the list pointed to by it's pxContainer parameter.  \n@return The number of items that remain in the list after the list item has been removed.  \n\\\\page uxListRemove uxListRemove  \n\\\\ingroup LinkedList"},"sortText":"405d8e68uxListRemove","filterText":"uxListRemove","insertText":"uxListRemove(${1:ListItem_t *const pxItemToRemove})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxListRemove(${1:ListItem_t *const pxItemToRemove})"}},{"label":" uxQueueGetQueueNumber(QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","sortText":"405d8e68uxQueueGetQueueNumber","filterText":"uxQueueGetQueueNumber","insertText":"uxQueueGetQueueNumber(${1:QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxQueueGetQueueNumber(${1:QueueHandle_t xQueue})"}},{"label":" uxQueueMessagesWaiting(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Return the number of messages stored in a queue.  \n@param xQueue A handle to the queue being queried.  \n@return The number of messages available in the queue.  \n\\\\ingroup QueueManagement"},"sortText":"405d8e68uxQueueMessagesWaiting","filterText":"uxQueueMessagesWaiting","insertText":"uxQueueMessagesWaiting(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxQueueMessagesWaiting(${1:const QueueHandle_t xQueue})"}},{"label":" uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","sortText":"405d8e68uxQueueMessagesWaitingFromISR","filterText":"uxQueueMessagesWaitingFromISR","insertText":"uxQueueMessagesWaitingFromISR(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxQueueMessagesWaitingFromISR(${1:const QueueHandle_t xQueue})"}},{"label":" uxQueueSpacesAvailable(const QueueHandle_t xQueue)","kind":3,"detail":"UBaseType_t","documentation":{"kind":"markdown","value":"Return the number of free spaces available in a queue. This is equal to the number of items that can be sent to the queue before the queue becomes full if no items are removed.  \n@param xQueue A handle to the queue being queried.  \n@return The number of spaces available in the queue.  \n\\\\ingroup QueueManagement"},"sortText":"405d8e68uxQueueSpacesAvailable","filterText":"uxQueueSpacesAvailable","insertText":"uxQueueSpacesAvailable(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxQueueSpacesAvailable(${1:const QueueHandle_t xQueue})"}},{"label":" uxSemaphoreGetCount(xSemaphore)","kind":1,"sortText":"40d1050auxSemaphoreGetCount","filterText":"uxSemaphoreGetCount","insertText":"uxSemaphoreGetCount(${1:xSemaphore})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":271,"character":19},"end":{"line":271,"character":21}},"newText":"uxSemaphoreGetCount(${1:xSemaphore})"}}]},"jsonrpc":"2.0"}Content-Length: 1137

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":21}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'ux'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":115}}}Content-Length: 469

{"jsonrpc":"2.0","id":90,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":21},"end":{"line":236,"character":21}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":21}},"message":"Use of undeclared identifier 'ux'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":90,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":116},"contentChanges":[{"range":{"start":{"line":236,"character":21},"end":{"line":236,"character":21}},"rangeLength":0,"text":"T"}]}}
>>>
Content-Length: 1138

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":22}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxT'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":117},"contentChanges":[{"range":{"start":{"line":236,"character":22},"end":{"line":236,"character":22}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 1139

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":23}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTa'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":118},"contentChanges":[{"range":{"start":{"line":236,"character":23},"end":{"line":236,"character":23}},"rangeLength":0,"text":"s"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":119},"contentChanges":[{"range":{"start":{"line":236,"character":24},"end":{"line":236,"character":24}},"rangeLength":0,"text":"k"}]}}
>>>
Content-Length: 1140

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":24}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTas'"}]},"jsonrpc":"2.0"}Content-Length: 1141

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":25}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTask'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 473

{"jsonrpc":"2.0","id":91,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":25},"end":{"line":236,"character":25}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":25}},"message":"Use of undeclared identifier 'uxTask'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":91,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":119}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":120},"contentChanges":[{"range":{"start":{"line":236,"character":25},"end":{"line":236,"character":25}},"rangeLength":0,"text":"G"}]}}
>>>
Content-Length: 1142

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":26}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTaskG'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":121},"contentChanges":[{"range":{"start":{"line":236,"character":26},"end":{"line":236,"character":26}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 1143

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":27}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTaskGe'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":122},"contentChanges":[{"range":{"start":{"line":236,"character":27},"end":{"line":236,"character":27}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 1144

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":28}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTaskGet'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 476

{"jsonrpc":"2.0","id":92,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":28},"end":{"line":236,"character":28}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":28}},"message":"Use of undeclared identifier 'uxTaskGet'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":92,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":122}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":123},"contentChanges":[{"range":{"start":{"line":236,"character":28},"end":{"line":236,"character":28}},"rangeLength":0,"text":"S"}]}}
>>>
Content-Length: 1145

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":29}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'uxTaskGetS'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 477

{"jsonrpc":"2.0","id":93,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":29},"end":{"line":236,"character":29}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":29}},"message":"Use of undeclared identifier 'uxTaskGetS'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":93,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":123}}}Content-Length: 355

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":124},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":29}},"rangeLength":10,"text":"uxTaskGetStackHighWaterMark(TaskHandle_t xTask)"}]}}
>>>
Content-Length: 958

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":59}},"severity":1,"code":"unexpected_typedef","source":"clang","message":"Unexpected type name 'TaskHandle_t': expected expression"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 492

{"jsonrpc":"2.0","id":94,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":65}},"context":{"diagnostics":[{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":59}},"message":"Unexpected type name 'TaskHandle_t': expected expression","severity":1,"code":"unexpected_typedef","source":"clang"}]}}}
>>>
Content-Length: 37

{"id":94,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":124}}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":125},"contentChanges":[{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":65}},"rangeLength":18,"text":"N"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":126},"contentChanges":[{"range":{"start":{"line":236,"character":48},"end":{"line":236,"character":48}},"rangeLength":0,"text":"U"}]}}
>>>
Content-Length: 1137

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":49}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'NU'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":127},"contentChanges":[{"range":{"start":{"line":236,"character":49},"end":{"line":236,"character":49}},"rangeLength":0,"text":"L"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":128},"contentChanges":[{"range":{"start":{"line":236,"character":50},"end":{"line":236,"character":50}},"rangeLength":0,"text":"L"}]}}
>>>
Content-Length: 1138

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":50}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'NUL'"}]},"jsonrpc":"2.0"}Content-Length: 951

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":0},"end":{"line":237,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":95,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":51},"end":{"line":236,"character":51}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 362

{"id":95,"result":[{"title":"Expand macro 'NULL'","kind":"refactor","command":{"title":"Expand macro 'NULL'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":271,"character":51},"end":{"line":271,"character":51}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":128}}}Content-Length: 284

{"jsonrpc":"2.0","id":96,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":53},"end":{"line":236,"character":53}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":96,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":129},"contentChanges":[{"range":{"start":{"line":236,"character":53},"end":{"line":236,"character":53}},"rangeLength":0,"text":";"}]}}
>>>
Content-Length: 749

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":10}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":97,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":54},"end":{"line":236,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":97,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":129}}}Content-Length: 209

{"jsonrpc":"2.0","id":98,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":37}}}
>>>
Content-Length: 312

{"id":98,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":270,"character":36},"end":{"line":270,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":130},"contentChanges":[{"range":{"start":{"line":235,"character":37},"end":{"line":235,"character":37}},"rangeLength":0,"text":";"}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":99,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":235,"character":38},"end":{"line":235,"character":38}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":99,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":130}}}Content-Length: 285

{"jsonrpc":"2.0","id":100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":236,"character":54},"end":{"line":236,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":100,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 313

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":131},"contentChanges":[{"range":{"start":{"line":236,"character":54},"end":{"line":236,"character":54}},"rangeLength":0,"text":"\n    "}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":131}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":132},"contentChanges":[{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":4}},"rangeLength":0,"text":"S"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":101,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":5},"context":{"triggerKind":1}}}
>>>
Content-Length: 41265

{"id":101,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3d20b5Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"serialPrint()"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"size_t"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sensors_event_t"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"3fefa429sprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sketchSize_t"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SLEEP_MODE"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68STICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68STICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"STICK_PARITY_EN"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":5}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":5}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'S'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 465

{"jsonrpc":"2.0","id":102,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":5},"end":{"line":237,"character":5}},"context":{"diagnostics":[{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":5}},"message":"Use of undeclared identifier 'S'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":102,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":133},"contentChanges":[{"range":{"start":{"line":237,"character":5},"end":{"line":237,"character":5}},"rangeLength":0,"text":"e"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":103,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 48379

{"id":103,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3d20b5Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"serialPrint()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sensors_event_t"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sensors_vec_t"}},{"label":" HardwareSerial","kind":7,"sortText":"3fd1c28eHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fe19999HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"serialEventRun()"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sensors_type_t"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"esp_now_send_cb_t"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SemaphoreHandle_t"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"seed48(${1:unsigned short *})"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":134},"contentChanges":[{"range":{"start":{"line":237,"character":6},"end":{"line":237,"character":6}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 242

{"jsonrpc":"2.0","id":104,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":7},"context":{"triggerKind":3}}}
>>>
Content-Length: 45780

{"id":104,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3d20b5Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3f787ae0HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3f899998HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"serialEventRun()"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"Server"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"4078a156set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"set_rtc_memory_crc()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40792ddbSERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL"}},{"label":"spi_flash_erase_range(size_t start_address, size_t size)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase a range of flash sectors  \n@param start_address Address where erase operation has to start.  \nMust be 4kB-aligned  \n@param size Size of erased range, in bytes. Must be divisible by 4kB.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_range","filterText":"spi_flash_erase_range","insertText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})"}},{"label":"spi_flash_erase_sector(size_t sector)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase the Flash sector.  \n@param sector Sector number, the count starts at sector 0, 4KB per sector.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_sector","filterText":"spi_flash_erase_sector","insertText":"spi_flash_erase_sector(${1:size_t sector})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"spi_flash_erase_sector(${1:size_t sector})"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40b2b554system_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERIAL_8O2"}},{"label":"WiFiServer","kind":7,"documentation":{"kind":"markdown","value":"From `\"WiFiServer.h\"`"},"sortText":"40b8812dWiFiServer","filterText":"WiFiServer","insertText":"WiFiServer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"WiFiServer"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40cbc334SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SERVER_IDENTIFIER"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"xthal_set_region_attribute(void *addr, unsigned int size, unsigned int cattr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset cache attribute (access modes) for a range of memory"},"sortText":"40f8a156xthal_set_region_attribute","filterText":"xthal_set_region_attribute","insertText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})"}},{"label":"xthal_set_region_translation(void *vaddr, void *paddr, unsigned int size, unsigned int cache_atr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation","filterText":"xthal_set_region_translation","insertText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})"}},{"label":"xthal_set_region_translation_raw(void *vaddr, void *paddr, unsigned int cattr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation_raw","filterText":"xthal_set_region_translation_raw","insertText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})"}},{"label":"gpio_install_isr_service(int intr_alloc_flags)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers.  \nThis function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.  \n@param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG\\_\\* values. See esp_intr_alloc.h for more info.  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_NO_MEM No memory to install this service  \n\\- ESP_ERR_INVALID_STATE ISR service already installed.  \n\\- ESP_ERR_NOT_FOUND No free interrupt found with the specified flags  \n\\- ESP_ERR_INVALID_ARG GPIO error"},"sortText":"4112d0aagpio_install_isr_service","filterText":"gpio_install_isr_service","insertText":"gpio_install_isr_service(${1:int intr_alloc_flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"gpio_install_isr_service(${1:int intr_alloc_flags})"}},{"label":"gpio_uninstall_isr_service()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Uninstall the driver's GPIO ISR service, freeing related resources."},"sortText":"4112d0aagpio_uninstall_isr_service","filterText":"gpio_uninstall_isr_service","insertText":"gpio_uninstall_isr_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"gpio_uninstall_isr_service()"}},{"label":"rmtSetRxThreshold(rmt_obj_t *rmt, uint32_t value)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-rmt.h\"`  \nSetting threshold for Rx completed"},"sortText":"41156184rmtSetRxThreshold","filterText":"rmtSetRxThreshold","insertText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41156184uartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"dns_clear_servers(bool keep_fallback)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"lwip/dns.h\"`"},"sortText":"41172137dns_clear_servers","filterText":"dns_clear_servers","insertText":"dns_clear_servers(${1:bool keep_fallback})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"dns_clear_servers(${1:bool keep_fallback})"}},{"label":"esp_rom_spiflash_erase_area(uint32_t start_addr, uint32_t area_len)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase some sectors.  \nPlease do not call this function in SDK.  \n@param uint32_t start_addr : Start addr to erase, should be sector aligned.  \n@param uint32_t area_len : Length to erase, should be sector aligned.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_area","filterText":"esp_rom_spiflash_erase_area","insertText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})"}},{"label":"esp_rom_spiflash_erase_block(uint32_t block_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a 64KB block of flash Uses SPI flash command D8H.  \nPlease do not call this function in SDK.  \n@param uint32_t block_num : Which block to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_block","filterText":"esp_rom_spiflash_erase_block","insertText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})"}},{"label":"esp_rom_spiflash_erase_chip()","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase whole flash chip.  \nPlease do not call this function in SDK.  \n@param None  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_chip","filterText":"esp_rom_spiflash_erase_chip","insertText":"esp_rom_spiflash_erase_chip()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"esp_rom_spiflash_erase_chip()"}},{"label":"esp_rom_spiflash_erase_sector(uint32_t sector_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a sector of flash.  \nUses SPI flash command 20H.  \nPlease do not call this function in SDK.  \n@param uint32_t sector_num : Which sector to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_sector","filterText":"esp_rom_spiflash_erase_sector","insertText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})"}},{"label":"xthal_tram_pending_to_service()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nTrampoline support functions:"},"sortText":"41276889xthal_tram_pending_to_service","filterText":"xthal_tram_pending_to_service","insertText":"xthal_tram_pending_to_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"xthal_tram_pending_to_service()"}},{"label":"hall_sensor_read()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Read Hall Sensor  \n@note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,  \nthe input of GPIO36 and GPIO39 will be pulled down for about 80ns.  \nWhen enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.  \nPlease refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.  \n@note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure these channels for use as ADC channels.  \n@note The ADC1 module must be enabled by calling adc1_config_width() before calling hall_sensor_read(). ADC1 should be configured for 12 bit readings, as the hall sensor readings are low values and do not cover the full range of the ADC.  \n@return The hall sensor reading."},"sortText":"413198efhall_sensor_read","filterText":"hall_sensor_read","insertText":"hall_sensor_read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"hall_sensor_read()"}},{"label":"lwip_send_r(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_send_r","filterText":"lwip_send_r","insertText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"lwip_sendmsg_r(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendmsg_r","filterText":"lwip_sendmsg_r","insertText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"lwip_sendto_r(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendto_r","filterText":"lwip_sendto_r","insertText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"lwip_setsockopt_r(int s, int level, int optname, const void *optval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_setsockopt_r","filterText":"lwip_setsockopt_r","insertText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})"}},{"label":"COOKIE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334COOKIE_SERVER","filterText":"COOKIE_SERVER","insertText":"COOKIE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"COOKIE_SERVER"}},{"label":"IMPRESS_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334IMPRESS_SERVER","filterText":"IMPRESS_SERVER","insertText":"IMPRESS_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"IMPRESS_SERVER"}},{"label":"LOG_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LOG_SERVER","filterText":"LOG_SERVER","insertText":"LOG_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"LOG_SERVER"}},{"label":"LPR_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LPR_SERVER","filterText":"LPR_SERVER","insertText":"LPR_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"LPR_SERVER"}},{"label":"NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334NAME_SERVER","filterText":"NAME_SERVER","insertText":"NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NAME_SERVER"}},{"label":"NAME_SERVICE_SEARCH","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NAME_SERVICE_SEARCH","filterText":"NAME_SERVICE_SEARCH","insertText":"NAME_SERVICE_SEARCH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NAME_SERVICE_SEARCH"}},{"label":"NDS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NDS_SERVERS","filterText":"NDS_SERVERS","insertText":"NDS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NDS_SERVERS"}},{"label":"NNTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334NNTP_SERVER","filterText":"NNTP_SERVER","insertText":"NNTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NNTP_SERVER"}},{"label":"SMTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334SMTP_SERVER","filterText":"SMTP_SERVER","insertText":"SMTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SMTP_SERVER"}},{"label":"STREETTALK_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334STREETTALK_SERVER","filterText":"STREETTALK_SERVER","insertText":"STREETTALK_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"STREETTALK_SERVER"}},{"label":"SWAP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334SWAP_SERVER","filterText":"SWAP_SERVER","insertText":"SWAP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"SWAP_SERVER"}},{"label":"TFTP_SERVER_NAME","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334TFTP_SERVER_NAME","filterText":"TFTP_SERVER_NAME","insertText":"TFTP_SERVER_NAME","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"TFTP_SERVER_NAME"}},{"label":"TIME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334TIME_SERVER","filterText":"TIME_SERVER","insertText":"TIME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"TIME_SERVER"}},{"label":" esp_dport_access_sequence_reg_read(uint32_t reg)","kind":3,"detail":"uint32_t","sortText":"41500923esp_dport_access_sequence_reg_read","filterText":"esp_dport_access_sequence_reg_read","insertText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})"}},{"label":"DPORT_SEQUENCE_REG_READ(uint32_t reg)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"soc/dport_access.h\"`  \n@brief Read value from register, NOT SMP-safe version.  \nThis method uses the pre-reading of the APB register before reading the register of the DPORT.  \nThere is not disable/enable interrupt.  \nThe difference from DPORT_REG_READ() is that the user himself must disable interrupts while DPORT reading.  \nThis implementation is useful for reading DORT registers in loop without stall other CPU. Note the usage example.  \nThe recommended way to read registers sequentially without stall other CPU is to use the method esp_dport_read_buffer(buff_out, address, num_words). It allows you to read registers in the buffer.  \n\\\\code{c} // This example shows how to use it.  \n{ // Use curly brackets to limit the visibility of variables in macros DPORT_INTERRUPT_DISABLE/RESTORE.  \nDPORT_INTERRUPT_DISABLE(); // Disable interrupt only on current CPU.  \nfor (i = 0; i \u003c max; ++i) { array[i] = DPORT_SEQUENCE_REG_READ(Address + i * 4); // reading DPORT registers } DPORT_INTERRUPT_RESTORE(); // restore the previous interrupt level }  \n\\\\endcode  \n@param reg Register address  \n@return Value"},"sortText":"4168a03fDPORT_SEQUENCE_REG_READ","filterText":"DPORT_SEQUENCE_REG_READ","insertText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})"}},{"label":"DEFAULT_FINGER_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_FINGER_SERVER","filterText":"DEFAULT_FINGER_SERVER","insertText":"DEFAULT_FINGER_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"DEFAULT_FINGER_SERVER"}},{"label":"DEFAULT_IRC_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_IRC_SERVER","filterText":"DEFAULT_IRC_SERVER","insertText":"DEFAULT_IRC_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"DEFAULT_IRC_SERVER"}},{"label":"DEFAULT_WWW_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_WWW_SERVER","filterText":"DEFAULT_WWW_SERVER","insertText":"DEFAULT_WWW_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"DEFAULT_WWW_SERVER"}},{"label":"DOMAIN_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cDOMAIN_NAME_SERVER","filterText":"DOMAIN_NAME_SERVER","insertText":"DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"DOMAIN_NAME_SERVER"}},{"label":"NETWORK_INFORMATION_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVERS","filterText":"NETWORK_INFORMATION_SERVERS","insertText":"NETWORK_INFORMATION_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETWORK_INFORMATION_SERVERS"}},{"label":"NETWORK_INFORMATION_SERVICE_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_SERVERS","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS"}},{"label":"POP3_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cPOP3_SERVER","filterText":"POP3_SERVER","insertText":"POP3_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"POP3_SERVER"}},{"label":"RESOURCE_LOCATION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cRESOURCE_LOCATION_SERVER","filterText":"RESOURCE_LOCATION_SERVER","insertText":"RESOURCE_LOCATION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"RESOURCE_LOCATION_SERVER"}},{"label":"NETWORK_TIME_PROTOCOL_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bNETWORK_TIME_PROTOCOL_SERVERS","filterText":"NETWORK_TIME_PROTOCOL_SERVERS","insertText":"NETWORK_TIME_PROTOCOL_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETWORK_TIME_PROTOCOL_SERVERS"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","kind":20,"detail":"tcpip_adapter_dhcp_option_id_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \nDomain name server"},"sortText":"41e04ec4TCPIP_ADAPTER_DOMAIN_NAME_SERVER","filterText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER"}},{"label":"X_WINDOW_SYSTEM_FONT_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41efcf5cX_WINDOW_SYSTEM_FONT_SERVER","filterText":"X_WINDOW_SYSTEM_FONT_SERVER","insertText":"X_WINDOW_SYSTEM_FONT_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"X_WINDOW_SYSTEM_FONT_SERVER"}},{"label":"ESP_ROM_SPIFLASH_RESULT_ERR","kind":20,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`"},"sortText":"42276889ESP_ROM_SPIFLASH_RESULT_ERR","filterText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"ESP_ROM_SPIFLASH_RESULT_ERR"}},{"label":"system_efuse_read_mac(uint8_t *mac)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Read hardware MAC address.  \nFunction has been renamed to esp_efuse_mac_get_default.  \nThis name will be removed in a future release.  \n@param mac hardware MAC address, length: 6 bytes.  \n@return ESP_OK on success"},"sortText":"42444e03system_efuse_read_mac","filterText":"system_efuse_read_mac","insertText":"system_efuse_read_mac(${1:uint8_t *mac})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"system_efuse_read_mac(${1:uint8_t *mac})"}},{"label":"NETBIOS_OVER_TCP_IP_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"426fcf5cNETBIOS_OVER_TCP_IP_NAME_SERVER","filterText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"NETBIOS_OVER_TCP_IP_NAME_SERVER"}},{"label":"std::__throw_system_error(int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003clist\u003e`"},"sortText":"430300b6__throw_system_error","filterText":"__throw_system_error","insertText":"std::__throw_system_error(${1:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":7}},"newText":"std::__throw_system_error(${1:int})"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":135},"contentChanges":[{"range":{"start":{"line":237,"character":7},"end":{"line":237,"character":7}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 731

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":7}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Ser'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 242

{"jsonrpc":"2.0","id":105,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":8},"context":{"triggerKind":3}}}
>>>
Content-Length: 11742

{"id":105,"result":{"isIncomplete":false,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3d20b5Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3f6047adHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3f6eccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"serialEventRun()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"407c8cb6SERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40bd0a20SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERIAL_8O2"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40eb4dd7SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"SERVER_IDENTIFIER"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41240b6buartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":8}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}}]},"jsonrpc":"2.0"}Content-Length: 732

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Seri'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":136},"contentChanges":[{"range":{"start":{"line":237,"character":8},"end":{"line":237,"character":8}},"rangeLength":0,"text":"a"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":137},"contentChanges":[{"range":{"start":{"line":237,"character":9},"end":{"line":237,"character":9}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 1112

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":9}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":106,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":10},"end":{"line":237,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":106,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":137}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":138},"contentChanges":[{"range":{"start":{"line":237,"character":10},"end":{"line":237,"character":10}},"rangeLength":0,"text":"."}]}}Content-Length: 266

{"jsonrpc":"2.0","id":107,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 8387

{"id":107,"result":{"isIncomplete":false,"items":[{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3ea67494print","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3ebde057println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"println($0)"}},{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"availableForWrite()"}},{"label":" baudRate()","kind":2,"detail":"uint32_t","sortText":"3ee51eb8baudRate","filterText":"baudRate","insertText":"baudRate()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"baudRate()"}},{"label":" begin(unsigned long baud, uint32_t config = SERIAL_8N1, int8_t rxPin = -1, int8_t txPin = -1, bool invert = false, unsigned long timeout_ms = 20000UL)","kind":2,"detail":"void","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"begin(${1:unsigned long baud})"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"flush($0)"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8read","filterText":"read","insertText":"read($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"read($0)"}},{"label":" setDebugOutput(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setDebugOutput","filterText":"setDebugOutput","insertText":"setDebugOutput(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"setDebugOutput(${1:bool})"}},{"label":" setRxBufferSize(size_t)","kind":2,"detail":"size_t","sortText":"3ee51eb8setRxBufferSize","filterText":"setRxBufferSize","insertText":"setRxBufferSize(${1:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"setRxBufferSize(${1:size_t})"}},{"label":" setRxInvert(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setRxInvert","filterText":"setRxInvert","insertText":"setRxInvert(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"setRxInvert(${1:bool})"}},{"label":" updateBaudRate(unsigned long baud)","kind":2,"detail":"void","sortText":"3ee51eb8updateBaudRate","filterText":"updateBaudRate","insertText":"updateBaudRate(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"updateBaudRate(${1:unsigned long baud})"}},{"label":" write()","kind":2,"detail":"[8 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"write($0)"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f17ae13printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"printf(${1:const char *format, ...})"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"clearWriteError()"}},{"label":" find()","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"find($0)"}},{"label":" findUntil()","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"getWriteError()"}},{"label":" parseFloat()","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"parseFloat()"}},{"label":" parseInt()","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"parseInt()"}},{"label":" readBytes()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"readBytes($0)"}},{"label":" readBytesUntil()","kind":2,"detail":"[2 overloads]","sortText":"3f651eb8readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"readBytesUntil($0)"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":272,"character":11},"end":{"line":272,"character":11}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 725

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_unqualified_id","source":"clang","message":"Expected unqualified-id"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":139},"contentChanges":[{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":11}},"rangeLength":0,"text":"p"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":140},"contentChanges":[{"range":{"start":{"line":237,"character":12},"end":{"line":237,"character":12}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 931

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":12}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'p' in 'HardwareSerial'"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":141},"contentChanges":[{"range":{"start":{"line":237,"character":13},"end":{"line":237,"character":13}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 932

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":13}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 933

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":14}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pri' in 'HardwareSerial'"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":142},"contentChanges":[{"range":{"start":{"line":237,"character":14},"end":{"line":237,"character":14}},"rangeLength":0,"text":"n"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":143},"contentChanges":[{"range":{"start":{"line":237,"character":15},"end":{"line":237,"character":15}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 934

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":15}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'prin' in 'HardwareSerial'"}]},"jsonrpc":"2.0"}Content-Length: 2651

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":16}},"severity":1,"code":"bound_member_function","source":"clang","message":"Reference to non-static member function must be called\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: possible target for call\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: possible target for call"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":144},"contentChanges":[{"range":{"start":{"line":237,"character":16},"end":{"line":237,"character":16}},"rangeLength":0,"text":"()"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":145},"contentChanges":[{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":18}},"rangeLength":1,"text":")"}]}}
>>>
Content-Length: 3419

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":16}},"severity":1,"code":"ovl_no_viable_member_function_in_call","source":"clang","message":"No matching member function for call to 'print'\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: candidate function not viable: requires at least argument 'timeinfo', but no arguments were provided"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 289

{"jsonrpc":"2.0","id":108,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":18},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 93

{"id":108,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":109,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":109,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":145}}}Content-Length: 311

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":146},"contentChanges":[{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":17}},"rangeLength":0,"text":"\"\""}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":147},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":19}},"rangeLength":1,"text":"\""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":110,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":19},"end":{"line":237,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":110,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":147}}}Content-Length: 285

{"jsonrpc":"2.0","id":111,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":111,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":148},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"rangeLength":0,"text":"H"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":149},"contentChanges":[{"range":{"start":{"line":237,"character":19},"end":{"line":237,"character":19}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":150},"contentChanges":[{"range":{"start":{"line":237,"character":20},"end":{"line":237,"character":20}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":151},"contentChanges":[{"range":{"start":{"line":237,"character":21},"end":{"line":237,"character":21}},"rangeLength":0,"text":"p"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":152},"contentChanges":[{"range":{"start":{"line":237,"character":22},"end":{"line":237,"character":22}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":153},"contentChanges":[{"range":{"start":{"line":237,"character":23},"end":{"line":237,"character":23}},"rangeLength":0,"text":"b"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":154},"contentChanges":[{"range":{"start":{"line":237,"character":24},"end":{"line":237,"character":24}},"rangeLength":0,"text":"e"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":155},"contentChanges":[{"range":{"start":{"line":237,"character":25},"end":{"line":237,"character":25}},"rangeLength":0,"text":"f"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":156},"contentChanges":[{"range":{"start":{"line":237,"character":26},"end":{"line":237,"character":26}},"rangeLength":0,"text":"o"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":157},"contentChanges":[{"range":{"start":{"line":237,"character":27},"end":{"line":237,"character":27}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":112,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":28},"end":{"line":237,"character":28}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":112,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":157}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":158},"contentChanges":[{"range":{"start":{"line":237,"character":28},"end":{"line":237,"character":28}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":159},"contentChanges":[{"range":{"start":{"line":237,"character":29},"end":{"line":237,"character":29}},"rangeLength":0,"text":" "}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":160},"contentChanges":[{"range":{"start":{"line":237,"character":30},"end":{"line":237,"character":30}},"rangeLength":0,"text":"m"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":161},"contentChanges":[{"range":{"start":{"line":237,"character":31},"end":{"line":237,"character":31}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":162},"contentChanges":[{"range":{"start":{"line":237,"character":32},"end":{"line":237,"character":32}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":163},"contentChanges":[{"range":{"start":{"line":237,"character":33},"end":{"line":237,"character":33}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":164},"contentChanges":[{"range":{"start":{"line":237,"character":34},"end":{"line":237,"character":34}},"rangeLength":0,"text":"o"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":165},"contentChanges":[{"range":{"start":{"line":237,"character":35},"end":{"line":237,"character":35}},"rangeLength":0,"text":"c"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":166},"contentChanges":[{"range":{"start":{"line":237,"character":36},"end":{"line":237,"character":36}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":167},"contentChanges":[{"range":{"start":{"line":237,"character":37},"end":{"line":237,"character":37}},"rangeLength":0,"text":"("}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":168},"contentChanges":[{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":38}},"rangeLength":0,"text":")"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 289

{"jsonrpc":"2.0","id":113,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":39},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 183

{"id":113,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 265

{"jsonrpc":"2.0","id":114,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":38},"context":{"isRetrigger":true,"triggerKind":3}}}
>>>
Content-Length: 183

{"id":114,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":169},"contentChanges":[{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":38}},"rangeLength":0,"text":"B"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":170},"contentChanges":[{"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":39}},"rangeLength":0,"text":"y"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":171},"contentChanges":[{"range":{"start":{"line":237,"character":40},"end":{"line":237,"character":40}},"rangeLength":0,"text":"t"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":172},"contentChanges":[{"range":{"start":{"line":237,"character":41},"end":{"line":237,"character":41}},"rangeLength":0,"text":"e"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":173},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":42}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":173}}}Content-Length: 285

{"jsonrpc":"2.0","id":115,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":44},"end":{"line":237,"character":44}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":115,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":116,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":43}}}
>>>
Content-Length: 38

{"id":116,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":174},"contentChanges":[{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":43}},"rangeLength":0,"text":"s"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":175},"contentChanges":[{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":44}},"rangeLength":1,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":117,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":43}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":117,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":176},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":43}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":177},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":42}},"rangeLength":0,"text":"s"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":118,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":42}}}
>>>
Content-Length: 38

{"id":118,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":177}}}Content-Length: 285

{"jsonrpc":"2.0","id":119,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":119,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":178},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":178}}}Content-Length: 285

{"jsonrpc":"2.0","id":120,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":47}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":120,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":121,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":44},"end":{"line":237,"character":44}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":121,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":122,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":122,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":179},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"rangeLength":0,"text":"L"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":180},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":46}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":180}}}Content-Length: 285

{"jsonrpc":"2.0","id":123,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":49},"end":{"line":237,"character":49}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":123,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":181},"contentChanges":[{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":49}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":182},"contentChanges":[{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":48}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 927

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected","source":"clang","message":"Expected ')'\n\nEsp_Master.ino.cpp:273:17: note: to match this '('"},{"range":{"start":{"line":237,"character":16},"end":{"line":237,"character":17}},"severity":3,"message":"To match this '('\n\nEsp_Master.ino.cpp:274:1: error: expected ')'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":183},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":47}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 893

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":47}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:319:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":184},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":46}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 893

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":46}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:319:1: error: expected '}'"}]},"jsonrpc":"2.0"}Content-Length: 893

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":45}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:319:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 457

{"jsonrpc":"2.0","id":124,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"context":{"diagnostics":[{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":45}},"message":"Expected expression","severity":1,"code":"expected_expression","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":124,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":184}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":185},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"rangeLength":0,"text":":"}]}}Content-Length: 266

{"jsonrpc":"2.0","id":125,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":46},"context":{"triggerKind":2,"triggerCharacter":":"}}}
>>>
Content-Length: 69

{"id":125,"result":{"isIncomplete":false,"items":[]},"jsonrpc":"2.0"}Content-Length: 893

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":46}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:319:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":186},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":46}},"rangeLength":0,"text":" "}]}}
>>>
Content-Length: 893

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":47}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:319:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":187},"contentChanges":[{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":47}},"rangeLength":0,"text":"\""}]}}
>>>
Content-Length: 927

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected","source":"clang","message":"Expected ')'\n\nEsp_Master.ino.cpp:273:17: note: to match this '('"},{"range":{"start":{"line":237,"character":16},"end":{"line":237,"character":17}},"severity":3,"message":"To match this '('\n\nEsp_Master.ino.cpp:274:1: error: expected ')'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":126,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":48}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":126,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":187}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":188},"contentChanges":[{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":48}},"rangeLength":0,"text":")"}]}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":189},"contentChanges":[{"range":{"start":{"line":237,"character":49},"end":{"line":237,"character":49}},"rangeLength":0,"text":";"}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 313

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":190},"contentChanges":[{"range":{"start":{"line":237,"character":50},"end":{"line":237,"character":50}},"rangeLength":0,"text":"\n    "}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":190}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":191},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":4}},"rangeLength":0,"text":"S"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":127,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":5},"context":{"triggerKind":1}}}
>>>
Content-Length: 41265

{"id":127,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3b3d3dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"serialPrint()"}},{"label":"size_t","kind":8,"documentation":{"kind":"markdown","value":"From `\u003ccstddef\u003e`"},"sortText":"3ed49a1bsize_t","filterText":"size_t","insertText":"size_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"size_t"}},{"label":" success","kind":6,"detail":"String","documentation":{"kind":"markdown","value":"String receivedString;  \nVariable to store if sending data was successful"},"sortText":"3eeffa26success","filterText":"success","insertText":"success","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"success"}},{"label":" short","kind":14,"sortText":"3f000000short","filterText":"short","insertText":"short","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"short"}},{"label":" signed","kind":14,"sortText":"3f000000signed","filterText":"signed","insertText":"signed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"signed"}},{"label":" sizeof(expression-or-type)","kind":15,"detail":"size_t","sortText":"3f000000sizeof","filterText":"sizeof","insertText":"sizeof(${0:expression-or-type})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sizeof(${0:expression-or-type})"}},{"label":" sizeof...(parameter-pack)","kind":15,"detail":"size_t","sortText":"3f000000sizeof...","filterText":"sizeof...","insertText":"sizeof...(${0:parameter-pack})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sizeof...(${0:parameter-pack})"}},{"label":" static","kind":14,"sortText":"3f000000static","filterText":"static","insertText":"static","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"static"}},{"label":" static_assert(expression, message);","kind":15,"sortText":"3f000000static_assert","filterText":"static_assert","insertText":"static_assert(${1:expression}, ${0:message});","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"static_assert(${1:expression}, ${0:message});"}},{"label":" static_cast\u003ctype\u003e(expression)","kind":15,"sortText":"3f000000static_cast","filterText":"static_cast","insertText":"static_cast\u003c${1:type}\u003e(${0:expression})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"static_cast\u003c${1:type}\u003e(${0:expression})"}},{"label":" struct","kind":14,"sortText":"3f000000struct","filterText":"struct","insertText":"struct","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"struct"}},{"label":" switch (condition) {cases}","kind":15,"sortText":"3f000000switch","filterText":"switch","insertText":"switch (${1:condition}) {\n${0:cases}\n}","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"switch (${1:condition}) {\n${0:cases}\n}"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sensors_event_t"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"setup()"}},{"label":"String","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nThe string class"},"sortText":"3f3d84bfString","filterText":"String","insertText":"String","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"String"}},{"label":"Stream","kind":7,"documentation":{"kind":"markdown","value":"From `\"Stream.h\"`  \ncompatability macros for testing  \n#define getInt() parseInt()  \n#define getInt(skipChar) parseInt(skipchar)  \n#define getFloat() parseFloat()  \n#define getFloat(skipChar) parseFloat(skipChar)  \n#define getString( pre_string, post_string, buffer, length) readBytesBetween( pre_string, terminator, buffer, length)"},"sortText":"3f4ffac7Stream","filterText":"Stream","insertText":"Stream","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"Stream"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sensors_vec_t"}},{"label":"StringSumHelper","kind":7,"documentation":{"kind":"markdown","value":"From `\"WString.h\"`  \nAn inherited class for holding the result of a concatenation. These result objects are assumed to be writable by subsequent concatenations."},"sortText":"3f651eb8StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"StringSumHelper"}},{"label":" sqrt(double)","kind":3,"detail":"double","sortText":"3f651eb8sqrt","filterText":"sqrt","insertText":"sqrt(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sqrt(${1:double})"}},{"label":" Stream()","kind":4,"detail":"[2 overloads]","sortText":"3f733333Stream","filterText":"Stream","insertText":"Stream($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"Stream($0)"}},{"label":" String()","kind":4,"detail":"[13 overloads]","sortText":"3f733333String","filterText":"String","insertText":"String($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"String($0)"}},{"label":" StringSumHelper()","kind":4,"detail":"[12 overloads]","sortText":"3f733333StringSumHelper","filterText":"StringSumHelper","insertText":"StringSumHelper($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"StringSumHelper($0)"}},{"label":" std","kind":9,"sortText":"3f9eb851std","filterText":"std","insertText":"std","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std"}},{"label":"sprintf(char *, const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"3fefa429sprintf","filterText":"sprintf","insertText":"sprintf(${1:char *}, ${2:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sprintf(${1:char *}, ${2:const char *, ...})"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"4012b71bSENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"4012b71bSENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sensor_t"}},{"label":"strlen(const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"402c8380strlen","filterText":"strlen","insertText":"strlen(${1:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strlen(${1:const char *})"}},{"label":"SDA","kind":6,"detail":"const uint8_t","documentation":{"kind":"markdown","value":"From `\"pins_arduino.h\"`"},"sortText":"403f858bSDA","filterText":"SDA","insertText":"SDA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SDA"}},{"label":"STA_CONNECTED_BIT","kind":6,"detail":"const int","documentation":{"kind":"markdown","value":"From `\"WiFiGeneric.h\"`"},"sortText":"403f858bSTA_CONNECTED_BIT","filterText":"STA_CONNECTED_BIT","insertText":"STA_CONNECTED_BIT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"STA_CONNECTED_BIT"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SemaphoreHandle_t"}},{"label":"StaticSemaphore_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`"},"sortText":"403f858bStaticSemaphore_t","filterText":"StaticSemaphore_t","insertText":"StaticSemaphore_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"StaticSemaphore_t"}},{"label":"scanf(const char *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bscanf","filterText":"scanf","insertText":"scanf(${1:const char *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"scanf(${1:const char *, ...})"}},{"label":"sketchSize_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Esp.h\"`"},"sortText":"403f858bsketchSize_t","filterText":"sketchSize_t","insertText":"sketchSize_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sketchSize_t"}},{"label":"srand(unsigned int __seed)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsrand","filterText":"srand","insertText":"srand(${1:unsigned int __seed})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"srand(${1:unsigned int __seed})"}},{"label":"strchr(const char *, int)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrchr","filterText":"strchr","insertText":"strchr(${1:const char *}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strchr(${1:const char *}, ${2:int})"}},{"label":"strcoll(const char *, const char *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcoll","filterText":"strcoll","insertText":"strcoll(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strcoll(${1:const char *}, ${2:const char *})"}},{"label":"strcspn(const char *, const char *)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrcspn","filterText":"strcspn","insertText":"strcspn(${1:const char *}, ${2:const char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strcspn(${1:const char *}, ${2:const char *})"}},{"label":"strlcat(char *, const char *, size_t)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrlcat","filterText":"strlcat","insertText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strlcat(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncasecmp(const char *, const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncasecmp","filterText":"strncasecmp","insertText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strncasecmp(${1:const char *}, ${2:const char *}, ${3:size_t})"}},{"label":"strncpy(char *, const char *, size_t)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"string.h\"`"},"sortText":"403f858bstrncpy","filterText":"strncpy","insertText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"strncpy(${1:char *}, ${2:const char *}, ${3:size_t})"}},{"label":"SC_STATUS_GETTING_SSID_PSWD","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nGetting SSID and password of target AP"},"sortText":"40500923SC_STATUS_GETTING_SSID_PSWD","filterText":"SC_STATUS_GETTING_SSID_PSWD","insertText":"SC_STATUS_GETTING_SSID_PSWD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SC_STATUS_GETTING_SSID_PSWD"}},{"label":"SC_STATUS_LINK_OVER","kind":20,"detail":"smartconfig_status_t","documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \nConnected to AP successfully"},"sortText":"40500923SC_STATUS_LINK_OVER","filterText":"SC_STATUS_LINK_OVER","insertText":"SC_STATUS_LINK_OVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SC_STATUS_LINK_OVER"}},{"label":"SYSTEM_EVENT_AP_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 soft-AP stop"},"sortText":"40500923SYSTEM_EVENT_AP_STOP","filterText":"SYSTEM_EVENT_AP_STOP","insertText":"SYSTEM_EVENT_AP_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SYSTEM_EVENT_AP_STOP"}},{"label":"SYSTEM_EVENT_STA_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station stop"},"sortText":"40500923SYSTEM_EVENT_STA_STOP","filterText":"SYSTEM_EVENT_STA_STOP","insertText":"SYSTEM_EVENT_STA_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SYSTEM_EVENT_STA_STOP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40500923SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"sc_callback_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_smartconfig.h\"`  \n@brief The callback of SmartConfig, executed when smart-config status changed.  \n@param status Status of SmartConfig:  \n\\- SC_STATUS_GETTING_SSID_PSWD : pdata is a pointer of smartconfig_type_t, means config type.  \n\\- SC_STATUS_LINK : pdata is a pointer to wifi_config_t.  \n\\- SC_STATUS_LINK_OVER : pdata is a pointer of phone's IP address(4 bytes) if pdata unequal NULL.  \n\\- otherwise : parameter void \\*pdata is NULL.  \n@param pdata According to the different status have different values."},"sortText":"40500923sc_callback_t","filterText":"sc_callback_t","insertText":"sc_callback_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sc_callback_t"}},{"label":"sigmaDeltaAttachPin(uint8_t pin, uint8_t channel)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaAttachPin","filterText":"sigmaDeltaAttachPin","insertText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sigmaDeltaAttachPin(${1:uint8_t pin}, ${2:uint8_t channel})"}},{"label":"sigmaDeltaWrite(uint8_t channel, uint8_t duty)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-sigmadelta.h\"`"},"sortText":"40500923sigmaDeltaWrite","filterText":"sigmaDeltaWrite","insertText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sigmaDeltaWrite(${1:uint8_t channel}, ${2:uint8_t duty})"}},{"label":"spiFrequencyToClockDiv(uint32_t freq)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nHelper functions to translate frequency to clock divider and back"},"sortText":"40500923spiFrequencyToClockDiv","filterText":"spiFrequencyToClockDiv","insertText":"spiFrequencyToClockDiv(${1:uint32_t freq})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiFrequencyToClockDiv(${1:uint32_t freq})"}},{"label":"spiGetClockDiv(spi_t *spi)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiGetClockDiv","filterText":"spiGetClockDiv","insertText":"spiGetClockDiv(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiGetClockDiv(${1:spi_t *spi})"}},{"label":"spiSSClear(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nDeactivate enabled SPI_CSx pins"},"sortText":"40500923spiSSClear","filterText":"spiSSClear","insertText":"spiSSClear(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiSSClear(${1:spi_t *spi})"}},{"label":"spiSSEnable(spi_t *spi)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`  \nEnable/Disable hardware control of SPI_CSx pins"},"sortText":"40500923spiSSEnable","filterText":"spiSSEnable","insertText":"spiSSEnable(${1:spi_t *spi})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiSSEnable(${1:spi_t *spi})"}},{"label":"spiStartBus(uint8_t spi_num, uint32_t clockDiv, uint8_t dataMode, uint8_t bitOrder)","kind":3,"detail":"spi_t *","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiStartBus","filterText":"spiStartBus","insertText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiStartBus(${1:uint8_t spi_num}, ${2:uint32_t clockDiv}, ${3:uint8_t dataMode}, ${4:uint8_t bitOrder})"}},{"label":"spiWriteShortNL(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteShortNL","filterText":"spiWriteShortNL","insertText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiWriteShortNL(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"spiWriteWord(spi_t *spi, uint16_t data)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-spi.h\"`"},"sortText":"40500923spiWriteWord","filterText":"spiWriteWord","insertText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"spiWriteWord(${1:spi_t *spi}, ${2:uint16_t data})"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"40500923system_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"system_event_cb_t"}},{"label":"SLEEP_MODE","kind":8,"documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`"},"sortText":"405d8e68SLEEP_MODE","filterText":"SLEEP_MODE","insertText":"SLEEP_MODE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SLEEP_MODE"}},{"label":"STICK_PARITY_DIS","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68STICK_PARITY_DIS","filterText":"STICK_PARITY_DIS","insertText":"STICK_PARITY_DIS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"STICK_PARITY_DIS"}},{"label":"STICK_PARITY_EN","kind":20,"detail":"UartExistParity","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"405d8e68STICK_PARITY_EN","filterText":"STICK_PARITY_EN","insertText":"STICK_PARITY_EN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"STICK_PARITY_EN"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"sinh(double)","kind":3,"detail":"double","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinh","filterText":"sinh","insertText":"sinh(${1:double})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sinh(${1:double})"}},{"label":"sinhf(float)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\"math.h\"`"},"sortText":"405d8e68sinhf","filterText":"sinhf","insertText":"sinhf(${1:float})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sinhf(${1:float})"}},{"label":"step_a","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_a","filterText":"step_a","insertText":"step_a","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"step_a"}},{"label":"step_b","kind":20,"detail":"base64_decodestep","documentation":{"kind":"markdown","value":"From `\"libb64/cdecode.h\"`"},"sortText":"405d8e68step_b","filterText":"step_b","insertText":"step_b","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"step_b"}},{"label":"std::signbit()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3signbit","filterText":"signbit","insertText":"std::signbit($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::signbit($0)"}},{"label":"std::sinh(float __x)","kind":3,"detail":"float","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sinh","filterText":"sinh","insertText":"std::sinh(${1:float __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::sinh(${1:float __x})"}},{"label":"std::sqrt(long double __x)","kind":3,"detail":"long double","documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"405f99f3sqrt","filterText":"sqrt","insertText":"std::sqrt(${1:long double __x})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::sqrt(${1:long double __x})"}},{"label":"SIGMADELTA","kind":6,"detail":"gpio_sd_dev_t","documentation":{"kind":"markdown","value":"From `\"soc/gpio_sd_struct.h\"`"},"sortText":"40680cb3SIGMADELTA","filterText":"SIGMADELTA","insertText":"SIGMADELTA","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SIGMADELTA"}},{"label":"soc_get_available_memory_region_max_count()","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn the maximum number of available memory regions which could be returned by soc_get_available_memory_regions(). Used to size the array passed to that function."},"sortText":"4068a03fsoc_get_available_memory_region_max_count","filterText":"soc_get_available_memory_region_max_count","insertText":"soc_get_available_memory_region_max_count()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_get_available_memory_region_max_count()"}},{"label":"soc_get_available_memory_regions(soc_memory_region_t *regions)","kind":3,"detail":"size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nReturn available memory regions for this SoC. Each available memory region is a contiguous piece of memory which is not being used by static data, used by ROM code, or reserved by a component using the SOC_RESERVE_MEMORY_REGION() macro.  \nThis result is soc_memory_regions[] minus all regions reserved via the SOC_RESERVE_MEMORY_REGION() macro (which may also split some regions up.)  \nAt startup, all available memory returned by this function is registered as heap space.  \n@note OS-level startup function only, not recommended to call from app code.  \n@param regions Pointer to an array for reading available regions into.  \nSize of the array should be at least the result of soc_get_available_memory_region_max_count(). Entries in the array will be ordered by memory address.  \n@return Number of entries copied to 'regions'. Will be no greater than the result of soc_get_available_memory_region_max_count()."},"sortText":"4068a03fsoc_get_available_memory_regions","filterText":"soc_get_available_memory_regions","insertText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_get_available_memory_regions(${1:soc_memory_region_t *regions})"}},{"label":"soc_memory_region_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_region_count","filterText":"soc_memory_region_count","insertText":"soc_memory_region_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_region_count"}},{"label":"soc_memory_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_region_t","filterText":"soc_memory_region_t","insertText":"soc_memory_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_region_t"}},{"label":"soc_memory_regions","kind":6,"detail":"const soc_memory_region_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_regions","filterText":"soc_memory_regions","insertText":"soc_memory_regions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_regions"}},{"label":"soc_memory_type_count","kind":6,"detail":"const size_t","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`"},"sortText":"4068a03fsoc_memory_type_count","filterText":"soc_memory_type_count","insertText":"soc_memory_type_count","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_type_count"}},{"label":"soc_memory_type_desc_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nType descriptor holds a description for a particular type of memory on a particular SoC."},"sortText":"4068a03fsoc_memory_type_desc_t","filterText":"soc_memory_type_desc_t","insertText":"soc_memory_type_desc_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_type_desc_t"}},{"label":"soc_memory_types","kind":6,"detail":"const soc_memory_type_desc_t []","documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nConstant table of tag descriptors for all this SoC's tags"},"sortText":"4068a03fsoc_memory_types","filterText":"soc_memory_types","insertText":"soc_memory_types","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_memory_types"}},{"label":"soc_reserved_region_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"soc/soc_memory_layout.h\"`  \nRegion descriptor holds a description for a particular region of memory reserved on this SoC for a particular use (ie not available for stack/heap usage.)"},"sortText":"4068a03fsoc_reserved_region_t","filterText":"soc_reserved_region_t","insertText":"soc_reserved_region_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"soc_reserved_region_t"}},{"label":"swscanf(const wchar_t *, const wchar_t *, ...)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"wchar.h\"`"},"sortText":"4068a03fswscanf","filterText":"swscanf","insertText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"swscanf(${1:const wchar_t *}, ${2:const wchar_t *, ...})"}},{"label":"std::scalbln","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalbln","filterText":"scalbln","insertText":"std::scalbln","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::scalbln"}},{"label":"std::scalblnf","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnf","filterText":"scalblnf","insertText":"std::scalblnf","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::scalblnf"}},{"label":"std::scalblnl","kind":18,"documentation":{"kind":"markdown","value":"From `\u003ccmath\u003e`"},"sortText":"406e2eddscalblnl","filterText":"scalblnl","insertText":"std::scalblnl","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"std::scalblnl"}},{"label":" SPI_BITORDER_LSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_LSBFIRST","filterText":"SPI_BITORDER_LSBFIRST","insertText":"SPI_BITORDER_LSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SPI_BITORDER_LSBFIRST"}},{"label":" SPI_BITORDER_MSBFIRST","kind":20,"detail":"_BitOrder","sortText":"4071b066SPI_BITORDER_MSBFIRST","filterText":"SPI_BITORDER_MSBFIRST","insertText":"SPI_BITORDER_MSBFIRST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"SPI_BITORDER_MSBFIRST"}},{"label":"sbrk(ptrdiff_t __incr)","kind":3,"detail":"void *","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sbrk","filterText":"sbrk","insertText":"sbrk(${1:ptrdiff_t __incr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sbrk(${1:ptrdiff_t __incr})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":5}},"newText":"setsid()"}}]},"jsonrpc":"2.0"}Content-Length: 729

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":5}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'S'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":192},"contentChanges":[{"range":{"start":{"line":238,"character":5},"end":{"line":238,"character":5}},"rangeLength":0,"text":"e"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":128,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":6},"context":{"triggerKind":3}}}
>>>
Content-Length: 48379

{"id":128,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3b3d3dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"serialPrint()"}},{"label":" sensors_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor event (36 bytes)  \nstruct sensor_event_s is used to provide a single sensor event in a common format."},"sortText":"3f10dee2sensors_event_t","filterText":"sensors_event_t","insertText":"sensors_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sensors_event_t"}},{"label":" setup()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3f13a2a3setup","filterText":"setup","insertText":"setup()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setup()"}},{"label":" sensors_color_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_color_s is used to return color data in a common format."},"sortText":"3f5b380csensors_color_t","filterText":"sensors_color_t","insertText":"sensors_color_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sensors_color_t"}},{"label":" sensors_vec_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nstruct sensors_vec_s is used to return a vector in a common format."},"sortText":"3f5b380csensors_vec_t","filterText":"sensors_vec_t","insertText":"sensors_vec_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sensors_vec_t"}},{"label":" HardwareSerial","kind":7,"sortText":"3fd1c28eHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3fe19999HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"serialEventRun()"}},{"label":" OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"Callback Function that sents message"},"sortText":"3feffa26OnDataSent","filterText":"OnDataSent","insertText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"OnDataSent(${1:const uint8_t *mac_addr}, ${2:esp_now_send_status_t status})"}},{"label":" initLDRSensor()","kind":3,"detail":"void","sortText":"3feffa26initLDRSensor","filterText":"initLDRSensor","insertText":"initLDRSensor()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"initLDRSensor()"}},{"label":" sensor_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor details (40 bytes)  \nstruct sensor_s is used to describe basic information about a specific sensor."},"sortText":"4012b71bsensor_t","filterText":"sensor_t","insertText":"sensor_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sensor_t"}},{"label":" sensors_type_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nSensor types"},"sortText":"4012b71bsensors_type_t","filterText":"sensors_type_t","insertText":"sensors_type_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sensors_type_t"}},{"label":" esp_now_send_cb_t","kind":8,"sortText":"4017ae13esp_now_send_cb_t","filterText":"esp_now_send_cb_t","insertText":"esp_now_send_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"esp_now_send_cb_t"}},{"label":" SENSOR_TYPE_ACCELEROMETER","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`  \nGravity + linear acceleration"},"sortText":"40306039SENSOR_TYPE_ACCELEROMETER","filterText":"SENSOR_TYPE_ACCELEROMETER","insertText":"SENSOR_TYPE_ACCELEROMETER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_ACCELEROMETER"}},{"label":" SENSOR_TYPE_AMBIENT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_AMBIENT_TEMPERATURE","filterText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertText":"SENSOR_TYPE_AMBIENT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_AMBIENT_TEMPERATURE"}},{"label":" SENSOR_TYPE_COLOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_COLOR","filterText":"SENSOR_TYPE_COLOR","insertText":"SENSOR_TYPE_COLOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_COLOR"}},{"label":" SENSOR_TYPE_CURRENT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_CURRENT","filterText":"SENSOR_TYPE_CURRENT","insertText":"SENSOR_TYPE_CURRENT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_CURRENT"}},{"label":" SENSOR_TYPE_GRAVITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GRAVITY","filterText":"SENSOR_TYPE_GRAVITY","insertText":"SENSOR_TYPE_GRAVITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_GRAVITY"}},{"label":" SENSOR_TYPE_GYROSCOPE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_GYROSCOPE","filterText":"SENSOR_TYPE_GYROSCOPE","insertText":"SENSOR_TYPE_GYROSCOPE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_GYROSCOPE"}},{"label":" SENSOR_TYPE_LIGHT","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LIGHT","filterText":"SENSOR_TYPE_LIGHT","insertText":"SENSOR_TYPE_LIGHT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_LIGHT"}},{"label":" SENSOR_TYPE_LINEAR_ACCELERATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_LINEAR_ACCELERATION","filterText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertText":"SENSOR_TYPE_LINEAR_ACCELERATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_LINEAR_ACCELERATION"}},{"label":" SENSOR_TYPE_MAGNETIC_FIELD","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_MAGNETIC_FIELD","filterText":"SENSOR_TYPE_MAGNETIC_FIELD","insertText":"SENSOR_TYPE_MAGNETIC_FIELD","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_MAGNETIC_FIELD"}},{"label":" SENSOR_TYPE_OBJECT_TEMPERATURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_OBJECT_TEMPERATURE","filterText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertText":"SENSOR_TYPE_OBJECT_TEMPERATURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_OBJECT_TEMPERATURE"}},{"label":" SENSOR_TYPE_ORIENTATION","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ORIENTATION","filterText":"SENSOR_TYPE_ORIENTATION","insertText":"SENSOR_TYPE_ORIENTATION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_ORIENTATION"}},{"label":" SENSOR_TYPE_PRESSURE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PRESSURE","filterText":"SENSOR_TYPE_PRESSURE","insertText":"SENSOR_TYPE_PRESSURE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_PRESSURE"}},{"label":" SENSOR_TYPE_PROXIMITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_PROXIMITY","filterText":"SENSOR_TYPE_PROXIMITY","insertText":"SENSOR_TYPE_PROXIMITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_PROXIMITY"}},{"label":" SENSOR_TYPE_RELATIVE_HUMIDITY","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_RELATIVE_HUMIDITY","filterText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertText":"SENSOR_TYPE_RELATIVE_HUMIDITY","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_RELATIVE_HUMIDITY"}},{"label":" SENSOR_TYPE_ROTATION_VECTOR","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_ROTATION_VECTOR","filterText":"SENSOR_TYPE_ROTATION_VECTOR","insertText":"SENSOR_TYPE_ROTATION_VECTOR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_ROTATION_VECTOR"}},{"label":" SENSOR_TYPE_VOLTAGE","kind":20,"detail":"sensors_type_t","documentation":{"kind":"markdown","value":"From `\"Adafruit_Sensor.h\"`"},"sortText":"40306039SENSOR_TYPE_VOLTAGE","filterText":"SENSOR_TYPE_VOLTAGE","insertText":"SENSOR_TYPE_VOLTAGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SENSOR_TYPE_VOLTAGE"}},{"label":" SemaphoreHandle_t","kind":8,"sortText":"403f858bSemaphoreHandle_t","filterText":"SemaphoreHandle_t","insertText":"SemaphoreHandle_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SemaphoreHandle_t"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"Server"}},{"label":"seed48(unsigned short *)","kind":3,"detail":"unsigned short *","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bseed48","filterText":"seed48","insertText":"seed48(${1:unsigned short *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"seed48(${1:unsigned short *})"}},{"label":"setbuf(FILE *, char *)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuf","filterText":"setbuf","insertText":"setbuf(${1:FILE *}, ${2:char *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setbuf(${1:FILE *}, ${2:char *})"}},{"label":"setbuffer(FILE *, char *, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetbuffer","filterText":"setbuffer","insertText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setbuffer(${1:FILE *}, ${2:char *}, ${3:int})"}},{"label":"setenv(const char *__string, const char *__value, int __overwrite)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdlib.h\"`"},"sortText":"403f858bsetenv","filterText":"setenv","insertText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setenv(${1:const char *__string}, ${2:const char *__value}, ${3:int __overwrite})"}},{"label":"setlinebuf(FILE *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetlinebuf","filterText":"setlinebuf","insertText":"setlinebuf(${1:FILE *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setlinebuf(${1:FILE *})"}},{"label":"setvbuf(FILE *, char *, int, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"stdio.h\"`"},"sortText":"403f858bsetvbuf","filterText":"setvbuf","insertText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setvbuf(${1:FILE *}, ${2:char *}, ${3:int}, ${4:size_t})"}},{"label":"setCpuFrequencyMhz(uint32_t cpu_freq_mhz)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-cpu.h\"`  \nfunction takes the following frequencies as valid values:  \n240, 160, 80 \u003c\u003c\u003c For all XTAL types 40, 20, 10 \u003c\u003c\u003c For 40MHz XTAL 26, 13 \u003c\u003c\u003c For 26MHz XTAL 24, 12 \u003c\u003c\u003c For 24MHz XTAL"},"sortText":"40500923setCpuFrequencyMhz","filterText":"setCpuFrequencyMhz","insertText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setCpuFrequencyMhz(${1:uint32_t cpu_freq_mhz})"}},{"label":" esp_now_send_status_t","kind":8,"sortText":"4052aa78esp_now_send_status_t","filterText":"esp_now_send_status_t","insertText":"esp_now_send_status_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"esp_now_send_status_t"}},{"label":"SendMsg(uint8_t *pData, uint16_t DataLen)","kind":3,"detail":"STATUS","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*pData : the pointer to input string.  \n@param uint16_t DataLen : the string length.  \n@return OK for successful.  \nFAIL for failed."},"sortText":"405d8e68SendMsg","filterText":"SendMsg","insertText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SendMsg(${1:uint8_t *pData}, ${2:uint16_t DataLen})"}},{"label":"send_packet(uint8_t *p, int len)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`  \n@brief Send an packet to download tool, with SLIP escaping.  \nPlease do not call this function in SDK.  \n@param uint8_t \\*p : the pointer to output string.  \n@param int len : the string length.  \n@return None."},"sortText":"405d8e68send_packet","filterText":"send_packet","insertText":"send_packet(${1:uint8_t *p}, ${2:int len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"send_packet(${1:uint8_t *p}, ${2:int len})"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"405d8e68set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"set_rtc_memory_crc()"}},{"label":" esp_now_send(const uint8_t *peer_addr, const uint8_t *data, size_t len)","kind":3,"detail":"esp_err_t","sortText":"40651eb8esp_now_send","filterText":"esp_now_send","insertText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"esp_now_send(${1:const uint8_t *peer_addr}, ${2:const uint8_t *data}, ${3:size_t len})"}},{"label":"setlocale(int category, const char *locale)","kind":3,"detail":"char *","documentation":{"kind":"markdown","value":"From `\"locale.h\"`"},"sortText":"4068a03fsetlocale","filterText":"setlocale","insertText":"setlocale(${1:int category}, ${2:const char *locale})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setlocale(${1:int category}, ${2:const char *locale})"}},{"label":"select(int nfds, _types_fd_set *readfds, _types_fd_set *writefds, _types_fd_set *errorfds, struct timeval *timeout)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066select","filterText":"select","insertText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"select(${1:int nfds}, ${2:_types_fd_set *readfds}, ${3:_types_fd_set *writefds}, ${4:_types_fd_set *errorfds}, ${5:struct timeval *timeout})"}},{"label":"setgid(gid_t __gid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setgid","filterText":"setgid","insertText":"setgid(${1:gid_t __gid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setgid(${1:gid_t __gid})"}},{"label":"sethostname(const char *, size_t)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066sethostname","filterText":"sethostname","insertText":"sethostname(${1:const char *}, ${2:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sethostname(${1:const char *}, ${2:size_t})"}},{"label":"setitimer(int __which, const struct itimerval *__value, struct itimerval *__ovalue)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066setitimer","filterText":"setitimer","insertText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setitimer(${1:int __which}, ${2:const struct itimerval *__value}, ${3:struct itimerval *__ovalue})"}},{"label":"setpgid(pid_t __pid, pid_t __pgid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgid","filterText":"setpgid","insertText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setpgid(${1:pid_t __pid}, ${2:pid_t __pgid})"}},{"label":"setpgrp()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setpgrp","filterText":"setpgrp","insertText":"setpgrp()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setpgrp()"}},{"label":"setsid()","kind":3,"detail":"pid_t","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setsid","filterText":"setsid","insertText":"setsid()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setsid()"}},{"label":"settimeofday(const struct timeval *, const struct timezone *)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\u003csys/select.h\u003e`"},"sortText":"4071b066settimeofday","filterText":"settimeofday","insertText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"settimeofday(${1:const struct timeval *}, ${2:const struct timezone *})"}},{"label":"setuid(uid_t __uid)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"sys/unistd.h\"`"},"sortText":"4071b066setuid","filterText":"setuid","insertText":"setuid(${1:uid_t __uid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setuid(${1:uid_t __uid})"}},{"label":"SEVEN_BITS","kind":20,"detail":"UartBitsNum4Char","documentation":{"kind":"markdown","value":"From `\"rom/uart.h\"`"},"sortText":"4071dc9bSEVEN_BITS","filterText":"SEVEN_BITS","insertText":"SEVEN_BITS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SEVEN_BITS"}},{"label":"system_event_ap_probe_req_rx_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_probe_req_rx_t","filterText":"system_event_ap_probe_req_rx_t","insertText":"system_event_ap_probe_req_rx_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_ap_probe_req_rx_t"}},{"label":"system_event_ap_staconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staconnected_t","filterText":"system_event_ap_staconnected_t","insertText":"system_event_ap_staconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_ap_staconnected_t"}},{"label":"system_event_ap_stadisconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_stadisconnected_t","filterText":"system_event_ap_stadisconnected_t","insertText":"system_event_ap_stadisconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_ap_stadisconnected_t"}},{"label":"system_event_ap_staipassigned_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_ap_staipassigned_t","filterText":"system_event_ap_staipassigned_t","insertText":"system_event_ap_staipassigned_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_ap_staipassigned_t"}},{"label":"system_event_cb_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_loop.h\"`  \n@brief Application specified event callback function  \n@param void \\*ctx : reserved for user  \n@param system_event_t \\*event : event type defined in this file  \n@return ESP_OK : succeed  \n@return others : fail"},"sortText":"407c06dasystem_event_cb_t","filterText":"system_event_cb_t","insertText":"system_event_cb_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_cb_t"}},{"label":"system_event_got_ip6_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_got_ip6_t","filterText":"system_event_got_ip6_t","insertText":"system_event_got_ip6_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_got_ip6_t"}},{"label":"system_event_handler_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_handler_t","filterText":"system_event_handler_t","insertText":"system_event_handler_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_handler_t"}},{"label":"system_event_id_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_id_t","filterText":"system_event_id_t","insertText":"system_event_id_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_id_t"}},{"label":"system_event_info_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_info_t","filterText":"system_event_info_t","insertText":"system_event_info_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_info_t"}},{"label":"system_event_sta_authmode_change_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_authmode_change_t","filterText":"system_event_sta_authmode_change_t","insertText":"system_event_sta_authmode_change_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_authmode_change_t"}},{"label":"system_event_sta_connected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_connected_t","filterText":"system_event_sta_connected_t","insertText":"system_event_sta_connected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_connected_t"}},{"label":"system_event_sta_disconnected_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_disconnected_t","filterText":"system_event_sta_disconnected_t","insertText":"system_event_sta_disconnected_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_disconnected_t"}},{"label":"system_event_sta_got_ip_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_got_ip_t","filterText":"system_event_sta_got_ip_t","insertText":"system_event_sta_got_ip_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_got_ip_t"}},{"label":"system_event_sta_scan_done_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_scan_done_t","filterText":"system_event_sta_scan_done_t","insertText":"system_event_sta_scan_done_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_scan_done_t"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"system_event_sta_wps_fail_reason_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_sta_wps_fail_reason_t","filterText":"system_event_sta_wps_fail_reason_t","insertText":"system_event_sta_wps_fail_reason_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_sta_wps_fail_reason_t"}},{"label":"system_event_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"407c06dasystem_event_t","filterText":"system_event_t","insertText":"system_event_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"system_event_t"}},{"label":"std::set_new_handler(new_handler)","kind":3,"detail":"new_handler","documentation":{"kind":"markdown","value":"From `\u003cnew\u003e`  \nTakes a replacement handler as the argument, returns the previous handler."},"sortText":"4083b5beset_new_handler","filterText":"set_new_handler","insertText":"std::set_new_handler(${1:new_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_new_handler(${1:new_handler})"}},{"label":"std::set_terminate(terminate_handler)","kind":3,"detail":"terminate_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_terminate","filterText":"set_terminate","insertText":"std::set_terminate(${1:terminate_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_terminate(${1:terminate_handler})"}},{"label":"std::set_unexpected(unexpected_handler)","kind":3,"detail":"unexpected_handler","documentation":{"kind":"markdown","value":"From `\u003cexception\u003e`  \nTakes a new handler function as an argument, returns the old function."},"sortText":"4083b5beset_unexpected","filterText":"set_unexpected","insertText":"std::set_unexpected(${1:unexpected_handler})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_unexpected(${1:unexpected_handler})"}},{"label":"std::search()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a matching sub-sequence.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first1 A forward iterator.  \n@param \\_\\_last1 A forward iterator.  \n@param \\_\\_first2 A forward iterator.  \n@param \\_\\_last2 A forward iterator.  \n@return The first iterator @c i in the range @p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2)) such that @c \\*(i+N) == @p  \n\\*(\\_\\_first2+N) for each @c N in the range @p [0,\\_\\_last2-\\_\\_first2), or @p \\_\\_last1 if no such iterator exists.  \nSearches the range @p [\\_\\_first1,\\_\\_last1) for a sub-sequence that compares equal value-by-value with the sequence given by @p [\\_\\_first2,\\_\\_last2) and returns an iterator to the first element of the sub-sequence, or @p \\_\\_last1 if the sub-sequence is not found.  \nBecause the sub-sequence must lie completely within the range @p [\\_\\_first1,\\_\\_last1) it must start at a position less than @p \\_\\_last1-(\\_\\_last2-\\_\\_first2) where @p \\_\\_last2-\\_\\_first2 is the length of the sub-sequence.  \nThis means that the returned iterator @c i will be in the range  \n@p [\\_\\_first1,\\_\\_last1-(\\_\\_last2-\\_\\_first2))"},"sortText":"4092d0aasearch","filterText":"search","insertText":"std::search($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::search($0)"}},{"label":"std::search_n()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Search a sequence for a number of consecutive values.  \n@ingroup non_mutating_algorithms  \n@param \\_\\_first A forward iterator.  \n@param \\_\\_last A forward iterator.  \n@param \\_\\_count The number of consecutive values.  \n@param \\_\\_val The value to find.  \n@return The first iterator @c i in the range @p [\\_\\_first,\\_\\_last-\\_\\_count) such that @c \\*(i+N) == @p \\_\\_val for each @c N in the range @p [0,\\_\\_count), or @p \\_\\_last if no such iterator exists.  \nSearches the range @p [\\_\\_first,\\_\\_last) for @p count consecutive elements equal to @p \\_\\_val."},"sortText":"4092d0aasearch_n","filterText":"search_n","insertText":"std::search_n($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::search_n($0)"}},{"label":"std::seed_seq","kind":7,"documentation":{"kind":"markdown","value":"From `\u003crandom\u003e`  \n@brief The seed_seq class generates sequences of seeds for random number generators."},"sortText":"4092d0aaseed_seq","filterText":"seed_seq","insertText":"std::seed_seq","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::seed_seq"}},{"label":"std::set_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the difference of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range.  \nIterators increment for each range. When the current element of the first range is less than the second according to @p \\_\\_comp, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances.  \nIf an element is contained in both ranges according to @p \\_\\_comp, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_difference","filterText":"set_difference","insertText":"std::set_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_difference($0)"}},{"label":"std::set_intersection()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the intersection of two sorted ranges using comparison functor.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@param \\_\\_comp The comparison functor.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to @p \\_\\_comp, that iterator advances. If an element is contained in both ranges according to @p \\_\\_comp, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_intersection","filterText":"set_intersection","insertText":"std::set_intersection($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_intersection($0)"}},{"label":"std::set_symmetric_difference()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the symmetric difference of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_symmetric_difference","filterText":"set_symmetric_difference","insertText":"std::set_symmetric_difference($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_symmetric_difference($0)"}},{"label":"std::set_union()","kind":3,"detail":"[2 overloads]","documentation":{"kind":"markdown","value":"From `\u003calgorithm\u003e`  \n@brief Return the union of two sorted ranges.  \n@ingroup set_algorithms  \n@param \\_\\_first1 Start of first range.  \n@param \\_\\_last1 End of first range.  \n@param \\_\\_first2 Start of second range.  \n@param \\_\\_last2 End of second range.  \n@return End of the output range.  \n@ingroup set_algorithms  \nThis operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other,  \nthat element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range."},"sortText":"4092d0aaset_union","filterText":"set_union","insertText":"std::set_union($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::set_union($0)"}},{"label":"setsockopt(int s, int level, int optname, const void *opval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40963e3csetsockopt","filterText":"setsockopt","insertText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"setsockopt(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *opval}, ${5:socklen_t optlen})"}},{"label":"send(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137send","filterText":"send","insertText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"send(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"sendmsg(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendmsg","filterText":"sendmsg","insertText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sendmsg(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"sendto(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"40972137sendto","filterText":"sendto","insertText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"sendto(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"std::setlocale","kind":18,"documentation":{"kind":"markdown","value":"From `\u003cclocale\u003e`"},"sortText":"409aa539setlocale","filterText":"setlocale","insertText":"std::setlocale","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"std::setlocale"}},{"label":"SYSTEM_EVENT_AP_STACONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station connected to ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STACONNECTED","filterText":"SYSTEM_EVENT_AP_STACONNECTED","insertText":"SYSTEM_EVENT_AP_STACONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_AP_STACONNECTED"}},{"label":"SYSTEM_EVENT_AP_STADISCONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \na station disconnected from ESP32 soft-AP"},"sortText":"40a40b6bSYSTEM_EVENT_AP_STADISCONNECTED","filterText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertText":"SYSTEM_EVENT_AP_STADISCONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_AP_STADISCONNECTED"}},{"label":"SYSTEM_EVENT_ETH_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet phy link up"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_CONNECTED","filterText":"SYSTEM_EVENT_ETH_CONNECTED","insertText":"SYSTEM_EVENT_ETH_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_ETH_CONNECTED"}},{"label":"SYSTEM_EVENT_ETH_GOT_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet got IP from connected AP"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_GOT_IP","filterText":"SYSTEM_EVENT_ETH_GOT_IP","insertText":"SYSTEM_EVENT_ETH_GOT_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_ETH_GOT_IP"}},{"label":"SYSTEM_EVENT_ETH_STOP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 ethernet stop"},"sortText":"40a40b6bSYSTEM_EVENT_ETH_STOP","filterText":"SYSTEM_EVENT_ETH_STOP","insertText":"SYSTEM_EVENT_ETH_STOP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_ETH_STOP"}},{"label":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nthe auth mode of AP connected by ESP32 station changed"},"sortText":"40a40b6bSYSTEM_EVENT_STA_AUTHMODE_CHANGE","filterText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_STA_AUTHMODE_CHANGE"}},{"label":"SYSTEM_EVENT_STA_CONNECTED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station connected to AP"},"sortText":"40a40b6bSYSTEM_EVENT_STA_CONNECTED","filterText":"SYSTEM_EVENT_STA_CONNECTED","insertText":"SYSTEM_EVENT_STA_CONNECTED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_STA_CONNECTED"}},{"label":"SYSTEM_EVENT_STA_LOST_IP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station lost IP and the IP is reset to 0"},"sortText":"40a40b6bSYSTEM_EVENT_STA_LOST_IP","filterText":"SYSTEM_EVENT_STA_LOST_IP","insertText":"SYSTEM_EVENT_STA_LOST_IP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_STA_LOST_IP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40a40b6bSYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":6}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}}]},"jsonrpc":"2.0"}Content-Length: 730

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":6}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Se'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":193},"contentChanges":[{"range":{"start":{"line":238,"character":6},"end":{"line":238,"character":6}},"rangeLength":0,"text":"r"}]}}Content-Length: 242

{"jsonrpc":"2.0","id":129,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":7},"context":{"triggerKind":3}}}
>>>
Content-Length: 45780

{"id":129,"result":{"isIncomplete":true,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3e3b3d3dSerial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3f787ae0HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3f899998HardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"serialEventRun()"}},{"label":"Server","kind":7,"documentation":{"kind":"markdown","value":"From `\"Server.h\"`"},"sortText":"403f858bServer","filterText":"Server","insertText":"Server","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"Server"}},{"label":"set_rtc_memory_crc()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"rom/rtc.h\"`  \n@brief Set CRC of Fast RTC memory 0-0x7ff into RTC STORE7.  \n@param None  \n@return None"},"sortText":"4078a156set_rtc_memory_crc","filterText":"set_rtc_memory_crc","insertText":"set_rtc_memory_crc()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"set_rtc_memory_crc()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"40792ddbSERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL"}},{"label":"spi_flash_erase_range(size_t start_address, size_t size)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase a range of flash sectors  \n@param start_address Address where erase operation has to start.  \nMust be 4kB-aligned  \n@param size Size of erased range, in bytes. Must be divisible by 4kB.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_range","filterText":"spi_flash_erase_range","insertText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"spi_flash_erase_range(${1:size_t start_address}, ${2:size_t size})"}},{"label":"spi_flash_erase_sector(size_t sector)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_spi_flash.h\"`  \n@brief Erase the Flash sector.  \n@param sector Sector number, the count starts at sector 0, 4KB per sector.  \n@return esp_err_t"},"sortText":"40aa889bspi_flash_erase_sector","filterText":"spi_flash_erase_sector","insertText":"spi_flash_erase_sector(${1:size_t sector})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"spi_flash_erase_sector(${1:size_t sector})"}},{"label":"system_event_sta_wps_er_pin_t","kind":8,"documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`"},"sortText":"40b2b554system_event_sta_wps_er_pin_t","filterText":"system_event_sta_wps_er_pin_t","insertText":"system_event_sta_wps_er_pin_t","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"system_event_sta_wps_er_pin_t"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40b80a61SERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERIAL_8O2"}},{"label":"WiFiServer","kind":7,"documentation":{"kind":"markdown","value":"From `\"WiFiServer.h\"`"},"sortText":"40b8812dWiFiServer","filterText":"WiFiServer","insertText":"WiFiServer","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"WiFiServer"}},{"label":"SERVER_IDENTIFIER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"40cbc334SERVER_IDENTIFIER","filterText":"SERVER_IDENTIFIER","insertText":"SERVER_IDENTIFIER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SERVER_IDENTIFIER"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_FAILED","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps fails in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_FAILED","filterText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertText":"SYSTEM_EVENT_STA_WPS_ER_FAILED","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_FAILED"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps overlap in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","filterText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PBC_OVERLAP"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_PIN","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps pin code in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_PIN","filterText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertText":"SYSTEM_EVENT_STA_WPS_ER_PIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_PIN"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps succeeds in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_SUCCESS","filterText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_SUCCESS"}},{"label":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","kind":20,"detail":"system_event_id_t","documentation":{"kind":"markdown","value":"From `\"esp_event_legacy.h\"`  \nESP32 station wps timeout in enrollee mode"},"sortText":"40ed5cf2SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","filterText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SYSTEM_EVENT_STA_WPS_ER_TIMEOUT"}},{"label":"xthal_set_region_attribute(void *addr, unsigned int size, unsigned int cattr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset cache attribute (access modes) for a range of memory"},"sortText":"40f8a156xthal_set_region_attribute","filterText":"xthal_set_region_attribute","insertText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"xthal_set_region_attribute(${1:void *addr}, ${2:unsigned int size}, ${3:unsigned int cattr}, ${4:unsigned int flags})"}},{"label":"xthal_set_region_translation(void *vaddr, void *paddr, unsigned int size, unsigned int cache_atr, unsigned int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation","filterText":"xthal_set_region_translation","insertText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"xthal_set_region_translation(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int size}, ${4:unsigned int cache_atr}, ${5:unsigned int flags})"}},{"label":"xthal_set_region_translation_raw(void *vaddr, void *paddr, unsigned int cattr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"40f8a156xthal_set_region_translation_raw","filterText":"xthal_set_region_translation_raw","insertText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"xthal_set_region_translation_raw(${1:void *vaddr}, ${2:void *paddr}, ${3:unsigned int cattr})"}},{"label":"gpio_install_isr_service(int intr_alloc_flags)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers.  \nThis function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function.  \n@param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG\\_\\* values. See esp_intr_alloc.h for more info.  \n@return  \n\\- ESP_OK Success  \n\\- ESP_ERR_NO_MEM No memory to install this service  \n\\- ESP_ERR_INVALID_STATE ISR service already installed.  \n\\- ESP_ERR_NOT_FOUND No free interrupt found with the specified flags  \n\\- ESP_ERR_INVALID_ARG GPIO error"},"sortText":"4112d0aagpio_install_isr_service","filterText":"gpio_install_isr_service","insertText":"gpio_install_isr_service(${1:int intr_alloc_flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"gpio_install_isr_service(${1:int intr_alloc_flags})"}},{"label":"gpio_uninstall_isr_service()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"driver/gpio.h\"`  \n@brief Uninstall the driver's GPIO ISR service, freeing related resources."},"sortText":"4112d0aagpio_uninstall_isr_service","filterText":"gpio_uninstall_isr_service","insertText":"gpio_uninstall_isr_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"gpio_uninstall_isr_service()"}},{"label":"rmtSetRxThreshold(rmt_obj_t *rmt, uint32_t value)","kind":3,"detail":"bool","documentation":{"kind":"markdown","value":"From `\"esp32-hal-rmt.h\"`  \nSetting threshold for Rx completed"},"sortText":"41156184rmtSetRxThreshold","filterText":"rmtSetRxThreshold","insertText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"rmtSetRxThreshold(${1:rmt_obj_t *rmt}, ${2:uint32_t value})"}},{"label":"uartSetRxInvert(uart_t *uart, bool invert)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"41156184uartSetRxInvert","filterText":"uartSetRxInvert","insertText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"uartSetRxInvert(${1:uart_t *uart}, ${2:bool invert})"}},{"label":"dns_clear_servers(bool keep_fallback)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"lwip/dns.h\"`"},"sortText":"41172137dns_clear_servers","filterText":"dns_clear_servers","insertText":"dns_clear_servers(${1:bool keep_fallback})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"dns_clear_servers(${1:bool keep_fallback})"}},{"label":"esp_rom_spiflash_erase_area(uint32_t start_addr, uint32_t area_len)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase some sectors.  \nPlease do not call this function in SDK.  \n@param uint32_t start_addr : Start addr to erase, should be sector aligned.  \n@param uint32_t area_len : Length to erase, should be sector aligned.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_area","filterText":"esp_rom_spiflash_erase_area","insertText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"esp_rom_spiflash_erase_area(${1:uint32_t start_addr}, ${2:uint32_t area_len})"}},{"label":"esp_rom_spiflash_erase_block(uint32_t block_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a 64KB block of flash Uses SPI flash command D8H.  \nPlease do not call this function in SDK.  \n@param uint32_t block_num : Which block to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_block","filterText":"esp_rom_spiflash_erase_block","insertText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"esp_rom_spiflash_erase_block(${1:uint32_t block_num})"}},{"label":"esp_rom_spiflash_erase_chip()","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase whole flash chip.  \nPlease do not call this function in SDK.  \n@param None  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_chip","filterText":"esp_rom_spiflash_erase_chip","insertText":"esp_rom_spiflash_erase_chip()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"esp_rom_spiflash_erase_chip()"}},{"label":"esp_rom_spiflash_erase_sector(uint32_t sector_num)","kind":3,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`  \n@brief Erase a sector of flash.  \nUses SPI flash command 20H.  \nPlease do not call this function in SDK.  \n@param uint32_t sector_num : Which sector to erase.  \n@return ESP_ROM_SPIFLASH_RESULT_OK : Erase OK.  \nESP_ROM_SPIFLASH_RESULT_ERR : Erase error.  \nESP_ROM_SPIFLASH_RESULT_TIMEOUT : Erase timeout."},"sortText":"41276889esp_rom_spiflash_erase_sector","filterText":"esp_rom_spiflash_erase_sector","insertText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"esp_rom_spiflash_erase_sector(${1:uint32_t sector_num})"}},{"label":"xthal_tram_pending_to_service()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nTrampoline support functions:"},"sortText":"41276889xthal_tram_pending_to_service","filterText":"xthal_tram_pending_to_service","insertText":"xthal_tram_pending_to_service()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"xthal_tram_pending_to_service()"}},{"label":"hall_sensor_read()","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"driver/adc.h\"`  \n@brief Read Hall Sensor  \n@note When the power switch of SARADC1, SARADC2, HALL sensor and AMP sensor is turned on,  \nthe input of GPIO36 and GPIO39 will be pulled down for about 80ns.  \nWhen enabling power for any of these peripherals, ignore input from GPIO36 and GPIO39.  \nPlease refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue.  \n@note The Hall Sensor uses channels 0 and 3 of ADC1. Do not configure these channels for use as ADC channels.  \n@note The ADC1 module must be enabled by calling adc1_config_width() before calling hall_sensor_read(). ADC1 should be configured for 12 bit readings, as the hall sensor readings are low values and do not cover the full range of the ADC.  \n@return The hall sensor reading."},"sortText":"413198efhall_sensor_read","filterText":"hall_sensor_read","insertText":"hall_sensor_read()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"hall_sensor_read()"}},{"label":"lwip_send_r(int s, const void *dataptr, size_t size, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_send_r","filterText":"lwip_send_r","insertText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"lwip_send_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags})"}},{"label":"lwip_sendmsg_r(int s, const struct msghdr *message, int flags)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendmsg_r","filterText":"lwip_sendmsg_r","insertText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"lwip_sendmsg_r(${1:int s}, ${2:const struct msghdr *message}, ${3:int flags})"}},{"label":"lwip_sendto_r(int s, const void *dataptr, size_t size, int flags, const struct sockaddr *to, socklen_t tolen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_sendto_r","filterText":"lwip_sendto_r","insertText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"lwip_sendto_r(${1:int s}, ${2:const void *dataptr}, ${3:size_t size}, ${4:int flags}, ${5:const struct sockaddr *to}, ${6:socklen_t tolen})"}},{"label":"lwip_setsockopt_r(int s, int level, int optname, const void *optval, socklen_t optlen)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"lwip/sockets.h\"`"},"sortText":"413df103lwip_setsockopt_r","filterText":"lwip_setsockopt_r","insertText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"lwip_setsockopt_r(${1:int s}, ${2:int level}, ${3:int optname}, ${4:const void *optval}, ${5:socklen_t optlen})"}},{"label":"COOKIE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334COOKIE_SERVER","filterText":"COOKIE_SERVER","insertText":"COOKIE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"COOKIE_SERVER"}},{"label":"IMPRESS_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334IMPRESS_SERVER","filterText":"IMPRESS_SERVER","insertText":"IMPRESS_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"IMPRESS_SERVER"}},{"label":"LOG_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LOG_SERVER","filterText":"LOG_SERVER","insertText":"LOG_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"LOG_SERVER"}},{"label":"LPR_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334LPR_SERVER","filterText":"LPR_SERVER","insertText":"LPR_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"LPR_SERVER"}},{"label":"NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334NAME_SERVER","filterText":"NAME_SERVER","insertText":"NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NAME_SERVER"}},{"label":"NAME_SERVICE_SEARCH","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NAME_SERVICE_SEARCH","filterText":"NAME_SERVICE_SEARCH","insertText":"NAME_SERVICE_SEARCH","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NAME_SERVICE_SEARCH"}},{"label":"NDS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334NDS_SERVERS","filterText":"NDS_SERVERS","insertText":"NDS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NDS_SERVERS"}},{"label":"NNTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334NNTP_SERVER","filterText":"NNTP_SERVER","insertText":"NNTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NNTP_SERVER"}},{"label":"SMTP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334SMTP_SERVER","filterText":"SMTP_SERVER","insertText":"SMTP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SMTP_SERVER"}},{"label":"STREETTALK_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"414bc334STREETTALK_SERVER","filterText":"STREETTALK_SERVER","insertText":"STREETTALK_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"STREETTALK_SERVER"}},{"label":"SWAP_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334SWAP_SERVER","filterText":"SWAP_SERVER","insertText":"SWAP_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"SWAP_SERVER"}},{"label":"TFTP_SERVER_NAME","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nDHCP Extensions"},"sortText":"414bc334TFTP_SERVER_NAME","filterText":"TFTP_SERVER_NAME","insertText":"TFTP_SERVER_NAME","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"TFTP_SERVER_NAME"}},{"label":"TIME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"414bc334TIME_SERVER","filterText":"TIME_SERVER","insertText":"TIME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"TIME_SERVER"}},{"label":" esp_dport_access_sequence_reg_read(uint32_t reg)","kind":3,"detail":"uint32_t","sortText":"41500923esp_dport_access_sequence_reg_read","filterText":"esp_dport_access_sequence_reg_read","insertText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"esp_dport_access_sequence_reg_read(${1:uint32_t reg})"}},{"label":"DPORT_SEQUENCE_REG_READ(uint32_t reg)","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"soc/dport_access.h\"`  \n@brief Read value from register, NOT SMP-safe version.  \nThis method uses the pre-reading of the APB register before reading the register of the DPORT.  \nThere is not disable/enable interrupt.  \nThe difference from DPORT_REG_READ() is that the user himself must disable interrupts while DPORT reading.  \nThis implementation is useful for reading DORT registers in loop without stall other CPU. Note the usage example.  \nThe recommended way to read registers sequentially without stall other CPU is to use the method esp_dport_read_buffer(buff_out, address, num_words). It allows you to read registers in the buffer.  \n\\\\code{c} // This example shows how to use it.  \n{ // Use curly brackets to limit the visibility of variables in macros DPORT_INTERRUPT_DISABLE/RESTORE.  \nDPORT_INTERRUPT_DISABLE(); // Disable interrupt only on current CPU.  \nfor (i = 0; i \u003c max; ++i) { array[i] = DPORT_SEQUENCE_REG_READ(Address + i * 4); // reading DPORT registers } DPORT_INTERRUPT_RESTORE(); // restore the previous interrupt level }  \n\\\\endcode  \n@param reg Register address  \n@return Value"},"sortText":"4168a03fDPORT_SEQUENCE_REG_READ","filterText":"DPORT_SEQUENCE_REG_READ","insertText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"DPORT_SEQUENCE_REG_READ(${1:uint32_t reg})"}},{"label":"DEFAULT_FINGER_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_FINGER_SERVER","filterText":"DEFAULT_FINGER_SERVER","insertText":"DEFAULT_FINGER_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"DEFAULT_FINGER_SERVER"}},{"label":"DEFAULT_IRC_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_IRC_SERVER","filterText":"DEFAULT_IRC_SERVER","insertText":"DEFAULT_IRC_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"DEFAULT_IRC_SERVER"}},{"label":"DEFAULT_WWW_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cDEFAULT_WWW_SERVER","filterText":"DEFAULT_WWW_SERVER","insertText":"DEFAULT_WWW_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"DEFAULT_WWW_SERVER"}},{"label":"DOMAIN_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cDOMAIN_NAME_SERVER","filterText":"DOMAIN_NAME_SERVER","insertText":"DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"DOMAIN_NAME_SERVER"}},{"label":"NETWORK_INFORMATION_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVERS","filterText":"NETWORK_INFORMATION_SERVERS","insertText":"NETWORK_INFORMATION_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETWORK_INFORMATION_SERVERS"}},{"label":"NETWORK_INFORMATION_SERVICE_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_DOMAIN"}},{"label":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cNETWORK_INFORMATION_SERVICE_PLUS_SERVERS","filterText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETWORK_INFORMATION_SERVICE_PLUS_SERVERS"}},{"label":"POP3_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"416fcf5cPOP3_SERVER","filterText":"POP3_SERVER","insertText":"POP3_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"POP3_SERVER"}},{"label":"RESOURCE_LOCATION_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nRFC 1497 Vendor Extensions"},"sortText":"416fcf5cRESOURCE_LOCATION_SERVER","filterText":"RESOURCE_LOCATION_SERVER","insertText":"RESOURCE_LOCATION_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"RESOURCE_LOCATION_SERVER"}},{"label":"NETWORK_TIME_PROTOCOL_SERVERS","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bNETWORK_TIME_PROTOCOL_SERVERS","filterText":"NETWORK_TIME_PROTOCOL_SERVERS","insertText":"NETWORK_TIME_PROTOCOL_SERVERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETWORK_TIME_PROTOCOL_SERVERS"}},{"label":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41a7b70bSTREETTALK_DIRECTORY_ASSISTANCE_SERVER","filterText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"STREETTALK_DIRECTORY_ASSISTANCE_SERVER"}},{"label":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","kind":20,"detail":"tcpip_adapter_dhcp_option_id_t","documentation":{"kind":"markdown","value":"From `\"tcpip_adapter.h\"`  \nDomain name server"},"sortText":"41e04ec4TCPIP_ADAPTER_DOMAIN_NAME_SERVER","filterText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"TCPIP_ADAPTER_DOMAIN_NAME_SERVER"}},{"label":"X_WINDOW_SYSTEM_FONT_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"41efcf5cX_WINDOW_SYSTEM_FONT_SERVER","filterText":"X_WINDOW_SYSTEM_FONT_SERVER","insertText":"X_WINDOW_SYSTEM_FONT_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"X_WINDOW_SYSTEM_FONT_SERVER"}},{"label":"ESP_ROM_SPIFLASH_RESULT_ERR","kind":20,"detail":"esp_rom_spiflash_result_t","documentation":{"kind":"markdown","value":"From `\"rom/spi_flash.h\"`"},"sortText":"42276889ESP_ROM_SPIFLASH_RESULT_ERR","filterText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertText":"ESP_ROM_SPIFLASH_RESULT_ERR","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"ESP_ROM_SPIFLASH_RESULT_ERR"}},{"label":"system_efuse_read_mac(uint8_t *mac)","kind":3,"detail":"esp_err_t","documentation":{"kind":"markdown","value":"From `\"esp_system.h\"`  \n@brief Read hardware MAC address.  \nFunction has been renamed to esp_efuse_mac_get_default.  \nThis name will be removed in a future release.  \n@param mac hardware MAC address, length: 6 bytes.  \n@return ESP_OK on success"},"sortText":"42444e03system_efuse_read_mac","filterText":"system_efuse_read_mac","insertText":"system_efuse_read_mac(${1:uint8_t *mac})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"system_efuse_read_mac(${1:uint8_t *mac})"}},{"label":"NETBIOS_OVER_TCP_IP_NAME_SERVER","kind":20,"detail":"dhcp_msg_option","documentation":{"kind":"markdown","value":"From `\"dhcpserver/dhcpserver_options.h\"`  \nApplication and Service Parameters"},"sortText":"426fcf5cNETBIOS_OVER_TCP_IP_NAME_SERVER","filterText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertText":"NETBIOS_OVER_TCP_IP_NAME_SERVER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"NETBIOS_OVER_TCP_IP_NAME_SERVER"}},{"label":"std::__throw_system_error(int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\u003clist\u003e`"},"sortText":"430300b6__throw_system_error","filterText":"__throw_system_error","insertText":"std::__throw_system_error(${1:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":7}},"newText":"std::__throw_system_error(${1:int})"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":194},"contentChanges":[{"range":{"start":{"line":238,"character":7},"end":{"line":238,"character":7}},"rangeLength":0,"text":"i"}]}}
>>>
Content-Length: 731

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":7}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Ser'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":195},"contentChanges":[{"range":{"start":{"line":238,"character":8},"end":{"line":238,"character":8}},"rangeLength":0,"text":"a"}]}}
>>>
Content-Length: 732

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'Seri'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":196},"contentChanges":[{"range":{"start":{"line":238,"character":9},"end":{"line":238,"character":9}},"rangeLength":0,"text":"l"}]}}
>>>
Content-Length: 1112

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":9}},"severity":1,"code":"undeclared_var_use_suggest","source":"clang","message":"Use of undeclared identifier 'Seria'; did you mean 'Serial'? (fix available)\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h:116:23:\nnote: 'Serial' declared here"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":130,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":10},"end":{"line":238,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":130,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 243

{"jsonrpc":"2.0","id":131,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":10},"context":{"triggerKind":3}}}
>>>
Content-Length: 10880

{"id":131,"result":{"isIncomplete":false,"items":[{"label":"Serial","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3db96de1Serial","filterText":"Serial","insertText":"Serial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"Serial"}},{"label":" serialPlotter()","kind":3,"detail":"void","sortText":"3ea7f738serialPlotter","filterText":"serialPlotter","insertText":"serialPlotter()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"serialPlotter()"}},{"label":" serialPrint()","kind":3,"detail":"void","sortText":"3eceb9faserialPrint","filterText":"serialPrint","insertText":"serialPrint()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"serialPrint()"}},{"label":"HardwareSerial","kind":7,"documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3f48147aHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"HardwareSerial"}},{"label":" HardwareSerial()","kind":4,"detail":"[3 overloads]","sortText":"3f58ccccHardwareSerial","filterText":"HardwareSerial","insertText":"HardwareSerial($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"HardwareSerial($0)"}},{"label":"Serial1","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial1","filterText":"Serial1","insertText":"Serial1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"Serial1"}},{"label":"Serial2","kind":6,"detail":"HardwareSerial","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429Serial2","filterText":"Serial2","insertText":"Serial2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"Serial2"}},{"label":"serialEventRun()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"HardwareSerial.h\"`"},"sortText":"3fefa429serialEventRun","filterText":"serialEventRun","insertText":"serialEventRun()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"serialEventRun()"}},{"label":" SERIAL","kind":1,"documentation":{"kind":"markdown","value":"From `\"Arduino.h\"`"},"sortText":"3fffeb90SERIAL","filterText":"SERIAL","insertText":"SERIAL","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL"}},{"label":"SERIAL_5E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5E1","filterText":"SERIAL_5E1","insertText":"SERIAL_5E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5E1"}},{"label":"SERIAL_5E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5E2","filterText":"SERIAL_5E2","insertText":"SERIAL_5E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5E2"}},{"label":"SERIAL_5N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5N1","filterText":"SERIAL_5N1","insertText":"SERIAL_5N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5N1"}},{"label":"SERIAL_5N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5N2","filterText":"SERIAL_5N2","insertText":"SERIAL_5N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5N2"}},{"label":"SERIAL_5O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5O1","filterText":"SERIAL_5O1","insertText":"SERIAL_5O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5O1"}},{"label":"SERIAL_5O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_5O2","filterText":"SERIAL_5O2","insertText":"SERIAL_5O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_5O2"}},{"label":"SERIAL_6E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6E1","filterText":"SERIAL_6E1","insertText":"SERIAL_6E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6E1"}},{"label":"SERIAL_6E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6E2","filterText":"SERIAL_6E2","insertText":"SERIAL_6E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6E2"}},{"label":"SERIAL_6N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6N1","filterText":"SERIAL_6N1","insertText":"SERIAL_6N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6N1"}},{"label":"SERIAL_6N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6N2","filterText":"SERIAL_6N2","insertText":"SERIAL_6N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6N2"}},{"label":"SERIAL_6O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6O1","filterText":"SERIAL_6O1","insertText":"SERIAL_6O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6O1"}},{"label":"SERIAL_6O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_6O2","filterText":"SERIAL_6O2","insertText":"SERIAL_6O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_6O2"}},{"label":"SERIAL_7E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7E1","filterText":"SERIAL_7E1","insertText":"SERIAL_7E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7E1"}},{"label":"SERIAL_7E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7E2","filterText":"SERIAL_7E2","insertText":"SERIAL_7E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7E2"}},{"label":"SERIAL_7N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7N1","filterText":"SERIAL_7N1","insertText":"SERIAL_7N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7N1"}},{"label":"SERIAL_7N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7N2","filterText":"SERIAL_7N2","insertText":"SERIAL_7N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7N2"}},{"label":"SERIAL_7O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7O1","filterText":"SERIAL_7O1","insertText":"SERIAL_7O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7O1"}},{"label":"SERIAL_7O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_7O2","filterText":"SERIAL_7O2","insertText":"SERIAL_7O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_7O2"}},{"label":"SERIAL_8E1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8E1","filterText":"SERIAL_8E1","insertText":"SERIAL_8E1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8E1"}},{"label":"SERIAL_8E2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8E2","filterText":"SERIAL_8E2","insertText":"SERIAL_8E2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8E2"}},{"label":"SERIAL_8N1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8N1","filterText":"SERIAL_8N1","insertText":"SERIAL_8N1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8N1"}},{"label":"SERIAL_8N2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8N2","filterText":"SERIAL_8N2","insertText":"SERIAL_8N2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8N2"}},{"label":"SERIAL_8O1","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8O1","filterText":"SERIAL_8O1","insertText":"SERIAL_8O1","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8O1"}},{"label":"SERIAL_8O2","kind":1,"documentation":{"kind":"markdown","value":"From `\"esp32-hal-uart.h\"`"},"sortText":"40c209ddSERIAL_8O2","filterText":"SERIAL_8O2","insertText":"SERIAL_8O2","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}},"newText":"SERIAL_8O2"}}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":197},"contentChanges":[{"range":{"start":{"line":238,"character":10},"end":{"line":238,"character":10}},"rangeLength":0,"text":"."}]}}Content-Length: 266

{"jsonrpc":"2.0","id":132,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":11},"context":{"triggerKind":2,"triggerCharacter":"."}}}
>>>
Content-Length: 8387

{"id":132,"result":{"isIncomplete":false,"items":[{"label":" print()","kind":2,"detail":"[14 overloads]","sortText":"3e9d2f71print","filterText":"print","insertText":"print($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"print($0)"}},{"label":" println()","kind":2,"detail":"[15 overloads]","sortText":"3ebde057println","filterText":"println","insertText":"println($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"println($0)"}},{"label":" available()","kind":2,"detail":"int","sortText":"3ee51eb8available","filterText":"available","insertText":"available()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"available()"}},{"label":" availableForWrite()","kind":2,"detail":"int","sortText":"3ee51eb8availableForWrite","filterText":"availableForWrite","insertText":"availableForWrite()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"availableForWrite()"}},{"label":" baudRate()","kind":2,"detail":"uint32_t","sortText":"3ee51eb8baudRate","filterText":"baudRate","insertText":"baudRate()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"baudRate()"}},{"label":" begin(unsigned long baud, uint32_t config = SERIAL_8N1, int8_t rxPin = -1, int8_t txPin = -1, bool invert = false, unsigned long timeout_ms = 20000UL)","kind":2,"detail":"void","sortText":"3ee51eb8begin","filterText":"begin","insertText":"begin(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"begin(${1:unsigned long baud})"}},{"label":" end()","kind":2,"detail":"void","sortText":"3ee51eb8end","filterText":"end","insertText":"end()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"end()"}},{"label":" flush()","kind":2,"detail":"[2 overloads]","sortText":"3ee51eb8flush","filterText":"flush","insertText":"flush($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"flush($0)"}},{"label":" peek()","kind":2,"detail":"int","sortText":"3ee51eb8peek","filterText":"peek","insertText":"peek()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"peek()"}},{"label":" read()","kind":2,"detail":"[3 overloads]","sortText":"3ee51eb8read","filterText":"read","insertText":"read($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"read($0)"}},{"label":" setDebugOutput(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setDebugOutput","filterText":"setDebugOutput","insertText":"setDebugOutput(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"setDebugOutput(${1:bool})"}},{"label":" setRxBufferSize(size_t)","kind":2,"detail":"size_t","sortText":"3ee51eb8setRxBufferSize","filterText":"setRxBufferSize","insertText":"setRxBufferSize(${1:size_t})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"setRxBufferSize(${1:size_t})"}},{"label":" setRxInvert(bool)","kind":2,"detail":"void","sortText":"3ee51eb8setRxInvert","filterText":"setRxInvert","insertText":"setRxInvert(${1:bool})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"setRxInvert(${1:bool})"}},{"label":" updateBaudRate(unsigned long baud)","kind":2,"detail":"void","sortText":"3ee51eb8updateBaudRate","filterText":"updateBaudRate","insertText":"updateBaudRate(${1:unsigned long baud})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"updateBaudRate(${1:unsigned long baud})"}},{"label":" write()","kind":2,"detail":"[8 overloads]","sortText":"3ee51eb8write","filterText":"write","insertText":"write($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"write($0)"}},{"label":" printf(const char *format, ...)","kind":2,"detail":"size_t","sortText":"3f17ae13printf","filterText":"printf","insertText":"printf(${1:const char *format, ...})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"printf(${1:const char *format, ...})"}},{"label":" readBytes()","kind":2,"detail":"[2 overloads]","sortText":"3f17ae13readBytes","filterText":"readBytes","insertText":"readBytes($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"readBytes($0)"}},{"label":" readBytesUntil()","kind":2,"detail":"[2 overloads]","sortText":"3f17ae13readBytesUntil","filterText":"readBytesUntil","insertText":"readBytesUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"readBytesUntil($0)"}},{"label":" clearWriteError()","kind":2,"detail":"void","sortText":"3f651eb8clearWriteError","filterText":"clearWriteError","insertText":"clearWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"clearWriteError()"}},{"label":" find()","kind":2,"detail":"[5 overloads]","sortText":"3f651eb8find","filterText":"find","insertText":"find($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"find($0)"}},{"label":" findUntil()","kind":2,"detail":"[4 overloads]","sortText":"3f651eb8findUntil","filterText":"findUntil","insertText":"findUntil($0)","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"findUntil($0)"}},{"label":" getTimeout()","kind":2,"detail":"unsigned long","sortText":"3f651eb8getTimeout","filterText":"getTimeout","insertText":"getTimeout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"getTimeout()"}},{"label":" getWriteError()","kind":2,"detail":"int","sortText":"3f651eb8getWriteError","filterText":"getWriteError","insertText":"getWriteError()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"getWriteError()"}},{"label":" parseFloat()","kind":2,"detail":"float","sortText":"3f651eb8parseFloat","filterText":"parseFloat","insertText":"parseFloat()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"parseFloat()"}},{"label":" parseInt()","kind":2,"detail":"long","sortText":"3f651eb8parseInt","filterText":"parseInt","insertText":"parseInt()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"parseInt()"}},{"label":" readString()","kind":2,"detail":"String","sortText":"3f651eb8readString","filterText":"readString","insertText":"readString()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"readString()"}},{"label":" readStringUntil(char terminator)","kind":2,"detail":"String","sortText":"3f651eb8readStringUntil","filterText":"readStringUntil","insertText":"readStringUntil(${1:char terminator})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"readStringUntil(${1:char terminator})"}},{"label":" setTimeout(unsigned long timeout)","kind":2,"detail":"void","sortText":"3f651eb8setTimeout","filterText":"setTimeout","insertText":"setTimeout(${1:unsigned long timeout})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":11}},"newText":"setTimeout(${1:unsigned long timeout})"}}]},"jsonrpc":"2.0"}Content-Length: 725

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_unqualified_id","source":"clang","message":"Expected unqualified-id"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":198},"contentChanges":[{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":11}},"rangeLength":0,"text":"p"}]}}
>>>
Content-Length: 931

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":12}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'p' in 'HardwareSerial'"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":199},"contentChanges":[{"range":{"start":{"line":238,"character":12},"end":{"line":238,"character":12}},"rangeLength":0,"text":"r"}]}}
>>>
Content-Length: 932

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":13}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":199}}}Content-Length: 314

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":200},"contentChanges":[{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":13}},"rangeLength":2,"text":"print()"}]}}
>>>
Content-Length: 3419

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":16}},"severity":1,"code":"ovl_no_viable_member_function_in_call","source":"clang","message":"No matching member function for call to 'print'\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:81:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:82:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:83:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:84:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:93:12:\nnote: candidate function not viable: requires 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:85:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:86:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:87:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:88:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:89:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:90:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:91:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:92:12:\nnote: candidate function not viable: requires at least 1 argument, but 0 were provided\n\n/home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.h:94:12:\nnote: candidate function not viable: requires at least argument 'timeinfo', but no arguments were provided"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":133,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":133,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":200}}}
>>>
Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":3,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":3,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":201},"contentChanges":[{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":17}},"rangeLength":0,"text":"x"}]}}
>>>
Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 243

{"jsonrpc":"2.0","id":134,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":18},"context":{"triggerKind":1}}}Content-Length: 285

{"jsonrpc":"2.0","id":135,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":18},"end":{"line":238,"character":18}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":202},"contentChanges":[{"range":{"start":{"line":238,"character":18},"end":{"line":238,"character":18}},"rangeLength":0,"text":"P"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":135}}Content-Length: 285

{"jsonrpc":"2.0","id":136,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":19},"end":{"line":238,"character":19}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":203},"contentChanges":[{"range":{"start":{"line":238,"character":19},"end":{"line":238,"character":19}},"rangeLength":0,"text":"o"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":136}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":204},"contentChanges":[{"range":{"start":{"line":238,"character":20},"end":{"line":238,"character":20}},"rangeLength":0,"text":"r"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":205},"contentChanges":[{"range":{"start":{"line":238,"character":21},"end":{"line":238,"character":21}},"rangeLength":0,"text":"t"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":137,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":22},"end":{"line":238,"character":22}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":206},"contentChanges":[{"range":{"start":{"line":238,"character":22},"end":{"line":238,"character":22}},"rangeLength":0,"text":"G"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":137}}Content-Length: 285

{"jsonrpc":"2.0","id":138,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":23},"end":{"line":238,"character":23}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":207},"contentChanges":[{"range":{"start":{"line":238,"character":23},"end":{"line":238,"character":23}},"rangeLength":0,"text":"e"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":138}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":208},"contentChanges":[{"range":{"start":{"line":238,"character":24},"e
>>>
Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":4,"jsonrpc":"2.0"}Content-Length: 75548

{"id":134,"result":{"isIncomplete":true,"items":[{"label":" xTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName, const uint32_t usStackDepth, void *const pvParameters, UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)","kind":3,"detail":"BaseType_t","sortText":"3fde70d5xTaskCreate","filterText":"xTaskCreate","insertText":"xTaskCreate(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t usStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:TaskHandle_t *const pvCreatedTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCreate(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t usStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:TaskHandle_t *const pvCreatedTask})"}},{"label":" xTASK_PARAMETERS","kind":22,"documentation":{"kind":"markdown","value":"Parameters required to create an MPU protected task."},"sortText":"3fefa429xTASK_PARAMETERS","filterText":"xTASK_PARAMETERS","insertText":"xTASK_PARAMETERS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTASK_PARAMETERS"}},{"label":" xTASK_SNAPSHOT","kind":22,"documentation":{"kind":"markdown","value":"Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.  \nWe need this struct because TCB_t is defined (hidden) in tasks.c."},"sortText":"3fefa429xTASK_SNAPSHOT","filterText":"xTASK_SNAPSHOT","insertText":"xTASK_SNAPSHOT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTASK_SNAPSHOT"}},{"label":" xTASK_STATUS","kind":22,"documentation":{"kind":"markdown","value":"Used with the uxTaskGetSystemState() function to return the state of each task in the system."},"sortText":"3fefa429xTASK_STATUS","filterText":"xTASK_STATUS","insertText":"xTASK_STATUS","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTASK_STATUS"}},{"label":" xTaskCallApplicationTaskHook(TaskHandle_t xTask, void *pvParameter)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Calls the hook function associated with xTask. Passing xTask as NULL has the effect of calling the Running tasks (the calling task) hook function.  \n@param xTask Handle of the task to call the hook for.  \n@param pvParameter Parameter passed to the hook function for the task to interpret as it wants. The return value is the value returned by the task hook function registered by the user."},"sortText":"3fefa429xTaskCallApplicationTaskHook","filterText":"xTaskCallApplicationTaskHook","insertText":"xTaskCallApplicationTaskHook(${1:TaskHandle_t xTask}, ${2:void *pvParameter})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCallApplicationTaskHook(${1:TaskHandle_t xTask}, ${2:void *pvParameter})"}},{"label":" xTaskCheckForTimeOut(TimeOut_t *const pxTimeOut, TickType_t *const pxTicksToWait)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Compare the time status now with that previously captured to see if the timeout has expired."},"sortText":"3fefa429xTaskCheckForTimeOut","filterText":"xTaskCheckForTimeOut","insertText":"xTaskCheckForTimeOut(${1:TimeOut_t *const pxTimeOut}, ${2:TickType_t *const pxTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCheckForTimeOut(${1:TimeOut_t *const pxTimeOut}, ${2:TickType_t *const pxTicksToWait})"}},{"label":" xTaskCreatePinnedToCore(TaskFunction_t pvTaskCode, const char *const pcName, const uint32_t usStackDepth, void *const pvParameters, UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask, const BaseType_t xCoreID)","kind":3,"detail":"BaseType_t","sortText":"3fefa429xTaskCreatePinnedToCore","filterText":"xTaskCreatePinnedToCore","insertText":"xTaskCreatePinnedToCore(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t usStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:TaskHandle_t *const pvCreatedTask}, ${7:const BaseType_t xCoreID})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCreatePinnedToCore(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t usStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:TaskHandle_t *const pvCreatedTask}, ${7:const BaseType_t xCoreID})"}},{"label":" xTaskCreateRestricted(const TaskParameters_t *const pxTaskDefinition, TaskHandle_t *pxCreatedTask)","kind":3,"detail":"BaseType_t","sortText":"3fefa429xTaskCreateRestricted","filterText":"xTaskCreateRestricted","insertText":"xTaskCreateRestricted(${1:const TaskParameters_t *const pxTaskDefinition}, ${2:TaskHandle_t *pxCreatedTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCreateRestricted(${1:const TaskParameters_t *const pxTaskDefinition}, ${2:TaskHandle_t *pxCreatedTask})"}},{"label":" xTaskCreateStatic(TaskFunction_t pvTaskCode, const char *const pcName, const uint32_t ulStackDepth, void *const pvParameters, UBaseType_t uxPriority, StackType_t *const pxStackBuffer, StaticTask_t *const pxTaskBuffer)","kind":3,"detail":"TaskHandle_t","sortText":"3fefa429xTaskCreateStatic","filterText":"xTaskCreateStatic","insertText":"xTaskCreateStatic(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t ulStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:StackType_t *const pxStackBuffer}, ${7:StaticTask_t *const pxTaskBuffer})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCreateStatic(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t ulStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:StackType_t *const pxStackBuffer}, ${7:StaticTask_t *const pxTaskBuffer})"}},{"label":" xTaskCreateStaticPinnedToCore(TaskFunction_t pvTaskCode, const char *const pcName, const uint32_t ulStackDepth, void *const pvParameters, UBaseType_t uxPriority, StackType_t *const pxStackBuffer, StaticTask_t *const pxTaskBuffer, const BaseType_t xCoreID)","kind":3,"detail":"TaskHandle_t","sortText":"3fefa429xTaskCreateStaticPinnedToCore","filterText":"xTaskCreateStaticPinnedToCore","insertText":"xTaskCreateStaticPinnedToCore(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t ulStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:StackType_t *const pxStackBuffer}, ${7:StaticTask_t *const pxTaskBuffer}, ${8:const BaseType_t xCoreID})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskCreateStaticPinnedToCore(${1:TaskFunction_t pvTaskCode}, ${2:const char *const pcName}, ${3:const uint32_t ulStackDepth}, ${4:void *const pvParameters}, ${5:UBaseType_t uxPriority}, ${6:StackType_t *const pxStackBuffer}, ${7:StaticTask_t *const pxTaskBuffer}, ${8:const BaseType_t xCoreID})"}},{"label":" xTaskGetAffinity(TaskHandle_t xTask)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Get the current core affinity of a task"},"sortText":"3fefa429xTaskGetAffinity","filterText":"xTaskGetAffinity","insertText":"xTaskGetAffinity(${1:TaskHandle_t xTask})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetAffinity(${1:TaskHandle_t xTask})"}},{"label":" xTaskGetCurrentTaskHandle()","kind":3,"detail":"TaskHandle_t","documentation":{"kind":"markdown","value":"Return the handle of the calling task."},"sortText":"3fefa429xTaskGetCurrentTaskHandle","filterText":"xTaskGetCurrentTaskHandle","insertText":"xTaskGetCurrentTaskHandle()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetCurrentTaskHandle()"}},{"label":" xTaskGetCurrentTaskHandleForCPU(BaseType_t cpuid)","kind":3,"detail":"TaskHandle_t","documentation":{"kind":"markdown","value":"Return the handle of the task running on a certain CPU. Because of the nature of SMP processing, there is no guarantee that this value will still be valid on return and should only be used for debugging purposes."},"sortText":"3fefa429xTaskGetCurrentTaskHandleForCPU","filterText":"xTaskGetCurrentTaskHandleForCPU","insertText":"xTaskGetCurrentTaskHandleForCPU(${1:BaseType_t cpuid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetCurrentTaskHandleForCPU(${1:BaseType_t cpuid})"}},{"label":" xTaskGetIdleTaskHandle()","kind":3,"detail":"TaskHandle_t","documentation":{"kind":"markdown","value":"Get the handle of idle task for the current CPU.  \nxTaskGetIdleTaskHandle() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.  \n@return The handle of the idle task. It is not valid to call xTaskGetIdleTaskHandle() before the scheduler has been started."},"sortText":"3fefa429xTaskGetIdleTaskHandle","filterText":"xTaskGetIdleTaskHandle","insertText":"xTaskGetIdleTaskHandle()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetIdleTaskHandle()"}},{"label":" xTaskGetIdleTaskHandleForCPU(UBaseType_t cpuid)","kind":3,"detail":"TaskHandle_t","documentation":{"kind":"markdown","value":"Get the handle of idle task for the given CPU.  \nxTaskGetIdleTaskHandleForCPU() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.  \n@param cpuid The CPU to get the handle for  \n@return Idle task handle of a given cpu. It is not valid to call xTaskGetIdleTaskHandleForCPU() before the scheduler has been started."},"sortText":"3fefa429xTaskGetIdleTaskHandleForCPU","filterText":"xTaskGetIdleTaskHandleForCPU","insertText":"xTaskGetIdleTaskHandleForCPU(${1:UBaseType_t cpuid})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetIdleTaskHandleForCPU(${1:UBaseType_t cpuid})"}},{"label":" xTaskGetSchedulerState()","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Returns the scheduler state as taskSCHEDULER_RUNNING,  \ntaskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED."},"sortText":"3fefa429xTaskGetSchedulerState","filterText":"xTaskGetSchedulerState","insertText":"xTaskGetSchedulerState()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetSchedulerState()"}},{"label":" xTaskGetTickCount()","kind":3,"detail":"TickType_t","documentation":{"kind":"markdown","value":"Get tick count  \n@return The count of ticks since vTaskStartScheduler was called.  \n\\\\ingroup TaskUtils"},"sortText":"3fefa429xTaskGetTickCount","filterText":"xTaskGetTickCount","insertText":"xTaskGetTickCount()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetTickCount()"}},{"label":" xTaskGetTickCountFromISR()","kind":3,"detail":"TickType_t","documentation":{"kind":"markdown","value":"Get tick count from ISR  \n@return The count of ticks since vTaskStartScheduler was called.  \nThis is a version of xTaskGetTickCount() that is safe to be called from an ISR - provided that TickType_t is the natural word size of the microcontroller being used or interrupt nesting is either not supported or not being used.  \n\\\\ingroup TaskUtils"},"sortText":"3fefa429xTaskGetTickCountFromISR","filterText":"xTaskGetTickCountFromISR","insertText":"xTaskGetTickCountFromISR()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskGetTickCountFromISR()"}},{"label":" xTaskIncrementTick()","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"\\----------------------------------------------------------- SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES  \n\\----------------------------------------------------------  \n@cond  \nTHIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE. IT IS ONLY INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.  \nCalled from the real time kernel tick (either preemptive or cooperative),  \nthis increments the tick count and checks if any tasks that are blocked for a finite period required removing from a blocked list and placing on a ready list. If a non-zero value is returned then a context switch is required because either:  \n\\+ A task was removed from a blocked list because its timeout had expired,  \nor + Time slicing is in use and there is a task of equal priority to the currently running task."},"sortText":"3fefa429xTaskIncrementTick","filterText":"xTaskIncrementTick","insertText":"xTaskIncrementTick()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskIncrementTick()"}},{"label":" xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Send task notification.  \nconfigUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.  \nWhen configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).  \nEvents can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.  \nA notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.  \nA notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.  \nA task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.  \nSee http://www.FreeRTOS.org/RTOS-task-notifications.html for details.  \n@param xTaskToNotify The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().  \n@param ulValue Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.  \n@param eAction Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:  \n\\- eSetBits:  \nThe task's notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.  \n\\- eIncrement:  \nThe task's notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.  \n\\- eSetValueWithOverwrite:  \nThe task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.  \n\\- eSetValueWithoutOverwrite:  \nIf the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.  \n\\- eNoAction:  \nThe task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.  \n@return Dependent on the value of eAction. See the description of the eAction parameter.  \n\\\\ingroup TaskNotifications"},"sortText":"3fefa429xTaskNotify","filterText":"xTaskNotify","insertText":"xTaskNotify(${1:TaskHandle_t xTaskToNotify}, ${2:uint32_t ulValue}, ${3:eNotifyAction eAction})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskNotify(${1:TaskHandle_t xTaskToNotify}, ${2:uint32_t ulValue}, ${3:eNotifyAction eAction})"}},{"label":" xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Send task notification from an ISR.  \nconfigUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.  \nWhen configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).  \nA version of xTaskNotify() that can be used from an interrupt service routine (ISR).  \nEvents can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.  \nA notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.  \nA notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.  \nA task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.  \nSee http://www.FreeRTOS.org/RTOS-task-notifications.html for details.  \n@param xTaskToNotify The handle of the task being notified. The handle to a task can be returned from the xTaskCreate() API function used to create the task, and the handle of the currently running task can be obtained by calling xTaskGetCurrentTaskHandle().  \n@param ulValue Data that can be sent with the notification. How the data is used depends on the value of the eAction parameter.  \n@param eAction Specifies how the notification updates the task's notification value, if at all. Valid values for eAction are as follows:  \n\\- eSetBits:  \nThe task's notification value is bitwise ORed with ulValue. xTaskNofify() always returns pdPASS in this case.  \n\\- eIncrement:  \nThe task's notification value is incremented. ulValue is not used and xTaskNotify() always returns pdPASS in this case.  \n\\- eSetValueWithOverwrite:  \nThe task's notification value is set to the value of ulValue, even if the task being notified had not yet processed the previous notification (the task already had a notification pending). xTaskNotify() always returns pdPASS in this case.  \n\\- eSetValueWithoutOverwrite:  \nIf the task being notified did not already have a notification pending then the task's notification value is set to ulValue and xTaskNotify() will return pdPASS. If the task being notified already had a notification pending then no action is performed and pdFAIL is returned.  \n\\- eNoAction:  \nThe task receives a notification without its notification value being updated. ulValue is not used and xTaskNotify() always returns pdPASS in this case.  \n@param pxHigherPriorityTaskWoken xTaskNotifyFromISR() will set  \n\\*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the task to which the notification was sent to leave the Blocked state, and the unblocked task has a priority higher than the currently running task. If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. How a context switch is requested from an ISR is dependent on the port - see the documentation page for the port in use.  \n@return Dependent on the value of eAction. See the description of the eAction parameter.  \n\\\\ingroup TaskNotifications"},"sortText":"3fefa429xTaskNotifyFromISR","filterText":"xTaskNotifyFromISR","insertText":"xTaskNotifyFromISR(${1:TaskHandle_t xTaskToNotify}, ${2:uint32_t ulValue}, ${3:eNotifyAction eAction}, ${4:BaseType_t *pxHigherPriorityTaskWoken})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskNotifyFromISR(${1:TaskHandle_t xTaskToNotify}, ${2:uint32_t ulValue}, ${3:eNotifyAction eAction}, ${4:BaseType_t *pxHigherPriorityTaskWoken})"}},{"label":" xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Wait for task notification  \nconfigUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this function to be available.  \nWhen configUSE_TASK_NOTIFICATIONS is set to one each task has its own private \"notification value\", which is a 32-bit unsigned integer (uint32_t).  \nEvents can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.  \nA notification sent to a task can optionally perform an action, such as update, overwrite or increment the task's notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.  \nA notification sent to a task will remain pending until it is cleared by the task calling xTaskNotifyWait() or ulTaskNotifyTake(). If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.  \nA task can use xTaskNotifyWait() to [optionally] block to wait for a notification to be pending, or ulTaskNotifyTake() to [optionally] block to wait for its notification value to have a non-zero value. The task does not consume any CPU time while it is in the Blocked state.  \nSee http://www.FreeRTOS.org/RTOS-task-notifications.html for details.  \n@param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value will be cleared in the calling task's notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.  \n@param ulBitsToClearOnExit If a notification is pending or received before the calling task exits the xTaskNotifyWait() function then the task's notification value (see the xTaskNotify() API function) is passed out using the pulNotificationValue parameter. Then any bits that are set in ulBitsToClearOnExit will be cleared in the task's notification value (note  \n\\*pulNotificationValue is set before any bits are cleared). Setting ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL (if limits.h is not included) will have the effect of resetting the task's notification value to 0 before the function exits. Setting ulBitsToClearOnExit to 0 will leave the task's notification value unchanged when the function exits (in which case the value passed out in pulNotificationValue will match the task's notification value).  \n@param pulNotificationValue Used to pass the task's notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ulBitsToClearOnExit being non-zero.  \n@param xTicksToWait The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when xTaskNotifyWait() was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.  \n@return If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned.  \n\\\\ingroup TaskNotifications"},"sortText":"3fefa429xTaskNotifyWait","filterText":"xTaskNotifyWait","insertText":"xTaskNotifyWait(${1:uint32_t ulBitsToClearOnEntry}, ${2:uint32_t ulBitsToClearOnExit}, ${3:uint32_t *pulNotificationValue}, ${4:TickType_t xTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskNotifyWait(${1:uint32_t ulBitsToClearOnEntry}, ${2:uint32_t ulBitsToClearOnExit}, ${3:uint32_t *pulNotificationValue}, ${4:TickType_t xTicksToWait})"}},{"label":" xTaskPriorityDisinherit(const TaskHandle_t pxMutexHolder)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Set the priority of a task back to its proper priority in the case that it inherited a higher priority while it was holding a semaphore."},"sortText":"3fefa429xTaskPriorityDisinherit","filterText":"xTaskPriorityDisinherit","insertText":"xTaskPriorityDisinherit(${1:const TaskHandle_t pxMutexHolder})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskPriorityDisinherit(${1:const TaskHandle_t pxMutexHolder})"}},{"label":" xTaskRemoveFromEventList(const List_t *const pxEventList)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE. IT IS AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.  \nTHIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.  \nRemoves a task from both the specified event list and the list of blocked tasks, and places it on a ready queue.  \nxTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called if either an event occurs to unblock a task, or the block timeout period expires.  \nxTaskRemoveFromEventList() is used when the event list is in task priority order. It removes the list item from the head of the event list as that will have the highest priority owning task of all the tasks on the event list.  \nxTaskRemoveFromUnorderedEventList() is used when the event list is not ordered and the event list items hold something other than the owning tasks priority. In this case the event list item value is updated to the value passed in the xItemValue parameter.  \n@return pdTRUE if the task being removed has a higher priority than the task making the call, otherwise pdFALSE."},"sortText":"3fefa429xTaskRemoveFromEventList","filterText":"xTaskRemoveFromEventList","insertText":"xTaskRemoveFromEventList(${1:const List_t *const pxEventList})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskRemoveFromEventList(${1:const List_t *const pxEventList})"}},{"label":" xTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem, const TickType_t xItemValue)","kind":3,"detail":"BaseType_t","sortText":"3fefa429xTaskRemoveFromUnorderedEventList","filterText":"xTaskRemoveFromUnorderedEventList","insertText":"xTaskRemoveFromUnorderedEventList(${1:ListItem_t *pxEventListItem}, ${2:const TickType_t xItemValue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskRemoveFromUnorderedEventList(${1:ListItem_t *pxEventListItem}, ${2:const TickType_t xItemValue})"}},{"label":" xTaskResumeAll()","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"Resumes scheduler activity after it was suspended by a call to vTaskSuspendAll().  \nxTaskResumeAll() only resumes the scheduler. It does not unsuspend tasks that were previously suspended by a call to vTaskSuspend().  \n@return If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.  \nExample usage:  \n@code{c} void vTask1( void * pvParameters ) { for( ;; ) { // Task code goes here.  \n// ...  \n// At some point the task wants to perform a long operation during // which it does not want to get swapped out. It cannot use // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the // operation may cause interrupts to be missed - including the // ticks.  \n// Prevent the real time kernel swapping out the task.  \nvTaskSuspendAll ();  \n// Perform the operation here. There is no need to use critical // sections as we have all the microcontroller processing time.  \n// During this time interrupts will still operate and the real // time kernel tick count will be maintained.  \n// ...  \n// The operation is complete. Restart the kernel. We want to force // a context switch - but there is no point if resuming the scheduler // caused a context switch already.  \nif( !xTaskResumeAll () ) { taskYIELD ();  \n} } }  \n@endcode  \n\\\\ingroup SchedulerControl"},"sortText":"3fefa429xTaskResumeAll","filterText":"xTaskResumeAll","insertText":"xTaskResumeAll()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskResumeAll()"}},{"label":" xTaskResumeFromISR(TaskHandle_t xTaskToResume)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"An implementation of vTaskResume() that can be called from within an ISR.  \nINCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.  \nA task that has been suspended by one or more calls to vTaskSuspend () will be made available for running again by a single call to xTaskResumeFromISR ().  \nxTaskResumeFromISR() should not be used to synchronise a task with an interrupt if there is a chance that the interrupt could arrive prior to the task being suspended - as this can lead to interrupts being missed. Use of a semaphore as a synchronisation mechanism would avoid this eventuality.  \n@param xTaskToResume Handle to the task being readied.  \n@return pdTRUE if resuming the task should result in a context switch,  \notherwise pdFALSE. This is used by the ISR to determine if a context switch may be required following the ISR.  \n\\\\ingroup TaskCtrl"},"sortText":"3fefa429xTaskResumeFromISR","filterText":"xTaskResumeFromISR","insertText":"xTaskResumeFromISR(${1:TaskHandle_t xTaskToResume})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTaskResumeFromISR(${1:TaskHandle_t xTaskToResume})"}},{"label":" xQueueGenericSend(QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"It is preferred that the macros xQueueSend(), xQueueSendToFront() and xQueueSendToBack() are used in place of calling this function directly.  \nPost an item on a queue. The item is queued by copy, not by reference.  \nThis function must not be called from an interrupt service routine.  \nSee xQueueSendFromISR () for an alternative which may be used in an ISR.  \n@param xQueue The handle to the queue on which the item is to be posted.  \n@param pvItemToQueue A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.  \n@param xTicksToWait The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.  \n@param xCopyPosition Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).  \n@return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.  \nExample usage:  \n@code{c} struct AMessage { char ucMessageID;  \nchar ucData[ 20 ];  \n} xMessage;  \nuint32_t ulVar = 10UL;  \nvoid vATask( void \\*pvParameters ) { QueueHandle_t xQueue1, xQueue2;  \nstruct AMessage \\*pxMessage;  \n// Create a queue capable of containing 10 uint32_t values.  \nxQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );  \n// Create a queue capable of containing 10 pointers to AMessage structures.  \n// These should be passed by pointer as they contain a lot of data.  \nxQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );  \n// ...  \nif( xQueue1 != 0 ) { // Send an uint32_t. Wait for 10 ticks for space to become // available if necessary.  \nif( xQueueGenericSend( xQueue1, ( void * ) \u0026ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS ) { // Failed to post the message, even after 10 ticks.  \n} }  \nif( xQueue2 != 0 ) { // Send a pointer to a struct AMessage object. Don't block if the // queue is already full.  \npxMessage = \u0026 xMessage;  \nxQueueGenericSend( xQueue2, ( void * ) \u0026pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );  \n}  \n// ... Rest of task code.  \n}  \n@endcode  \n\\\\ingroup QueueManagement"},"sortText":"403c1a43xQueueGenericSend","filterText":"xQueueGenericSend","insertText":"xQueueGenericSend(${1:QueueHandle_t xQueue}, ${2:const void *const pvItemToQueue}, ${3:TickType_t xTicksToWait}, ${4:const BaseType_t xCopyPosition})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueGenericSend(${1:QueueHandle_t xQueue}, ${2:const void *const pvItemToQueue}, ${3:TickType_t xTicksToWait}, ${4:const BaseType_t xCopyPosition})"}},{"label":" xQueueGenericReceive(QueueHandle_t xQueue, void *const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"It is preferred that the macro xQueueReceive() be used rather than calling this function directly.  \nReceive an item from a queue. The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.  \nThis function must not be used in an interrupt service routine. See xQueueReceiveFromISR for an alternative that can.  \n@param xQueue The handle to the queue from which the item is to be received.  \n@param pvBuffer Pointer to the buffer into which the received item will be copied.  \n@param xTicksToWait The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required.  \nxQueueGenericReceive() will return immediately if the queue is empty and xTicksToWait is 0.  \n@param xJustPeek When set to true, the item received from the queue is not actually removed from the queue - meaning a subsequent call to xQueueReceive() will return the same item. When set to false, the item being received from the queue is also removed from the queue.  \n@return pdTRUE if an item was successfully received from the queue,  \notherwise pdFALSE.  \nExample usage:  \n@code{c} struct AMessage { char ucMessageID;  \nchar ucData[ 20 ];  \n} xMessage;  \nQueueHandle_t xQueue;  \n// Task to create a queue and post a value.  \nvoid vATask( void \\*pvParameters ) { struct AMessage \\*pxMessage;  \n// Create a queue capable of containing 10 pointers to AMessage structures.  \n// These should be passed by pointer as they contain a lot of data.  \nxQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );  \nif( xQueue == 0 ) { // Failed to create the queue.  \n}  \n// ...  \n// Send a pointer to a struct AMessage object. Don't block if the // queue is already full.  \npxMessage = \u0026 xMessage;  \nxQueueSend( xQueue, ( void * ) \u0026pxMessage, ( TickType_t ) 0 );  \n// ... Rest of task code.  \n}  \n// Task to receive from the queue.  \nvoid vADifferentTask( void \\*pvParameters ) { struct AMessage \\*pxRxedMessage;  \nif( xQueue != 0 ) { // Receive a message on the created queue. Block for 10 ticks if a // message is not immediately available.  \nif( xQueueGenericReceive( xQueue, \u0026( pxRxedMessage ), ( TickType_t ) 10 ) ) { // pcRxedMessage now points to the struct AMessage variable posted // by vATask.  \n} }  \n// ... Rest of task code.  \n}  \n@endcode  \n\\\\ingroup QueueManagement"},"sortText":"403f0c58xQueueGenericReceive","filterText":"xQueueGenericReceive","insertText":"xQueueGenericReceive(${1:QueueHandle_t xQueue}, ${2:void *const pvBuffer}, ${3:TickType_t xTicksToWait}, ${4:const BaseType_t xJustPeek})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueGenericReceive(${1:QueueHandle_t xQueue}, ${2:void *const pvBuffer}, ${3:TickType_t xTicksToWait}, ${4:const BaseType_t xJustPeek})"}},{"label":" xMEMORY_REGION","kind":22,"documentation":{"kind":"markdown","value":"Defines the memory ranges allocated to the task when an MPU is used."},"sortText":"403f858bxMEMORY_REGION","filterText":"xMEMORY_REGION","insertText":"xMEMORY_REGION","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xMEMORY_REGION"}},{"label":"xSTATIC_LIST","kind":22,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`  \nSee the comments above the struct xSTATIC_LIST_ITEM definition."},"sortText":"403f858bxSTATIC_LIST","filterText":"xSTATIC_LIST","insertText":"xSTATIC_LIST","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xSTATIC_LIST"}},{"label":"xSTATIC_TIMER","kind":22,"documentation":{"kind":"markdown","value":"From `\"freertos/FreeRTOS.h\"`  \nIn line with software engineering best practice, especially when supplying a library that is likely to change in future versions, FreeRTOS implements a strict data hiding policy. This means the software timer structure used internally by FreeRTOS is not accessible to application code. However, if the application writer wants to statically allocate the memory required to create a software timer then the size of the queue object needs to be know.  \nThe StaticTimer_t structure below is provided for this purpose. Its sizes and alignment requirements are guaranteed to match those of the genuine structure, no matter which architecture is being used, and no matter how the values in FreeRTOSConfig.h are set. Its contents are somewhat obfuscated in the hope users will recognise that it would be unwise to make direct use of the structure members."},"sortText":"403f858bxSTATIC_TIMER","filterText":"xSTATIC_TIMER","insertText":"xSTATIC_TIMER","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xSTATIC_TIMER"}},{"label":" xTIME_OUT","kind":22,"documentation":{"kind":"markdown","value":"@cond  \nUsed internally only."},"sortText":"403f858bxTIME_OUT","filterText":"xTIME_OUT","insertText":"xTIME_OUT","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xTIME_OUT"}},{"label":"XtHalVoidFunc","kind":8,"documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \n\\---------------------------------------------------------------------- Generic Interrupt Trampolining Support (DEPRECATED)  \n\\----------------------------------------------------------------------"},"sortText":"405d8e68XtHalVoidFunc","filterText":"XtHalVoidFunc","insertText":"XtHalVoidFunc","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"XtHalVoidFunc"}},{"label":"Xthal_all_extra_size","kind":6,"detail":"const unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_all_extra_size","filterText":"Xthal_all_extra_size","insertText":"Xthal_all_extra_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_all_extra_size"}},{"label":"Xthal_build_unique_id","kind":6,"detail":"const unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_build_unique_id","filterText":"Xthal_build_unique_id","insertText":"Xthal_build_unique_id","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_build_unique_id"}},{"label":"Xthal_cp_mask","kind":6,"detail":"const unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nindex of highest allowed coprocessor number, per cfg, plus one  \nextern const unsigned char Xthal_cp_maxcfg;  \nbitmask of which coprocessors are present"},"sortText":"405d8e68Xthal_cp_mask","filterText":"Xthal_cp_mask","insertText":"Xthal_cp_mask","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_cp_mask"}},{"label":"Xthal_cpregs_align","kind":6,"detail":"const unsigned int [8]","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_cpregs_align","filterText":"Xthal_cpregs_align","insertText":"Xthal_cpregs_align","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_cpregs_align"}},{"label":"Xthal_cpregs_save_nw_fn","kind":6,"detail":"void *[8]","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nsimilarly for non-windowed ABI (may be same or different)"},"sortText":"405d8e68Xthal_cpregs_save_nw_fn","filterText":"Xthal_cpregs_save_nw_fn","insertText":"Xthal_cpregs_save_nw_fn","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_cpregs_save_nw_fn"}},{"label":"Xthal_cpregs_size","kind":6,"detail":"const unsigned int [8]","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_cpregs_size","filterText":"Xthal_cpregs_size","insertText":"Xthal_cpregs_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_cpregs_size"}},{"label":"Xthal_dataram_size","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_dataram_size","filterText":"Xthal_dataram_size","insertText":"Xthal_dataram_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_dataram_size"}},{"label":"Xthal_datarom_paddr","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_datarom_paddr","filterText":"Xthal_datarom_paddr","insertText":"Xthal_datarom_paddr","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_datarom_paddr"}},{"label":"Xthal_dcache_size","kind":6,"detail":"const unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_dcache_size","filterText":"Xthal_dcache_size","insertText":"Xthal_dcache_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_dcache_size"}},{"label":"Xthal_dtlb_way_bits","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_dtlb_way_bits","filterText":"Xthal_dtlb_way_bits","insertText":"Xthal_dtlb_way_bits","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_dtlb_way_bits"}},{"label":"Xthal_have_booleans","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_booleans","filterText":"Xthal_have_booleans","insertText":"Xthal_have_booleans","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_booleans"}},{"label":"Xthal_have_ccount","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nset if CCOUNT register present"},"sortText":"405d8e68Xthal_have_ccount","filterText":"Xthal_have_ccount","insertText":"Xthal_have_ccount","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_ccount"}},{"label":"Xthal_have_exceptions","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_exceptions","filterText":"Xthal_have_exceptions","insertText":"Xthal_have_exceptions","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_exceptions"}},{"label":"Xthal_have_mimic_cacheattr","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_mimic_cacheattr","filterText":"Xthal_have_mimic_cacheattr","insertText":"Xthal_have_mimic_cacheattr","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_mimic_cacheattr"}},{"label":"Xthal_have_mul16","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_mul16","filterText":"Xthal_have_mul16","insertText":"Xthal_have_mul16","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_mul16"}},{"label":"Xthal_have_nmi","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_nmi","filterText":"Xthal_have_nmi","insertText":"Xthal_have_nmi","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_nmi"}},{"label":"Xthal_have_nsa","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_nsa","filterText":"Xthal_have_nsa","insertText":"Xthal_have_nsa","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_nsa"}},{"label":"Xthal_have_spanning_way","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \n\\---------------------------------------------------------------------- Memory Management Unit  \n\\----------------------------------------------------------------------"},"sortText":"405d8e68Xthal_have_spanning_way","filterText":"Xthal_have_spanning_way","insertText":"Xthal_have_spanning_way","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_spanning_way"}},{"label":"Xthal_have_windowed","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_have_windowed","filterText":"Xthal_have_windowed","insertText":"Xthal_have_windowed","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_have_windowed"}},{"label":"Xthal_icache_linewidth","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nsize of the cache lines in log2(bytes)"},"sortText":"405d8e68Xthal_icache_linewidth","filterText":"Xthal_icache_linewidth","insertText":"Xthal_icache_linewidth","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_icache_linewidth"}},{"label":"Xthal_instram_size","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_instram_size","filterText":"Xthal_instram_size","insertText":"Xthal_instram_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_instram_size"}},{"label":"Xthal_instram_vaddr","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_instram_vaddr","filterText":"Xthal_instram_vaddr","insertText":"Xthal_instram_vaddr","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_instram_vaddr"}},{"label":"Xthal_instrom_size","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_instrom_size","filterText":"Xthal_instrom_size","insertText":"Xthal_instrom_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_instrom_size"}},{"label":"Xthal_inttype","kind":6,"detail":"const unsigned char [32]","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \ntype per interrupt"},"sortText":"405d8e68Xthal_inttype","filterText":"Xthal_inttype","insertText":"Xthal_inttype","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_inttype"}},{"label":"Xthal_mmu_asid_bits","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \n0 .. 8"},"sortText":"405d8e68Xthal_mmu_asid_bits","filterText":"Xthal_mmu_asid_bits","insertText":"Xthal_mmu_asid_bits","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_mmu_asid_bits"}},{"label":"Xthal_mmu_max_pte_page_size","kind":6,"detail":"const unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_mmu_max_pte_page_size","filterText":"Xthal_mmu_max_pte_page_size","insertText":"Xthal_mmu_max_pte_page_size","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_mmu_max_pte_page_size"}},{"label":"Xthal_mmu_sr_bits","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_mmu_sr_bits","filterText":"Xthal_mmu_sr_bits","insertText":"Xthal_mmu_sr_bits","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_mmu_sr_bits"}},{"label":"Xthal_num_intlevels","kind":6,"detail":"const unsigned char","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nthe number of interrupt levels"},"sortText":"405d8e68Xthal_num_intlevels","filterText":"Xthal_num_intlevels","insertText":"Xthal_num_intlevels","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_num_intlevels"}},{"label":"Xthal_release_name","kind":6,"detail":"const char *const","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_release_name","filterText":"Xthal_release_name","insertText":"Xthal_release_name","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_release_name"}},{"label":"Xthal_tram_sync","kind":6,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nBitmask of interrupts configured for sync trampolining:"},"sortText":"405d8e68Xthal_tram_sync","filterText":"Xthal_tram_sync","insertText":"Xthal_tram_sync","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_tram_sync"}},{"label":"Xthal_xlmi_paddr","kind":6,"detail":"const unsigned int []","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68Xthal_xlmi_paddr","filterText":"Xthal_xlmi_paddr","insertText":"Xthal_xlmi_paddr","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"Xthal_xlmi_paddr"}},{"label":"xPortGetTickRateHz()","kind":3,"detail":"uint32_t","documentation":{"kind":"markdown","value":"From `\"freertos/portable.h\"`  \nGet tick rate per second"},"sortText":"405d8e68xPortGetTickRateHz","filterText":"xPortGetTickRateHz","insertText":"xPortGetTickRateHz()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xPortGetTickRateHz()"}},{"label":" xQueueAltGenericSend(QueueHandle_t xQueue, const void *const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"@cond  \nxQueueAltGenericSend() is an alternative version of xQueueGenericSend().  \nLikewise xQueueAltGenericReceive() is an alternative version of xQueueGenericReceive().  \nThe source code that implements the alternative (Alt) API is much simpler because it executes everything from within a critical section.  \nThis is the approach taken by many other RTOSes, but FreeRTOS.org has the preferred fully featured API too. The fully featured API has more complex code that takes longer to execute, but makes much less use of critical sections. Therefore the alternative API sacrifices interrupt responsiveness to gain execution speed, whereas the fully featured API sacrifices execution speed to ensure better interrupt responsiveness."},"sortText":"405d8e68xQueueAltGenericSend","filterText":"xQueueAltGenericSend","insertText":"xQueueAltGenericSend(${1:QueueHandle_t xQueue}, ${2:const void *const pvItemToQueue}, ${3:TickType_t xTicksToWait}, ${4:BaseType_t xCopyPosition})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueAltGenericSend(${1:QueueHandle_t xQueue}, ${2:const void *const pvItemToQueue}, ${3:TickType_t xTicksToWait}, ${4:BaseType_t xCopyPosition})"}},{"label":" xQueueCRSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait)","kind":3,"detail":"BaseType_t","sortText":"405d8e68xQueueCRSend","filterText":"xQueueCRSend","insertText":"xQueueCRSend(${1:QueueHandle_t xQueue}, ${2:const void *pvItemToQueue}, ${3:TickType_t xTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueCRSend(${1:QueueHandle_t xQueue}, ${2:const void *pvItemToQueue}, ${3:TickType_t xTicksToWait})"}},{"label":" xQueueCRSendFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"The functions defined above are for passing data to and from tasks. The functions below are the equivalents for passing data to and from co-routines.  \nThese functions are called from the co-routine macro implementation and should not be called directly from application code. Instead use the macro wrappers defined within croutine.h."},"sortText":"405d8e68xQueueCRSendFromISR","filterText":"xQueueCRSendFromISR","insertText":"xQueueCRSendFromISR(${1:QueueHandle_t xQueue}, ${2:const void *pvItemToQueue}, ${3:BaseType_t xCoRoutinePreviouslyWoken})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueCRSendFromISR(${1:QueueHandle_t xQueue}, ${2:const void *pvItemToQueue}, ${3:BaseType_t xCoRoutinePreviouslyWoken})"}},{"label":" xQueueCreateMutex(const uint8_t ucQueueType)","kind":3,"detail":"QueueHandle_t","documentation":{"kind":"markdown","value":"For internal use only. Use xSemaphoreCreateMutex(),  \nxSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling these functions directly."},"sortText":"405d8e68xQueueCreateMutex","filterText":"xQueueCreateMutex","insertText":"xQueueCreateMutex(${1:const uint8_t ucQueueType})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueCreateMutex(${1:const uint8_t ucQueueType})"}},{"label":" xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue)","kind":3,"detail":"QueueHandle_t","sortText":"405d8e68xQueueCreateMutexStatic","filterText":"xQueueCreateMutexStatic","insertText":"xQueueCreateMutexStatic(${1:const uint8_t ucQueueType}, ${2:StaticQueue_t *pxStaticQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueCreateMutexStatic(${1:const uint8_t ucQueueType}, ${2:StaticQueue_t *pxStaticQueue})"}},{"label":" xQueueGiveMutexRecursive(QueueHandle_t pxMutex)","kind":3,"detail":"BaseType_t","sortText":"405d8e68xQueueGiveMutexRecursive","filterText":"xQueueGiveMutexRecursive","insertText":"xQueueGiveMutexRecursive(${1:QueueHandle_t pxMutex})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueGiveMutexRecursive(${1:QueueHandle_t pxMutex})"}},{"label":" xQueueIsQueueFullFromISR(const QueueHandle_t xQueue)","kind":3,"detail":"BaseType_t","sortText":"405d8e68xQueueIsQueueFullFromISR","filterText":"xQueueIsQueueFullFromISR","insertText":"xQueueIsQueueFullFromISR(${1:const QueueHandle_t xQueue})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueIsQueueFullFromISR(${1:const QueueHandle_t xQueue})"}},{"label":" xQueueSelectFromSet(QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)","kind":3,"detail":"QueueSetMemberHandle_t","documentation":{"kind":"markdown","value":"xQueueSelectFromSet() selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). xQueueSelectFromSet() effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously.  \nSee FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.  \nNote 1: See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.  \nNote 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.  \nNote 3: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to xQueueSelectFromSet() has first returned a handle to that set member.  \n@param xQueueSet The queue set on which the task will (potentially) block.  \n@param xTicksToWait The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation.  \n@return xQueueSelectFromSet() will return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data,  \nor the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires."},"sortText":"405d8e68xQueueSelectFromSet","filterText":"xQueueSelectFromSet","insertText":"xQueueSelectFromSet(${1:QueueSetHandle_t xQueueSet}, ${2:const TickType_t xTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueSelectFromSet(${1:QueueSetHandle_t xQueueSet}, ${2:const TickType_t xTicksToWait})"}},{"label":" xQueueSelectFromSetFromISR(QueueSetHandle_t xQueueSet)","kind":3,"detail":"QueueSetMemberHandle_t","documentation":{"kind":"markdown","value":"A version of xQueueSelectFromSet() that can be used from an ISR."},"sortText":"405d8e68xQueueSelectFromSetFromISR","filterText":"xQueueSelectFromSetFromISR","insertText":"xQueueSelectFromSetFromISR(${1:QueueSetHandle_t xQueueSet})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueSelectFromSetFromISR(${1:QueueSetHandle_t xQueueSet})"}},{"label":" xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait)","kind":3,"detail":"BaseType_t","documentation":{"kind":"markdown","value":"For internal use only. Use xSemaphoreTakeMutexRecursive() or xSemaphoreGiveMutexRecursive() instead of calling these functions directly."},"sortText":"405d8e68xQueueTakeMutexRecursive","filterText":"xQueueTakeMutexRecursive","insertText":"xQueueTakeMutexRecursive(${1:QueueHandle_t xMutex}, ${2:TickType_t xTicksToWait})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xQueueTakeMutexRecursive(${1:QueueHandle_t xMutex}, ${2:TickType_t xTicksToWait})"}},{"label":"xthal_cache_coherence_optout()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_cache_coherence_optout","filterText":"xthal_cache_coherence_optout","insertText":"xthal_cache_coherence_optout()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_cache_coherence_optout()"}},{"label":"xthal_compare_and_set(int *addr, int test_val, int compare_val)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \n\\---------------------------------------------------------------------- MP Synchronization  \n\\----------------------------------------------------------------------"},"sortText":"405d8e68xthal_compare_and_set","filterText":"xthal_compare_and_set","insertText":"xthal_compare_and_set(${1:int *addr}, ${2:int test_val}, ${3:int compare_val})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_compare_and_set(${1:int *addr}, ${2:int test_val}, ${3:int compare_val})"}},{"label":"xthal_dcache_all_writeback()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nwrite dirty data back"},"sortText":"405d8e68xthal_dcache_all_writeback","filterText":"xthal_dcache_all_writeback","insertText":"xthal_dcache_all_writeback()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_dcache_all_writeback()"}},{"label":"xthal_dcache_get_ways()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nget number of dcache ways enabled"},"sortText":"405d8e68xthal_dcache_get_ways","filterText":"xthal_dcache_get_ways","insertText":"xthal_dcache_get_ways()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_dcache_get_ways()"}},{"label":"xthal_dcache_line_unlock(void *addr)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_dcache_line_unlock","filterText":"xthal_dcache_line_unlock","insertText":"xthal_dcache_line_unlock(${1:void *addr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_dcache_line_unlock(${1:void *addr})"}},{"label":"xthal_dcache_region_lock(void *addr, unsigned int size)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_dcache_region_lock","filterText":"xthal_dcache_region_lock","insertText":"xthal_dcache_region_lock(${1:void *addr}, ${2:unsigned int size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_dcache_region_lock(${1:void *addr}, ${2:unsigned int size})"}},{"label":"xthal_dcache_region_unlock(void *addr, unsigned int size)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_dcache_region_unlock","filterText":"xthal_dcache_region_unlock","insertText":"xthal_dcache_region_unlock(${1:void *addr}, ${2:unsigned int size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_dcache_region_unlock(${1:void *addr}, ${2:unsigned int size})"}},{"label":"xthal_disassemble(unsigned char *instr_buf, void *tgt_addr, char *buffer, unsigned int buflen, unsigned int options)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nroutine to get a string for the disassembled instruction"},"sortText":"405d8e68xthal_disassemble","filterText":"xthal_disassemble","insertText":"xthal_disassemble(${1:unsigned char *instr_buf}, ${2:void *tgt_addr}, ${3:char *buffer}, ${4:unsigned int buflen}, ${5:unsigned int options})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_disassemble(${1:unsigned char *instr_buf}, ${2:void *tgt_addr}, ${3:char *buffer}, ${4:unsigned int buflen}, ${5:unsigned int options})"}},{"label":"xthal_disassemble_size(unsigned char *instr_buf)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nroutine to get the size of the next instruction. Returns 0 for illegal instruction"},"sortText":"405d8e68xthal_disassemble_size","filterText":"xthal_disassemble_size","insertText":"xthal_disassemble_size(${1:unsigned char *instr_buf})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_disassemble_size(${1:unsigned char *instr_buf})"}},{"label":"xthal_get_cacheattr()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \ncache attribute register control (used by other HAL routines)"},"sortText":"405d8e68xthal_get_cacheattr","filterText":"xthal_get_cacheattr","insertText":"xthal_get_cacheattr()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_get_cacheattr()"}},{"label":"xthal_get_ccount()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nget CCOUNT register (if not present return 0)"},"sortText":"405d8e68xthal_get_ccount","filterText":"xthal_get_ccount","insertText":"xthal_get_ccount()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_get_ccount()"}},{"label":"xthal_get_icacheattr()","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_get_icacheattr","filterText":"xthal_get_icacheattr","insertText":"xthal_get_icacheattr()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_get_icacheattr()"}},{"label":"xthal_icache_enable()","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nenable caches"},"sortText":"405d8e68xthal_icache_enable","filterText":"xthal_icache_enable","insertText":"xthal_icache_enable()","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_icache_enable()"}},{"label":"xthal_icache_region_invalidate(void *addr, unsigned int size)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \ninvalidate the caches"},"sortText":"405d8e68xthal_icache_region_invalidate","filterText":"xthal_icache_region_invalidate","insertText":"xthal_icache_region_invalidate(${1:void *addr}, ${2:unsigned int size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_icache_region_invalidate(${1:void *addr}, ${2:unsigned int size})"}},{"label":"xthal_icache_region_lock(void *addr, unsigned int size)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nprefetch and lock specified memory range into cache"},"sortText":"405d8e68xthal_icache_region_lock","filterText":"xthal_icache_region_lock","insertText":"xthal_icache_region_lock(${1:void *addr}, ${2:unsigned int size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_icache_region_lock(${1:void *addr}, ${2:unsigned int size})"}},{"label":"xthal_icache_region_unlock(void *addr, unsigned int size)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_icache_region_unlock","filterText":"xthal_icache_region_unlock","insertText":"xthal_icache_region_unlock(${1:void *addr}, ${2:unsigned int size})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_icache_region_unlock(${1:void *addr}, ${2:unsigned int size})"}},{"label":"xthal_int_enable(unsigned int)","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`  \nEnables/disables given set (mask) of interrupts; returns previous enabled-mask of all ints:"},"sortText":"405d8e68xthal_int_enable","filterText":"xthal_int_enable","insertText":"xthal_int_enable(${1:unsigned int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_int_enable(${1:unsigned int})"}},{"label":"xthal_intlevel_to_vpri(unsigned int intlevel)","kind":3,"detail":"unsigned int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_intlevel_to_vpri","filterText":"xthal_intlevel_to_vpri","insertText":"xthal_intlevel_to_vpri(${1:unsigned int intlevel})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_intlevel_to_vpri(${1:unsigned int intlevel})"}},{"label":"xthal_invalidate_region(void *addr)","kind":3,"detail":"int","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_invalidate_region","filterText":"xthal_invalidate_region","insertText":"xthal_invalidate_region(${1:void *addr})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_invalidate_region(${1:void *addr})"}},{"label":"xthal_restore_cp2(void *base)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_restore_cp2","filterText":"xthal_restore_cp2","insertText":"xthal_restore_cp2(${1:void *base})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_restore_cp2(${1:void *base})"}},{"label":"xthal_restore_cp5(void *base)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_restore_cp5","filterText":"xthal_restore_cp5","insertText":"xthal_restore_cp5(${1:void *base})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_restore_cp5(${1:void *base})"}},{"label":"xthal_restore_cpregs(void *base, int)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_restore_cpregs","filterText":"xthal_restore_cpregs","insertText":"xthal_restore_cpregs(${1:void *base}, ${2:int})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_restore_cpregs(${1:void *base}, ${2:int})"}},{"label":"xthal_restore_extra(void *base)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_restore_extra","filterText":"xthal_restore_extra","insertText":"xthal_restore_extra(${1:void *base})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_restore_extra(${1:void *base})"}},{"label":"xthal_save_cp1(void *base)","kind":3,"detail":"void","documentation":{"kind":"markdown","value":"From `\"xtensa/hal.h\"`"},"sortText":"405d8e68xthal_save_cp1","filterText":"xthal_save_cp1","insertText":"xthal_save_cp1(${1:void *base})","insertTextFormat":2,"textEdit":{"range":{"start":{"line":273,"character":17},"end":{"line":273,"character":18}},"newText":"xthal_save_cp1(${1:void *base})"}}]},"jsonrpc":"2.0"}Content-Length: 933

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":18}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'x'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":135,"result":[],"jsonrpc":"2.0"}Content-Length: 38

{"id":136,"result":[],"jsonrpc":"2.0"}Content-Length: 934

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":19}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xP'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":137,"result":[],"jsonrpc":"2.0"}Content-Length: 937

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":22}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPort'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":138,"result":[],"jsonrpc":"2.0"}
<<<
nd":{"line":238,"character":24}},"rangeLength":0,"text":"t"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":139,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":25},"end":{"line":238,"character":25}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":209},"contentChanges":[{"range":{"start":{"line":238,"character":25},"end":{"line":238,"character":25}},"rangeLength":0,"text":"F"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":139}}Content-Length: 285

{"jsonrpc":"2.0","id":140,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":26},"end":{"line":238,"character":26}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":210},"contentChanges":[{"range":{"start":{"line":238,"character":26},"end":{"line":238,"character":26}},"rangeLength":0,"text":"r"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":140}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":211},"contentChanges":[{"range":{"start":{"line":238,"character":27},"end":{"line":238,"character":27}},"rangeLength":0,"text":"e"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":141,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":28},"end":{"line":238,"character":28}},"context":{"diagnostics":[]}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":211}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":212},"contentChanges":[{"range":{"start":{"line":238,"character":28},"end":{"line":238,"character":28}},"rangeLength":0,"text":"e"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":141}}Content-Length: 285

{"jsonrpc":"2.0","id":142,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":29},"end":{"line":238,"character":29}},"context":{"diagnostics":[]}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":212}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":213},"contentChanges":[{"range":{"start":{"line":238,"character":29},"end":{"line":238,"character":29}},"rangeLength":0,"text":"H"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":142}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":214},"contentChanges":[{"range":{"start":{"line":238,"character":30},"end":{"line":238,"character":30}},"rangeLength":0,"text":"e"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didCha
>>>
Content-Length: 938

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":23}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortG'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":139,"result":[],"jsonrpc":"2.0"}Content-Length: 940

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":25}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGet'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":140,"result":[],"jsonrpc":"2.0"}Content-Length: 941

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":26}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGetF'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":141,"result":[],"jsonrpc":"2.0"}Content-Length: 943

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":28}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGetFre'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":142,"result":[],"jsonrpc":"2.0"}
<<<
nge","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":215},"contentChanges":[{"range":{"start":{"line":238,"character":31},"end":{"line":238,"character":31}},"rangeLength":0,"text":"a"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":216},"contentChanges":[{"range":{"start":{"line":238,"character":32},"end":{"line":238,"character":32}},"rangeLength":0,"text":"p"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":143,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":33},"end":{"line":238,"character":33}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":217},"contentChanges":[{"range":{"start":{"line":238,"character":33},"end":{"line":238,"character":33}},"rangeLength":0,"text":"S"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":143}}Content-Length: 285

{"jsonrpc":"2.0","id":144,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":34},"end":{"line":238,"character":34}},"context":{"diagnostics":[]}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":218},"contentChanges":[{"range":{"start":{"line":238,"character":34},"end":{"line":238,"character":34}},"rangeLength":0,"text":"i"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":144}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":219},"contentChanges":[{"range":{"start":{"line":238,"character":35},"end":{"line":238,"character":35}},"rangeLength":0,"text":"z"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":220},"contentChanges":[{"range":{"start":{"line":238,"character":36},"end":{"line":238,"character":36}},"rangeLength":0,"text":"e"}]}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":221},"contentChanges":[{"range":{"start":{"line":238,"character":37},"end":{"line":238,"character":37}},"rangeLength":0,"text":"()"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":222},"contentChanges":[{"range":{"start":{"line":238,"character":38},"end":{"line":238,"character":39}},"rangeLength":1,"text":")"}]}}Content-Length: 289

{"jsonrpc":"2.0","id":145,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":39},"context":{"isRetrigger":false,"triggerCharacter":"(","triggerKind":2}}}Content-Length: 285

{"jsonrpc":"2.0","id":146,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":39},"end":{"line":238,"character":39}},"context":{"diagnostics":[]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":134}}Content-Length: 178

>>>
Content-Length: 944

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":29}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGetFree'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":143,"result":[],"jsonrpc":"2.0"}Content-Length: 948

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":33}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGetFreeHeap'"}]},"jsonrpc":"2.0"}Content-Length: 949

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":34}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'xPortGetFreeHeapS'"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":144,"result":[],"jsonrpc":"2.0"}Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 183

{"id":145,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}Content-Length: 38

{"id":146,"result":[],"jsonrpc":"2.0"}
<<<

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":222}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":145}}Content-Length: 265

{"jsonrpc":"2.0","id":147,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":40},"context":{"isRetrigger":true,"triggerKind":3}}}Content-Length: 285

{"jsonrpc":"2.0","id":148,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":40},"end":{"line":238,"character":40}},"context":{"diagnostics":[]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":146}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":223},"contentChanges":[{"range":{"start":{"line":238,"character":40},"end":{"line":238,"character":40}},"rangeLength":0,"text":";"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":148}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":147}}Content-Length: 265

{"jsonrpc":"2.0","id":149,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":41},"context":{"isRetrigger":true,"triggerKind":3}}}Content-Length: 285

{"jsonrpc":"2.0","id":150,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":223}}}Content-Length: 38

{"jsonrpc":"2.0","id":4,"result":null}Content-Length: 285

{"jsonrpc":"2.0","id":151,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":150}}Content-Length: 285

{"jsonrpc":"2.0","id":152,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":151}}
>>>
Content-Length: 93

{"id":147,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}Content-Length: 38

{"id":148,"result":[],"jsonrpc":"2.0"}Content-Length: 93

{"id":149,"result":{"signatures":[],"activeSignature":0,"activeParameter":0},"jsonrpc":"2.0"}Content-Length: 38

{"id":150,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":151,"result":[],"jsonrpc":"2.0"}Content-Length: 38

{"id":152,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":153,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":153,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":154,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":154,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":155,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":233,"character":7}}}
>>>
Content-Length: 247

{"id":155,"result":{"contents":{"kind":"markdown","value":"### function `checkAlarms`  \n\n---\n `void`  \n\n---\n```cpp\nvoid checkAlarms()\n```"},"range":{"start":{"line":268,"character":4},"end":{"line":268,"character":15}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":156,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":244,"character":6}}}
>>>
Content-Length: 1892

{"id":156,"result":{"contents":{"kind":"markdown","value":"### function `vTaskDelay`  \n\n---\n `void`  \nParameters:  \n- `const TickType_t xTicksToDelay`\n\nDelay a task for a given number of ticks.  \nThe actual time that the task remains blocked depends on the tick rate.  \nThe constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.  \nINCLUDE_vTaskDelay must be defined as 1 for this function to be available.  \nSee the configuration section for more information.  \nvTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.  \n@param xTicksToDelay The amount of time, in tick periods, that the calling task should block.  \nExample usage:  \n@code{c} void vTaskFunction( void * pvParameters ) { // Block for 500ms.  \nconst TickType_t xDelay = 500 / portTICK_PERIOD_MS;  \nfor( ;; ) { // Simply toggle the LED every 500ms, blocking between each toggle.  \nvToggleLED();  \nvTaskDelay( xDelay );  \n} }  \n@endcode  \n\\\\ingroup TaskCtrl  \n\n---\n```cpp\nvoid vTaskDelay(const TickType_t xTicksToDelay)\n```"},"range":{"start":{"line":279,"character":4},"end":{"line":279,"character":14}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":157,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":235,"character":15}}}
>>>
Content-Length: 313

{"id":157,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":158,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":106,"character":11}}}
>>>
Content-Length: 247

{"id":158,"result":{"contents":{"kind":"markdown","value":"### function `serialPrint`  \n\n---\n `void`  \n\n---\n```cpp\nvoid serialPrint()\n```"},"range":{"start":{"line":141,"character":5},"end":{"line":141,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":159,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":104,"character":1},"end":{"line":104,"character":1}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":159,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":160,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":113,"character":5}}}
>>>
Content-Length: 257

{"id":160,"result":{"contents":{"kind":"markdown","value":"### variable `itch`  \n\n---\nType: `int`  \n\n---\n```cpp\n// In serialPrint\npublic: int itch\n```"},"range":{"start":{"line":148,"character":4},"end":{"line":148,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":161,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":113,"character":5}}}
>>>
Content-Length: 126

{"id":161,"result":[{"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":8}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":162,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":5},"end":{"line":113,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":162,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":163,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":113,"character":2}}}
>>>
Content-Length: 257

{"id":163,"result":{"contents":{"kind":"markdown","value":"### variable `itch`  \n\n---\nType: `int`  \n\n---\n```cpp\n// In serialPrint\npublic: int itch\n```"},"range":{"start":{"line":148,"character":2},"end":{"line":148,"character":3}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":164,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":113,"character":2}}}
>>>
Content-Length: 126

{"id":164,"result":[{"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":8}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 452

{"jsonrpc":"2.0","id":165,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":2}},"context":{"diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"message":"Unknown type name 'v'","severity":1,"code":"unknown_typename","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":165,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 452

{"jsonrpc":"2.0","id":166,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":3},"end":{"line":113,"character":3}},"context":{"diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"message":"Unknown type name 'v'","severity":1,"code":"unknown_typename","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":166,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":167,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":113,"character":3}}}
>>>
Content-Length: 257

{"id":167,"result":{"contents":{"kind":"markdown","value":"### variable `itch`  \n\n---\nType: `int`  \n\n---\n```cpp\n// In serialPrint\npublic: int itch\n```"},"range":{"start":{"line":148,"character":2},"end":{"line":148,"character":3}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":168,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":115,"character":0}}}
>>>
Content-Length: 40

{"id":168,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":169,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":114,"character":6}}}
>>>
Content-Length: 269

{"id":169,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":149,"character":2},"end":{"line":149,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":170,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":114,"character":12}}}
>>>
Content-Length: 312

{"id":170,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":149,"character":9},"end":{"line":149,"character":14}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":171,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":8}}}
>>>
Content-Length: 321

{"id":171,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `double`\n- `int = 2`\n\n---\n```cpp\n// In Print\npublic: size_t print(double, int = 2)\n```"},"range":{"start":{"line":147,"character":2},"end":{"line":147,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":172,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":1}}}
>>>
Content-Length: 40

{"id":172,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":173,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":4},"end":{"line":113,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":173,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":174,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":5},"end":{"line":113,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":174,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":175,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":3}}}
>>>
Content-Length: 269

{"id":175,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":147,"character":2},"end":{"line":147,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":176,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":4}}}
>>>
Content-Length: 222

{"id":176,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":177,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":3}}}
>>>
Content-Length: 269

{"id":177,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":147,"character":2},"end":{"line":147,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":178,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":4}}}
>>>
Content-Length: 222

{"id":178,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":179,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":112,"character":3}}}
>>>
Content-Length: 269

{"id":179,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":147,"character":2},"end":{"line":147,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":224},"contentChanges":[{"range":{"start":{"line":238,"character":40},"end":{"line":238,"character":41}},"rangeLength":1,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":180,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":40},"end":{"line":238,"character":40}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 748

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":180,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 416

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":226},"contentChanges":[{"range":{"start":{"line":238,"character":38},"end":{"line":238,"character":39}},"rangeLength":1,"text":")"},{"range":{"start":{"line":238,"character":37},"end":{"line":238,"character":39}},"rangeLength":2,"text":""}]}}Content-Length: 2359

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":246},"contentChanges":[{"range":{"start":{"line":238,"character":36},"end":{"line":238,"character":37}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":35},"end":{"line":238,"character":36}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":34},"end":{"line":238,"character":35}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":33},"end":{"line":238,"character":34}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":32},"end":{"line":238,"character":33}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":31},"end":{"line":238,"character":32}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":30},"end":{"line":238,"character":31}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":29},"end":{"line":238,"character":30}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":28},"end":{"line":238,"character":29}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":27},"end":{"line":238,"character":28}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":26},"end":{"line":238,"character":27}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":25},"end":{"line":238,"character":26}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":24},"end":{"line":238,"character":25}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":23},"end":{"line":238,"character":24}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":22},"end":{"line":238,"character":23}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":21},"end":{"line":238,"character":22}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":20},"end":{"line":238,"character":21}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":19},"end":{"line":238,"character":20}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":18},"end":{"line":238,"character":19}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":18}},"rangeLength":1,"text":""}]}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":247},"contentChanges":[{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":18}},"rangeLength":7,"text":"pr"}]}}Content-Length: 1267

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":257},"contentChanges":[{"range":{"start":{"line":238,"character":12},"end":{"line":238,"character":13}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":10},"end":{"line":238,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":9},"end":{"line":238,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":8},"end":{"line":238,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":7},"end":{"line":238,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":6},"end":{"line":238,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":5},"end":{"line":238,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":50},"end":{"line":238,"character":4}},"rangeLength":5,"text":""}]}}Content-Length: 631

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":261},"contentChanges":[{"range":{"start":{"line":237,"character":49},"end":{"line":237,"character":50}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":49}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":48}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":47}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":262},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":46}},"rangeLength":1,"text":""}]}}Content-Length: 636

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":266},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"rangeLength":0,"text":"L"},{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":46}},"rangeLength":0,"text":" "},{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":47}},"rangeLength":0,"text":"\""},{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":48}},"rangeLength":0,"text":")"}]}}
>>>
Content-Length: 932

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":13}},"severity":1,"code":"no_member","source":"clang","message":"No member named 'pr' in 'HardwareSerial'"},{"range":{"start":{"line":239,"character":0},"end":{"line":239,"character":1}},"severity":1,"code":"expected_semi_after_expr","source":"clang","message":"Expected ';' after expression (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":267},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":47}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":268},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":46}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":269},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":270},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":43}},"rangeLength":1,"text":""}]}}Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":272},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":42}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":43}},"rangeLength":0,"text":"s"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":273},"contentChanges":[{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":44}},"rangeLength":1,"text":""}]}}Content-Length: 739

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":278},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":43}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":41},"end":{"line":237,"character":42}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":40},"end":{"line":237,"character":41}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":40}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":39}},"rangeLength":1,"text":""}]}}Content-Length: 523

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":281},"contentChanges":[{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":39}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":37},"end":{"line":237,"character":38}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":36},"end":{"line":237,"character":37}},"rangeLength":1,"text":""}]}}Content-Length: 955

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":288},"contentChanges":[{"range":{"start":{"line":237,"character":35},"end":{"line":237,"character":36}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":34},"end":{"line":237,"character":35}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":33},"end":{"line":237,"character":34}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":32},"end":{"line":237,"character":33}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":31},"end":{"line":237,"character":32}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":30},"end":{"line":237,"character":31}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":29},"end":{"line":237,"character":30}},"rangeLength":1,"text":""}]}}Content-Length: 955

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":295},"contentChanges":[{"range":{"start":{"line":237,"character":28},"end":{"line":237,"character":29}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":27},"end":{"line":237,"character":28}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":26},"end":{"line":237,"character":27}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":25},"end":{"line":237,"character":26}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":24},"end":{"line":237,"character":25}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":23},"end":{"line":237,"character":24}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":22},"end":{"line":237,"character":23}},"rangeLength":1,"text":""}]}}Content-Length: 631

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":299},"contentChanges":[{"range":{"start":{"line":237,"character":21},"end":{"line":237,"character":22}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":20},"end":{"line":237,"character":21}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":19},"end":{"line":237,"character":20}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":301},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":19}},"rangeLength":1,"text":"\""},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":19}},"rangeLength":2,"text":""}]}}Content-Length: 416

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":303},"contentChanges":[{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":18}},"rangeLength":1,"text":")"},{"range":{"start":{"line":237,"character":16},"end":{"line":237,"character":18}},"rangeLength":2,"text":""}]}}Content-Length: 1591

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":316},"contentChanges":[{"range":{"start":{"line":237,"character":15},"end":{"line":237,"character":16}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":14},"end":{"line":237,"character":15}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":13},"end":{"line":237,"character":14}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":12},"end":{"line":237,"character":13}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":10},"end":{"line":237,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":9},"end":{"line":237,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":8},"end":{"line":237,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":7},"end":{"line":237,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":6},"end":{"line":237,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":5},"end":{"line":237,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":54},"end":{"line":237,"character":4}},"rangeLength":5,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":317},"contentChanges":[{"range":{"start":{"line":235,"character":37},"end":{"line":235,"character":38}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":318},"contentChanges":[{"range":{"start":{"line":236,"character":53},"end":{"line":236,"character":54}},"rangeLength":1,"text":""}]}}Content-Length: 649

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":322},"contentChanges":[{"range":{"start":{"line":236,"character":50},"end":{"line":236,"character":51}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":49},"end":{"line":236,"character":50}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":48},"end":{"line":236,"character":49}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":48}},"rangeLength":1,"text":"TaskHandle_t xTask"}]}}Content-Length: 318

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":323},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":66}},"rangeLength":47,"text":"uxTaskGetS"}]}}Content-Length: 1279

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":333},"contentChanges":[{"range":{"start":{"line":236,"character":28},"end":{"line":236,"character":29}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":27},"end":{"line":236,"character":28}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":26},"end":{"line":236,"character":27}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":25},"end":{"line":236,"character":26}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":24},"end":{"line":236,"character":25}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":23},"end":{"line":236,"character":24}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":22},"end":{"line":236,"character":23}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":21},"end":{"line":236,"character":22}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":21}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":20}},"rangeLength":1,"text":""}]}}Content-Length: 416

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":335},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":20}},"rangeLength":1,"text":")"},{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":20}},"rangeLength":2,"text":""}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":337},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"rangeLength":0,"text":"*"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"rangeLength":0,"text":"()"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":338},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":21}},"rangeLength":2,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":339},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 415

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":341},"contentChanges":[{"range":{"start":{"line":235,"character":34},"end":{"line":235,"character":35}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":33},"end":{"line":235,"character":34}},"rangeLength":1,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":342},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 847

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":348},"contentChanges":[{"range":{"start":{"line":235,"character":31},"end":{"line":235,"character":32}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":30},"end":{"line":235,"character":31}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":29},"end":{"line":235,"character":30}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":28},"end":{"line":235,"character":29}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":27},"end":{"line":235,"character":28}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":26},"end":{"line":235,"character":27}},"rangeLength":1,"text":""}]}}Content-Length: 1063

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":356},"contentChanges":[{"range":{"start":{"line":235,"character":25},"end":{"line":235,"character":26}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":24},"end":{"line":235,"character":25}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":23},"end":{"line":235,"character":24}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":22},"end":{"line":235,"character":23}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":21},"end":{"line":235,"character":22}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":20},"end":{"line":235,"character":21}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":19},"end":{"line":235,"character":20}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":358},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":19}},"rangeLength":1,"text":"\""},{"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":19}},"rangeLength":2,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":359},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":18}},"rangeLength":2,"text":""}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":360},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":362},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"rangeLength":0,"text":"()"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":363},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":364},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"g"}]}}Content-Length: 415

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":366},"contentChanges":[{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":11}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":367},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"rangeLength":0,"text":"P"}]}}Content-Length: 416

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":369},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":17}},"rangeLength":1,"text":")"},{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":17}},"rangeLength":2,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":370},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":":"}]}}Content-Length: 1378

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":381},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":14},"end":{"line":235,"character":15}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":13},"end":{"line":235,"character":14}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":12},"end":{"line":235,"character":13}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":9},"end":{"line":235,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":8},"end":{"line":235,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":7},"end":{"line":235,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":6},"end":{"line":235,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":382},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"rangeLength":0,"text":"r"}]}}Content-Length: 411

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":384},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":385},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":4}},"rangeLength":0,"text":"/"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":386},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":387},"contentChanges":[{"range":{"start":{"line":235,"character":2},"end":{"line":235,"character":4}},"rangeLength":2,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":388},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":2}},"rangeLength":2,"text":""}]}}Content-Length: 1700

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":402},"contentChanges":[{"range":{"start":{"line":236,"character":17},"end":{"line":236,"character":18}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":16},"end":{"line":236,"character":17}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":15},"end":{"line":236,"character":16}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":14},"end":{"line":236,"character":15}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":13},"end":{"line":236,"character":14}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":12},"end":{"line":236,"character":13}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":403},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":4}},"rangeLength":2,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":404},"contentChanges":[{"range":{"start":{"line":214,"character":2},"end":{"line":214,"character":5}},"rangeLength":3,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":405},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":0}},"rangeLength":0,"text":"}"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":406},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":0}},"rangeLength":0,"text":"  "}]}}
>>>
Content-Length: 1542

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":239,"character":29},"end":{"line":239,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":246,"character":12},"end":{"line":246,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":278,"character":11},"end":{"line":278,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":282,"character":0},"end":{"line":282,"character":0}},"severity":1,"code":"expected","source":"clang","message":"Expected '}'\n\nEsp_Master.ino.cpp:249:30: note: to match this '{'"},{"range":{"start":{"line":213,"character":29},"end":{"line":213,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:318:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 1273

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":416},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"rangeLength":0,"text":"."},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":10}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"rangeLength":0,"text":"e"}]}}Content-Length: 1052

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":424},"contentChanges":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":425},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"i"}]}}Content-Length: 517

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":428},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":429},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"A"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":430},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 841

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":436},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"s"},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"a"}]}}Content-Length: 941

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":443},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""},{"range":{"start":{"line":235,"character":3},"end":{"line":236,"character":2}},"rangeLength":3,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":444},"contentChanges":[{"range":{"start":{"line":113,"character":3},"end":{"line":113,"character":4}},"rangeLength":1,"text":""}]}}Content-Length: 427

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":445},"contentChanges":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"rangeLength":1,"text":"Serial.print(\"  Roll: \");\n  Serial.print(msgToSlave.roll);\n  Serial.print(\"  Pitch: \");\n  Serial.print(msgToSlave.p"}]}}
>>>
Content-Length: 175

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":181,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":2},"end":{"line":116,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":181,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":182,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":117,"character":27},"end":{"line":117,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":182,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":445}}}Content-Length: 285

{"jsonrpc":"2.0","id":183,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":117,"character":27},"end":{"line":117,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":183,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":184,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":125,"character":3}}}
>>>
Content-Length: 40

{"id":184,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":185,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":123,"character":9}}}
>>>
Content-Length: 251

{"id":185,"result":{"contents":{"kind":"markdown","value":"### function `serialPlotter`  \n\n---\n `void`  \n\n---\n```cpp\nvoid serialPlotter()\n```"},"range":{"start":{"line":158,"character":5},"end":{"line":158,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":186,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":15},"end":{"line":119,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":186,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":187,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":107,"character":2},"end":{"line":119,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 366

{"id":187,"result":[{"title":"Extract to function","kind":"refactor","command":{"title":"Extract to function","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractFunction","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":142,"character":2},"end":{"line":154,"character":19}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":188,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}
>>>
Content-Length: 269

{"id":188,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":142,"character":2},"end":{"line":142,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":189,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}
>>>
Content-Length: 222

{"id":189,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":190,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}
>>>
Content-Length: 269

{"id":190,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":142,"character":2},"end":{"line":142,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":191,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}
>>>
Content-Length: 269

{"id":191,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":142,"character":2},"end":{"line":142,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":446},"contentChanges":[{"range":{"start":{"line":113,"character":2},"end":{"line":116,"character":27}},"rangeLength":115,"text":"v"}]}}
>>>
Content-Length: 361

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":7}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'vitch'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 469

{"jsonrpc":"2.0","id":192,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":113,"character":3},"end":{"line":113,"character":3}},"context":{"diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":7}},"message":"Use of undeclared identifier 'vitch'","severity":1,"code":"undeclared_var_use","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":192,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":193,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}
>>>
Content-Length: 269

{"id":193,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":142,"character":2},"end":{"line":142,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":447},"contentChanges":[{"range":{"start":{"line":113,"character":3},"end":{"line":113,"character":3}},"rangeLength":0,"text":" "}]}}Content-Length: 951

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":454},"contentChanges":[{"range":{"start":{"line":235,"character":3},"end":{"line":235,"character":3}},"rangeLength":0,"text":"\n  "},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"s"},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"a"}]}}Content-Length: 835

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":460},"contentChanges":[{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":461},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"A"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":462},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}
>>>
Content-Length: 734

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":8}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'serila'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 520

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":465},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":3}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"i"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":466},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 1059

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":474},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"rangeLength":0,"text":"."},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":10}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"rangeLength":0,"text":"e"}]}}Content-Length: 1264

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":484},"contentChanges":[{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":12}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":11}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":10}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":9}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":8}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":7}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":6}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":5}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":3},"end":{"line":236,"character":4}},"rangeLength":1,"text":""},{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":3}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":485},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":2}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":486},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":1}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":487},"contentChanges":[{"range":{"start":{"line":214,"character":2},"end":{"line":214,"character":2}},"rangeLength":0,"text":"// "}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":488},"contentChanges":[{"range":{"start":{"line":236,"character":2},"end":{"line":236,"character":2}},"rangeLength":0,"text":"  "}]}}Content-Length: 1713

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":502},"contentChanges":[{"range":{"start":{"line":236,"character":4},"end":{"line":236,"character":4}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":236,"character":5},"end":{"line":236,"character":5}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":6},"end":{"line":236,"character":6}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":7},"end":{"line":236,"character":7}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":8},"end":{"line":236,"character":8}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":236,"character":9},"end":{"line":236,"character":9}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":10},"end":{"line":236,"character":10}},"rangeLength":0,"text":"."},{"range":{"start":{"line":236,"character":11},"end":{"line":236,"character":11}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":236,"character":12},"end":{"line":236,"character":12}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":236,"character":13},"end":{"line":236,"character":13}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":236,"character":14},"end":{"line":236,"character":14}},"rangeLength":0,"text":"n"},{"range":{"start":{"line":236,"character":15},"end":{"line":236,"character":15}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":236,"character":16},"end":{"line":236,"character":16}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":236,"character":17},"end":{"line":236,"character":17}},"rangeLength":0,"text":"n"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":503},"contentChanges":[{"range":{"start":{"line":235,"character":0},"end":{"line":235,"character":0}},"rangeLength":0,"text":"  "}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":504},"contentChanges":[{"range":{"start":{"line":235,"character":2},"end":{"line":235,"character":2}},"rangeLength":0,"text":"  "}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":505},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":4}},"rangeLength":0,"text":"/"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":506},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":5}},"rangeLength":1,"text":""}]}}Content-Length: 413

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":508},"contentChanges":[{"range":{"start":{"line":235,"character":4},"end":{"line":235,"character":4}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"rangeLength":0,"text":"r"}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":509},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 1388

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":520},"contentChanges":[{"range":{"start":{"line":235,"character":5},"end":{"line":235,"character":5}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":235,"character":6},"end":{"line":235,"character":6}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":235,"character":7},"end":{"line":235,"character":7}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":235,"character":8},"end":{"line":235,"character":8}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":235,"character":9},"end":{"line":235,"character":9}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"rangeLength":0,"text":"P"},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":11}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":235,"character":12},"end":{"line":235,"character":12}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":235,"character":13},"end":{"line":235,"character":13}},"rangeLength":0,"text":"n"},{"range":{"start":{"line":235,"character":14},"end":{"line":235,"character":14}},"rangeLength":0,"text":"g"},{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":":"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":521},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":523},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"()"},{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":17}},"rangeLength":1,"text":")"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":524},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":11}},"rangeLength":1,"text":""}]}}Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":526},"contentChanges":[{"range":{"start":{"line":235,"character":10},"end":{"line":235,"character":10}},"rangeLength":0,"text":"."},{"range":{"start":{"line":235,"character":11},"end":{"line":235,"character":11}},"rangeLength":0,"text":"p"}]}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":527},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":528},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"r"}]}}Content-Length: 415

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":530},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":18}},"rangeLength":2,"text":""},{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":16}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":531},"contentChanges":[{"range":{"start":{"line":235,"character":15},"end":{"line":235,"character":15}},"rangeLength":0,"text":"t"}]}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":532},"contentChanges":[{"range":{"start":{"line":235,"character":16},"end":{"line":235,"character":16}},"rangeLength":0,"text":"()"}]}}Content-Length: 421

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":534},"contentChanges":[{"range":{"start":{"line":235,"character":17},"end":{"line":235,"character":17}},"rangeLength":0,"text":"\"\""},{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":19}},"rangeLength":1,"text":"\""}]}}Content-Length: 1071

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":542},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"rangeLength":0,"text":"O"},{"range":{"start":{"line":235,"character":19},"end":{"line":235,"character":19}},"rangeLength":0,"text":"v"},{"range":{"start":{"line":235,"character":20},"end":{"line":235,"character":20}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":235,"character":21},"end":{"line":235,"character":21}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":235,"character":22},"end":{"line":235,"character":22}},"rangeLength":0,"text":"f"},{"range":{"start":{"line":235,"character":23},"end":{"line":235,"character":23}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":235,"character":24},"end":{"line":235,"character":24}},"rangeLength":0,"text":"o"},{"range":{"start":{"line":235,"character":25},"end":{"line":235,"character":25}},"rangeLength":0,"text":"w"}]}}Content-Length: 853

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":548},"contentChanges":[{"range":{"start":{"line":235,"character":26},"end":{"line":235,"character":26}},"rangeLength":0,"text":" "},{"range":{"start":{"line":235,"character":27},"end":{"line":235,"character":27}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":235,"character":28},"end":{"line":235,"character":28}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":235,"character":29},"end":{"line":235,"character":29}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":235,"character":30},"end":{"line":235,"character":30}},"rangeLength":0,"text":"c"},{"range":{"start":{"line":235,"character":31},"end":{"line":235,"character":31}},"rangeLength":0,"text":"k"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":549},"contentChanges":[{"range":{"start":{"line":235,"character":18},"end":{"line":235,"character":18}},"rangeLength":0,"text":" "}]}}Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":551},"contentChanges":[{"range":{"start":{"line":235,"character":33},"end":{"line":235,"character":33}},"rangeLength":0,"text":" "},{"range":{"start":{"line":235,"character":34},"end":{"line":235,"character":34}},"rangeLength":0,"text":":"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":552},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"rangeLength":0,"text":"*"}]}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":553},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"rangeLength":0,"text":"()"}]}}Content-Length: 415

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":555},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":21}},"rangeLength":2,"text":""},{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":19}},"rangeLength":1,"text":""}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":557},"contentChanges":[{"range":{"start":{"line":236,"character":18},"end":{"line":236,"character":18}},"rangeLength":0,"text":"()"},{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":20}},"rangeLength":1,"text":")"}]}}Content-Length: 1289

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":567},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":19}},"rangeLength":0,"text":"u"},{"range":{"start":{"line":236,"character":20},"end":{"line":236,"character":20}},"rangeLength":0,"text":"x"},{"range":{"start":{"line":236,"character":21},"end":{"line":236,"character":21}},"rangeLength":0,"text":"T"},{"range":{"start":{"line":236,"character":22},"end":{"line":236,"character":22}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":236,"character":23},"end":{"line":236,"character":23}},"rangeLength":0,"text":"s"},{"range":{"start":{"line":236,"character":24},"end":{"line":236,"character":24}},"rangeLength":0,"text":"k"},{"range":{"start":{"line":236,"character":25},"end":{"line":236,"character":25}},"rangeLength":0,"text":"G"},{"range":{"start":{"line":236,"character":26},"end":{"line":236,"character":26}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":236,"character":27},"end":{"line":236,"character":27}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":236,"character":28},"end":{"line":236,"character":28}},"rangeLength":0,"text":"S"}]}}Content-Length: 355

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":568},"contentChanges":[{"range":{"start":{"line":236,"character":19},"end":{"line":236,"character":29}},"rangeLength":10,"text":"uxTaskGetStackHighWaterMark(TaskHandle_t xTask)"}]}}Content-Length: 636

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":572},"contentChanges":[{"range":{"start":{"line":236,"character":47},"end":{"line":236,"character":65}},"rangeLength":18,"text":"N"},{"range":{"start":{"line":236,"character":48},"end":{"line":236,"character":48}},"rangeLength":0,"text":"U"},{"range":{"start":{"line":236,"character":49},"end":{"line":236,"character":49}},"rangeLength":0,"text":"L"},{"range":{"start":{"line":236,"character":50},"end":{"line":236,"character":50}},"rangeLength":0,"text":"L"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":573},"contentChanges":[{"range":{"start":{"line":236,"character":53},"end":{"line":236,"character":53}},"rangeLength":0,"text":";"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":574},"contentChanges":[{"range":{"start":{"line":235,"character":37},"end":{"line":235,"character":37}},"rangeLength":0,"text":";"}]}}Content-Length: 1609

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":587},"contentChanges":[{"range":{"start":{"line":236,"character":54},"end":{"line":236,"character":54}},"rangeLength":0,"text":"\n    "},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":4}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":237,"character":5},"end":{"line":237,"character":5}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":237,"character":6},"end":{"line":237,"character":6}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":237,"character":7},"end":{"line":237,"character":7}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":237,"character":8},"end":{"line":237,"character":8}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":237,"character":9},"end":{"line":237,"character":9}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":237,"character":10},"end":{"line":237,"character":10}},"rangeLength":0,"text":"."},{"range":{"start":{"line":237,"character":11},"end":{"line":237,"character":11}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":237,"character":12},"end":{"line":237,"character":12}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":237,"character":13},"end":{"line":237,"character":13}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":237,"character":14},"end":{"line":237,"character":14}},"rangeLength":0,"text":"n"},{"range":{"start":{"line":237,"character":15},"end":{"line":237,"character":15}},"rangeLength":0,"text":"t"}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":589},"contentChanges":[{"range":{"start":{"line":237,"character":16},"end":{"line":237,"character":16}},"rangeLength":0,"text":"()"},{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":18}},"rangeLength":1,"text":")"}]}}Content-Length: 421

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":591},"contentChanges":[{"range":{"start":{"line":237,"character":17},"end":{"line":237,"character":17}},"rangeLength":0,"text":"\"\""},{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":19}},"rangeLength":1,"text":"\""}]}}Content-Length: 635

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":595},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"rangeLength":0,"text":"H"},{"range":{"start":{"line":237,"character":19},"end":{"line":237,"character":19}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":237,"character":20},"end":{"line":237,"character":20}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":237,"character":21},"end":{"line":237,"character":21}},"rangeLength":0,"text":"p"}]}}Content-Length: 962

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":602},"contentChanges":[{"range":{"start":{"line":237,"character":22},"end":{"line":237,"character":22}},"rangeLength":0,"text":" "},{"range":{"start":{"line":237,"character":23},"end":{"line":237,"character":23}},"rangeLength":0,"text":"b"},{"range":{"start":{"line":237,"character":24},"end":{"line":237,"character":24}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":237,"character":25},"end":{"line":237,"character":25}},"rangeLength":0,"text":"f"},{"range":{"start":{"line":237,"character":26},"end":{"line":237,"character":26}},"rangeLength":0,"text":"o"},{"range":{"start":{"line":237,"character":27},"end":{"line":237,"character":27}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":237,"character":28},"end":{"line":237,"character":28}},"rangeLength":0,"text":"e"}]}}Content-Length: 962

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":609},"contentChanges":[{"range":{"start":{"line":237,"character":29},"end":{"line":237,"character":29}},"rangeLength":0,"text":" "},{"range":{"start":{"line":237,"character":30},"end":{"line":237,"character":30}},"rangeLength":0,"text":"m"},{"range":{"start":{"line":237,"character":31},"end":{"line":237,"character":31}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":237,"character":32},"end":{"line":237,"character":32}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":237,"character":33},"end":{"line":237,"character":33}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":237,"character":34},"end":{"line":237,"character":34}},"rangeLength":0,"text":"o"},{"range":{"start":{"line":237,"character":35},"end":{"line":237,"character":35}},"rangeLength":0,"text":"c"}]}}Content-Length: 526

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":612},"contentChanges":[{"range":{"start":{"line":237,"character":36},"end":{"line":237,"character":36}},"rangeLength":0,"text":" "},{"range":{"start":{"line":237,"character":37},"end":{"line":237,"character":37}},"rangeLength":0,"text":"("},{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":38}},"rangeLength":0,"text":")"}]}}Content-Length: 744

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":617},"contentChanges":[{"range":{"start":{"line":237,"character":38},"end":{"line":237,"character":38}},"rangeLength":0,"text":"B"},{"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":39}},"rangeLength":0,"text":"y"},{"range":{"start":{"line":237,"character":40},"end":{"line":237,"character":40}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":237,"character":41},"end":{"line":237,"character":41}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":42}},"rangeLength":0,"text":"r"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":618},"contentChanges":[{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":43}},"rangeLength":0,"text":"s"}]}}Content-Length: 415

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":620},"contentChanges":[{"range":{"start":{"line":237,"character":43},"end":{"line":237,"character":44}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":43}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":621},"contentChanges":[{"range":{"start":{"line":237,"character":42},"end":{"line":237,"character":42}},"rangeLength":0,"text":"s"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":622},"contentChanges":[{"range":{"start":{"line":237,"character":18},"end":{"line":237,"character":18}},"rangeLength":0,"text":" "}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":623},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"rangeLength":0,"text":"L"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":624},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":46}},"rangeLength":0,"text":" "}]}}Content-Length: 631

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":628},"contentChanges":[{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":49}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":48}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":47}},"rangeLength":1,"text":""},{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":46}},"rangeLength":1,"text":""}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":629},"contentChanges":[{"range":{"start":{"line":237,"character":45},"end":{"line":237,"character":45}},"rangeLength":0,"text":":"}]}}Content-Length: 636

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":633},"contentChanges":[{"range":{"start":{"line":237,"character":46},"end":{"line":237,"character":46}},"rangeLength":0,"text":" "},{"range":{"start":{"line":237,"character":47},"end":{"line":237,"character":47}},"rangeLength":0,"text":"\""},{"range":{"start":{"line":237,"character":48},"end":{"line":237,"character":48}},"rangeLength":0,"text":")"},{"range":{"start":{"line":237,"character":49},"end":{"line":237,"character":49}},"rangeLength":0,"text":";"}]}}Content-Length: 1282

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":643},"contentChanges":[{"range":{"start":{"line":237,"character":50},"end":{"line":237,"character":50}},"rangeLength":0,"text":"\n    "},{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":4}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":238,"character":5},"end":{"line":238,"character":5}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":238,"character":6},"end":{"line":238,"character":6}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":238,"character":7},"end":{"line":238,"character":7}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":238,"character":8},"end":{"line":238,"character":8}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":238,"character":9},"end":{"line":238,"character":9}},"rangeLength":0,"text":"l"},{"range":{"start":{"line":238,"character":10},"end":{"line":238,"character":10}},"rangeLength":0,"text":"."},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":11}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":238,"character":12},"end":{"line":238,"character":12}},"rangeLength":0,"text":"r"}]}}Content-Length: 314

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":644},"contentChanges":[{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":13}},"rangeLength":2,"text":"print()"}]}}Content-Length: 2379

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":664},"contentChanges":[{"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":17}},"rangeLength":0,"text":"x"},{"range":{"start":{"line":238,"character":18},"end":{"line":238,"character":18}},"rangeLength":0,"text":"P"},{"range":{"start":{"line":238,"character":19},"end":{"line":238,"character":19}},"rangeLength":0,"text":"o"},{"range":{"start":{"line":238,"character":20},"end":{"line":238,"character":20}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":238,"character":21},"end":{"line":238,"character":21}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":238,"character":22},"end":{"line":238,"character":22}},"rangeLength":0,"text":"G"},{"range":{"start":{"line":238,"character":23},"end":{"line":238,"character":23}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":238,"character":24},"end":{"line":238,"character":24}},"rangeLength":0,"text":"t"},{"range":{"start":{"line":238,"character":25},"end":{"line":238,"character":25}},"rangeLength":0,"text":"F"},{"range":{"start":{"line":238,"character":26},"end":{"line":238,"character":26}},"rangeLength":0,"text":"r"},{"range":{"start":{"line":238,"character":27},"end":{"line":238,"character":27}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":238,"character":28},"end":{"line":238,"character":28}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":238,"character":29},"end":{"line":238,"character":29}},"rangeLength":0,"text":"H"},{"range":{"start":{"line":238,"character":30},"end":{"line":238,"character":30}},"rangeLength":0,"text":"e"},{"range":{"start":{"line":238,"character":31},"end":{"line":238,"character":31}},"rangeLength":0,"text":"a"},{"range":{"start":{"line":238,"character":32},"end":{"line":238,"character":32}},"rangeLength":0,"text":"p"},{"range":{"start":{"line":238,"character":33},"end":{"line":238,"character":33}},"rangeLength":0,"text":"S"},{"range":{"start":{"line":238,"character":34},"end":{"line":238,"character":34}},"rangeLength":0,"text":"i"},{"range":{"start":{"line":238,"character":35},"end":{"line":238,"character":35}},"rangeLength":0,"text":"z"},{"range":{"start":{"line":238,"character":36},"end":{"line":238,"character":36}},"rangeLength":0,"text":"e"}]}}Content-Length: 418

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":666},"contentChanges":[{"range":{"start":{"line":238,"character":37},"end":{"line":238,"character":37}},"rangeLength":0,"text":"()"},{"range":{"start":{"line":238,"character":38},"end":{"line":238,"character":39}},"rangeLength":1,"text":")"}]}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":667},"contentChanges":[{"range":{"start":{"line":238,"character":40},"end":{"line":238,"character":40}},"rangeLength":0,"text":";"}]}}
>>>
Content-Length: 546

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"severity":1,"code":"unknown_typename","source":"clang","message":"Unknown type name 'v'"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"severity":1,"code":"extraneous_token_before_semi","source":"clang","message":"Extraneous ')' before ';' (fix available)"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":194,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":194,"result":[],"jsonrpc":"2.0"}Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":5,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":5,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":667}}}
>>>
Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":195,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":41},"end":{"line":238,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 655

{"jsonrpc":"2.0","id":196,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":107,"character":1},"end":{"line":116,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"message":"Unknown type name 'v'","severity":1,"code":"unknown_typename","source":"clang"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"message":"Extraneous ')' before ';' (fix available)","severity":1,"code":"extraneous_token_before_semi","source":"clang"}]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":195}}Content-Length: 655

{"jsonrpc":"2.0","id":197,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":107,"character":2},"end":{"line":116,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":3}},"message":"Unknown type name 'v'","severity":1,"code":"unknown_typename","source":"clang"},{"range":{"start":{"line":113,"character":8},"end":{"line":113,"character":9}},"message":"Extraneous ')' before ';' (fix available)","severity":1,"code":"extraneous_token_before_semi","source":"clang"}]}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":196}}Content-Length: 209

{"jsonrpc":"2.0","id":198,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}Content-Length: 214

{"jsonrpc":"2.0","id":199,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":107,"character":2}}}Content-Length: 681

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":668},"contentChanges":[{"range":{"start":{"line":107,"character":2},"end":{"line":116,"character":19}},"rangeLength":236,"text":"Serial.print(\"X: \");\n  Serial.print(accX);\n  Serial.print(\"  Y: \");\n  Serial.print(accY);\n  Serial.print(\"  Z: \");\n  Serial.print(accZ);\n  Serial.print(\"  Roll: \");\n  Serial.print(msgToSlave.roll);\n  Serial.print(\"  Pitch: \");\n  Serial.print(msgToSlave.pitch);\n  Serial.print(\"  Light: \");\n  Serial.print(msgToSlave.lightSensor);\n  Serial.println();"}]}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":197}}Content-Length: 285

{"jsonrpc":"2.0","id":200,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":119,"character":19},"end":{"line":119,"character":19}},"context":{"diagnostics":[]}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":668}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":668}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":198}}
>>>
Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":6,"jsonrpc":"2.0"}Content-Length: 38

{"id":195,"result":[],"jsonrpc":"2.0"}Content-Length: 190

{"id":196,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}Content-Length: 190

{"id":197,"error":{"code":0,"message":"json: cannot unmarshal object into Go struct field WorkspaceEdit.edit.changes of type map[lsp.DocumentURI][]lsp.TextEdit","data":null},"jsonrpc":"2.0"}Content-Length: 269

{"id":198,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":142,"character":2},"end":{"line":142,"character":8}}},"jsonrpc":"2.0"}Content-Length: 222

{"id":199,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}Content-Length: 38

{"id":200,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":6,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 175

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":201,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":119,"character":19},"end":{"line":119,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":201,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":202,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":20}}}
>>>
Content-Length: 40

{"id":202,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":203,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":21}}}
>>>
Content-Length: 38

{"id":203,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":204,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":21},"end":{"line":240,"character":21}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":204,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":205,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":241,"character":21}}}
>>>
Content-Length: 128

{"id":205,"result":[{"range":{"start":{"line":241,"character":17},"end":{"line":241,"character":37}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":206,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":21},"end":{"line":241,"character":21}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 395

{"id":206,"result":[{"title":"Expand macro 'xPortGetFreeHeapSize'","kind":"refactor","command":{"title":"Expand macro 'xPortGetFreeHeapSize'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":276,"character":21},"end":{"line":276,"character":21}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":669},"contentChanges":[{"range":{"start":{"line":241,"character":4},"end":{"line":241,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":207,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":24},"end":{"line":241,"character":24}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":207,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":208,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":24}}}
>>>
Content-Length: 38

{"id":208,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":669}}}Content-Length: 285

{"jsonrpc":"2.0","id":209,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":24},"end":{"line":240,"character":24}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":209,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":670},"contentChanges":[{"range":{"start":{"line":240,"character":4},"end":{"line":240,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":210,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":27},"end":{"line":240,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":210,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":670}}}Content-Length: 210

{"jsonrpc":"2.0","id":211,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":15}}}
>>>
Content-Length: 313

{"id":211,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":273,"character":11},"end":{"line":273,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":212,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":15}}}
>>>
Content-Length: 849

{"id":212,"result":[{"range":{"start":{"line":107,"character":9},"end":{"line":107,"character":14}},"kind":1},{"range":{"start":{"line":109,"character":9},"end":{"line":109,"character":14}},"kind":1},{"range":{"start":{"line":111,"character":9},"end":{"line":111,"character":14}},"kind":1},{"range":{"start":{"line":113,"character":9},"end":{"line":113,"character":14}},"kind":1},{"range":{"start":{"line":115,"character":9},"end":{"line":115,"character":14}},"kind":1},{"range":{"start":{"line":117,"character":9},"end":{"line":117,"character":14}},"kind":1},{"range":{"start":{"line":128,"character":9},"end":{"line":128,"character":14}},"kind":1},{"range":{"start":{"line":218,"character":11},"end":{"line":218,"character":16}},"kind":1},{"range":{"start":{"line":238,"character":11},"end":{"line":238,"character":16}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":213,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":15}}}
>>>
Content-Length: 128

{"id":213,"result":[{"range":{"start":{"line":239,"character":11},"end":{"line":239,"character":18}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":214,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":15},"end":{"line":239,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":214,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":215,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":15}}}
>>>
Content-Length: 213

{"id":215,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","range":{"start":{"line":86,"character":14},"end":{"line":86,"character":19}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 8355

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","languageId":"cpp","version":1,"text":"/*\n Print.cpp - Base class that provides print() and println()\n Copyright (c) 2008 David A. Mellis.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 23 November 2006 by David A. Mellis\n Modified December 2014 by Ivan Grokhotkov\n Modified May 2015 by Michael C. Miller - ESP31B progmem support\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"Arduino.h\"\n\n#include \"Print.h\"\nextern \"C\" {\n    #include \"time.h\"\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\n/* default implementation: may be overridden */\nsize_t Print::write(const uint8_t *buffer, size_t size)\n{\n    size_t n = 0;\n    while(size--) {\n        n += write(*buffer++);\n    }\n    return n;\n}\n\nsize_t Print::printf(const char *format, ...)\n{\n    char loc_buf[64];\n    char * temp = loc_buf;\n    va_list arg;\n    va_list copy;\n    va_start(arg, format);\n    va_copy(copy, arg);\n    int len = vsnprintf(temp, sizeof(loc_buf), format, copy);\n    va_end(copy);\n    if(len < 0) {\n        va_end(arg);\n        return 0;\n    };\n    if(len >= sizeof(loc_buf)){\n        temp = (char*) malloc(len+1);\n        if(temp == NULL) {\n            va_end(arg);\n            return 0;\n        }\n        len = vsnprintf(temp, len+1, format, arg);\n    }\n    va_end(arg);\n    len = write((uint8_t*)temp, len);\n    if(temp != loc_buf){\n        free(temp);\n    }\n    return len;\n}\n\nsize_t Print::print(const __FlashStringHelper *ifsh)\n{\n    return print(reinterpret_cast<const char *>(ifsh));\n}\n\nsize_t Print::print(const String &s)\n{\n    return write(s.c_str(), s.length());\n}\n\nsize_t Print::print(const char str[])\n{\n    return write(str);\n}\n\nsize_t Print::print(char c)\n{\n    return write(c);\n}\n\nsize_t Print::print(unsigned char b, int base)\n{\n    return print((unsigned long) b, base);\n}\n\nsize_t Print::print(int n, int base)\n{\n    return print((long) n, base);\n}\n\nsize_t Print::print(unsigned int n, int base)\n{\n    return print((unsigned long) n, base);\n}\n\nsize_t Print::print(long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long n, int base)\n{\n    if(base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(long long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long long n, int base)\n{\n    if (base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(double n, int digits)\n{\n    return printFloat(n, digits);\n}\n\nsize_t Print::println(const __FlashStringHelper *ifsh)\n{\n    size_t n = print(ifsh);\n    n += println();\n    return n;\n}\n\nsize_t Print::print(const Printable& x)\n{\n    return x.printTo(*this);\n}\n\nsize_t Print::print(struct tm * timeinfo, const char * format)\n{\n    const char * f = format;\n    if(!f){\n        f = \"%c\";\n    }\n    char buf[64];\n    size_t written = strftime(buf, 64, f, timeinfo);\n    if(written == 0){\n        return written;\n    }\n    return print(buf);\n}\n\nsize_t Print::println(void)\n{\n    return print(\"\\r\\n\");\n}\n\nsize_t Print::println(const String &s)\n{\n    size_t n = print(s);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const char c[])\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(char c)\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned char b, int base)\n{\n    size_t n = print(b, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(double num, int digits)\n{\n    size_t n = print(num, digits);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const Printable& x)\n{\n    size_t n = print(x);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(struct tm * timeinfo, const char * format)\n{\n    size_t n = print(timeinfo, format);\n    n += println();\n    return n;\n}\n\n// Private Methods /////////////////////////////////////////////////////////////\n\nsize_t Print::printNumber(unsigned long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char *str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if(base < 2) {\n        base = 10;\n    }\n\n    do {\n        char c = n % base;\n        n /= base;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printNumber(unsigned long long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char* str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if (base < 2) {\n        base = 10;\n    }\n\n    do {\n        auto m = n;\n        n /= base;\n        char c = m - base * n;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printFloat(double number, uint8_t digits)\n{\n    size_t n = 0;\n\n    if(isnan(number)) {\n        return print(\"nan\");\n    }\n    if(isinf(number)) {\n        return print(\"inf\");\n    }\n    if(number > 4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n    if(number < -4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n\n    // Handle negative numbers\n    if(number < 0.0) {\n        n += print('-');\n        number = -number;\n    }\n\n    // Round correctly so that print(1.999, 2) prints as \"2.00\"\n    double rounding = 0.5;\n    for(uint8_t i = 0; i < digits; ++i) {\n        rounding /= 10.0;\n    }\n\n    number += rounding;\n\n    // Extract the integer part of the number and print it\n    unsigned long int_part = (unsigned long) number;\n    double remainder = number - (double) int_part;\n    n += print(int_part);\n\n    // Print the decimal point, but only if there are digits beyond\n    if(digits > 0) {\n        n += print(\".\");\n    }\n\n    // Extract digits from the remainder one at a time\n    while(digits-- > 0) {\n        remainder *= 10.0;\n        int toPrint = int(remainder);\n        n += print(toPrint);\n        remainder -= toPrint;\n    }\n\n    return n;\n}\n"}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":671},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 174

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp"}}}
>>>
Content-Length: 184

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":216,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":18},"end":{"line":238,"character":18}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":216,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":672},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":217,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":21},"end":{"line":238,"character":21}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":217,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":672}}}Content-Length: 210

{"jsonrpc":"2.0","id":218,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":27}}}
>>>
Content-Length: 40

{"id":218,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":219,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":17}}}
>>>
Content-Length: 40

{"id":219,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":220,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":5}}}
>>>
Content-Length: 40

{"id":220,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":221,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":6}}}
>>>
Content-Length: 38

{"id":221,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":222,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":274,"character":6},"end":{"line":274,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":222,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":223,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":5}}}
>>>
Content-Length: 216

{"id":223,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":303,"character":4},"end":{"line":303,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":224,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":266,"character":5}}}
>>>
Content-Length: 216

{"id":224,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":301,"character":4},"end":{"line":301,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":225,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":5}}}
>>>
Content-Length: 40

{"id":225,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":226,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":5}}}
>>>
Content-Length: 38

{"id":226,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":227,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":227,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":228,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":267,"character":7}}}
>>>
Content-Length: 40

{"id":228,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":673},"contentChanges":[{"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"rangeLength":4,"text":"3"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":229,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":229,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":674},"contentChanges":[{"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":675},"contentChanges":[{"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":676},"contentChanges":[{"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":230,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":230,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":676}}}Content-Length: 210

{"jsonrpc":"2.0","id":231,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":267,"character":12}}}
>>>
Content-Length: 40

{"id":231,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":232,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":17}}}
>>>
Content-Length: 40

{"id":232,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":233,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":17}}}
>>>
Content-Length: 38

{"id":233,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":234,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":17},"end":{"line":238,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":234,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":235,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":17}}}
>>>
Content-Length: 38

{"id":235,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":677},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":236,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":14},"end":{"line":238,"character":14}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":236,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":237,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":14}}}
>>>
Content-Length: 38

{"id":237,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":678},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":238,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":11},"end":{"line":239,"character":11}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":238,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":679},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":239,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":14},"end":{"line":239,"character":14}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":239,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":679}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":680},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 222

{"jsonrpc":"2.0","id":240,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":11}}}
>>>
Content-Length: 38

{"id":240,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":241,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":11},"end":{"line":240,"character":11}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":241,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":680}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":681},"contentChanges":[{"range":{"start":{"line":240,"character":4},"end":{"line":240,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":242,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":8},"end":{"line":240,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":242,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":243,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":241,"character":8}}}
>>>
Content-Length: 38

{"id":243,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":681}}}Content-Length: 283

{"jsonrpc":"2.0","id":244,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":8},"end":{"line":241,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":244,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":682},"contentChanges":[{"range":{"start":{"line":241,"character":4},"end":{"line":241,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":245,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":5},"end":{"line":241,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":245,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":682}}}
>>>
Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":7,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":7,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":8,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":8,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":246,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":13}}}
>>>
Content-Length: 1892

{"id":246,"result":{"contents":{"kind":"markdown","value":"### function `vTaskDelay`  \n\n---\n `void`  \nParameters:  \n- `const TickType_t xTicksToDelay`\n\nDelay a task for a given number of ticks.  \nThe actual time that the task remains blocked depends on the tick rate.  \nThe constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.  \nINCLUDE_vTaskDelay must be defined as 1 for this function to be available.  \nSee the configuration section for more information.  \nvTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.  \n@param xTicksToDelay The amount of time, in tick periods, that the calling task should block.  \nExample usage:  \n@code{c} void vTaskFunction( void * pvParameters ) { // Block for 500ms.  \nconst TickType_t xDelay = 500 / portTICK_PERIOD_MS;  \nfor( ;; ) { // Simply toggle the LED every 500ms, blocking between each toggle.  \nvToggleLED();  \nvTaskDelay( xDelay );  \n} }  \n@endcode  \n\\\\ingroup TaskCtrl  \n\n---\n```cpp\nvoid vTaskDelay(const TickType_t xTicksToDelay)\n```"},"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":14}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":247,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":36}}}
>>>
Content-Length: 38

{"id":247,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":248,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":36}}}
>>>
Content-Length: 40

{"id":248,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":249,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":36}}}
>>>
Content-Length: 38

{"id":249,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":250,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":36},"end":{"line":240,"character":36}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":250,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":683},"contentChanges":[{"range":{"start":{"line":240,"character":4},"end":{"line":240,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":251,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":39},"end":{"line":240,"character":39}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":251,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":683}}}Content-Length: 285

{"jsonrpc":"2.0","id":252,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":39},"end":{"line":241,"character":39}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":252,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":684},"contentChanges":[{"range":{"start":{"line":241,"character":4},"end":{"line":241,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":253,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":42},"end":{"line":241,"character":42}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":253,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":684}}}Content-Length: 209

{"jsonrpc":"2.0","id":254,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":229,"character":2}}}
>>>
Content-Length: 40

{"id":254,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":255,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":30}}}
>>>
Content-Length: 38

{"id":255,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":256,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":30},"end":{"line":238,"character":30}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":256,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":257,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":33}}}
>>>
Content-Length: 1078

{"id":257,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":274,"character":19},"end":{"line":274,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":258,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":33}}}
>>>
Content-Length: 128

{"id":258,"result":[{"range":{"start":{"line":239,"character":19},"end":{"line":239,"character":46}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":259,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":33}}}
>>>
Content-Length: 1078

{"id":259,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":274,"character":19},"end":{"line":274,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":260,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":33},"end":{"line":239,"character":33}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":260,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":261,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":244,"character":14}}}
>>>
Content-Length: 40

{"id":261,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":262,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":273,"character":9}}}
>>>
Content-Length: 40

{"id":262,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":263,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":11}}}
>>>
Content-Length: 40

{"id":263,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":264,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":7}}}
>>>
Content-Length: 40

{"id":264,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":265,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":7}}}
>>>
Content-Length: 38

{"id":265,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":266,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":266,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":267,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":8}}}
>>>
Content-Length: 216

{"id":267,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":303,"character":4},"end":{"line":303,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":268,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":268,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":269,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":8}}}
>>>
Content-Length: 216

{"id":269,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":303,"character":4},"end":{"line":303,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":270,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":270,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":685},"contentChanges":[{"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"rangeLength":4,"text":"4"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":271,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":271,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":686},"contentChanges":[{"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"rangeLength":0,"text":"9"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":687},"contentChanges":[{"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":688},"contentChanges":[{"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":272,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":272,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":688}}}Content-Length: 221

{"jsonrpc":"2.0","id":273,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":266,"character":8}}}
>>>
Content-Length: 217

{"id":273,"result":[{"range":{"start":{"line":262,"character":2},"end":{"line":262,"character":13}},"kind":1},{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":13}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":274,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":266,"character":8},"end":{"line":266,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 361

{"id":274,"result":[{"title":"Expand macro 'NULL'","kind":"refactor","command":{"title":"Expand macro 'NULL'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":301,"character":8},"end":{"line":301,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":275,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":13}}}
>>>
Content-Length: 40

{"id":275,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":276,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":7}}}
>>>
Content-Length: 38

{"id":276,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":277,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":6}}}
>>>
Content-Length: 40

{"id":277,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":278,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":274,"character":9},"end":{"line":274,"character":9}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":278,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":279,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":8}}}
>>>
Content-Length: 217

{"id":279,"result":[{"range":{"start":{"line":262,"character":2},"end":{"line":262,"character":13}},"kind":1},{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":13}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":689},"contentChanges":[{"range":{"start":{"line":274,"character":7},"end":{"line":274,"character":8}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":690},"contentChanges":[{"range":{"start":{"line":274,"character":6},"end":{"line":274,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":691},"contentChanges":[{"range":{"start":{"line":274,"character":6},"end":{"line":274,"character":6}},"rangeLength":0,"text":"2"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":280,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":274,"character":7},"end":{"line":274,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":280,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":692},"contentChanges":[{"range":{"start":{"line":274,"character":7},"end":{"line":274,"character":7}},"rangeLength":0,"text":"4"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":281,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":274,"character":8},"end":{"line":274,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":281,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":692}}}Content-Length: 210

{"jsonrpc":"2.0","id":282,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":23}}}
>>>
Content-Length: 40

{"id":282,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":283,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":23}}}
>>>
Content-Length: 40

{"id":283,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":284,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":275,"character":6}}}
>>>
Content-Length: 216

{"id":284,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":310,"character":4},"end":{"line":310,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":285,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":10}}}
>>>
Content-Length: 40

{"id":285,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":286,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":15}}}
>>>
Content-Length: 40

{"id":286,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":287,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":273,"character":12}}}
>>>
Content-Length: 672

{"id":287,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":308,"character":11},"end":{"line":308,"character":12}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":288,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":9}}}
>>>
Content-Length: 670

{"id":288,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":300,"character":8},"end":{"line":300,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":289,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":8}}}
>>>
Content-Length: 217

{"id":289,"result":[{"range":{"start":{"line":262,"character":2},"end":{"line":262,"character":13}},"kind":1},{"range":{"start":{"line":271,"character":2},"end":{"line":271,"character":13}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":290,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":290,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":291,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":273,"character":3}}}
>>>
Content-Length: 40

{"id":291,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":292,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":292,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":693},"contentChanges":[{"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"rangeLength":4,"text":"8"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":694},"contentChanges":[{"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":695},"contentChanges":[{"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":696},"contentChanges":[{"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":293,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":293,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":696}}}Content-Length: 209

{"jsonrpc":"2.0","id":294,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":8}}}
>>>
Content-Length: 216

{"id":294,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":303,"character":4},"end":{"line":303,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":295,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":6}}}
>>>
Content-Length: 38

{"id":295,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":296,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":296,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":297,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":272,"character":9}}}
>>>
Content-Length: 670

{"id":297,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":307,"character":4},"end":{"line":307,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":697},"contentChanges":[{"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"rangeLength":4,"text":"1"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":698},"contentChanges":[{"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"rangeLength":0,"text":"1"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":298,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":298,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":698}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":699},"contentChanges":[{"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"rangeLength":0,"text":"1"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":700},"contentChanges":[{"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"rangeLength":0,"text":"6"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":299,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":299,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":700}}}Content-Length: 209

{"jsonrpc":"2.0","id":300,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":264,"character":2}}}
>>>
Content-Length: 40

{"id":300,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":301,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":241,"character":36}}}
>>>
Content-Length: 40

{"id":301,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":302,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":50}}}
>>>
Content-Length: 40

{"id":302,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":303,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":254,"character":10}}}
>>>
Content-Length: 303

{"id":303,"result":[{"range":{"start":{"line":99,"character":5},"end":{"line":99,"character":18}},"kind":1},{"range":{"start":{"line":99,"character":5},"end":{"line":99,"character":18}},"kind":1},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":15}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":304,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":254,"character":10},"end":{"line":254,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":304,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":305,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":16}}}
>>>
Content-Length: 128

{"id":305,"result":[{"range":{"start":{"line":239,"character":11},"end":{"line":239,"character":18}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":306,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":16},"end":{"line":239,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":306,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":307,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":15}}}
>>>
Content-Length: 341

{"id":307,"result":{"contents":{"kind":"markdown","value":"### instance-method `println`  \n\n---\n `size_t`  \nParameters:  \n- `unsigned int`\n- `int = 10`\n\n---\n```cpp\n// In Print\npublic: size_t println(unsigned int, int = 10)\n```"},"range":{"start":{"line":274,"character":11},"end":{"line":274,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":308,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":16}}}
>>>
Content-Length: 215

{"id":308,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","range":{"start":{"line":220,"character":14},"end":{"line":220,"character":21}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":701},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 222

{"jsonrpc":"2.0","id":309,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":19}}}
>>>
Content-Length: 38

{"id":309,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":702},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":310,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":22},"end":{"line":238,"character":22}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":310,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":702}}}Content-Length: 210

{"jsonrpc":"2.0","id":311,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":13}}}
>>>
Content-Length: 247

{"id":311,"result":{"contents":{"kind":"markdown","value":"### function `checkAlarms`  \n\n---\n `void`  \n\n---\n```cpp\nvoid checkAlarms()\n```"},"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":15}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":312,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":244,"character":16},"end":{"line":244,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":312,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":313,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":266,"character":4}}}
>>>
Content-Length: 216

{"id":313,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":301,"character":4},"end":{"line":301,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":313}}Content-Length: 221

{"jsonrpc":"2.0","id":314,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":5}}}
>>>
Content-Length: 38

{"id":314,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":315,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":315,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":316,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":5}}}
>>>
Content-Length: 670

{"id":316,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":311,"character":5},"end":{"line":311,"character":6}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":317,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":264,"character":4}}}
>>>
Content-Length: 40

{"id":317,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":318,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":318,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":319,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":264,"character":5}}}
>>>
Content-Length: 38

{"id":319,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":320,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":320,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":703},"contentChanges":[{"range":{"start":{"line":265,"character":4},"end":{"line":265,"character":8}},"rangeLength":4,"text":"4"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":704},"contentChanges":[{"range":{"start":{"line":265,"character":5},"end":{"line":265,"character":5}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":705},"contentChanges":[{"range":{"start":{"line":265,"character":6},"end":{"line":265,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":321,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":321,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":706},"contentChanges":[{"range":{"start":{"line":265,"character":7},"end":{"line":265,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":322,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":265,"character":8},"end":{"line":265,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":322,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":706}}}Content-Length: 209

{"jsonrpc":"2.0","id":323,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":265,"character":1}}}
>>>
Content-Length: 40

{"id":323,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":324,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":64,"character":39},"end":{"line":64,"character":39}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":324,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":325,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":216,"character":5},"end":{"line":216,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":325,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":326,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":221,"character":21},"end":{"line":221,"character":21}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":326,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":327,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":217,"character":13},"end":{"line":217,"character":13}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":327,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":328,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":222,"character":10}}}
>>>
Content-Length: 253

{"id":328,"result":{"contents":{"kind":"markdown","value":"### function `doCalculations`  \n\n---\n `void`  \n\n---\n```cpp\nvoid doCalculations()\n```"},"range":{"start":{"line":257,"character":4},"end":{"line":257,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":329,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":27},"end":{"line":218,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":329,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":330,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":217,"character":13},"end":{"line":217,"character":13}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":330,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":707},"contentChanges":[{"range":{"start":{"line":217,"character":2},"end":{"line":217,"character":5}},"rangeLength":3,"text":""}]}}
>>>
Content-Length: 1170

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":244,"character":29},"end":{"line":244,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":251,"character":12},"end":{"line":251,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":283,"character":11},"end":{"line":283,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":287,"character":0},"end":{"line":287,"character":0}},"severity":1,"code":"expected","source":"clang","message":"Expected '}'\n\nEsp_Master.ino.cpp:252:30: note: to match this '{'"},{"range":{"start":{"line":216,"character":29},"end":{"line":216,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:323:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":331,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":217,"character":10},"end":{"line":217,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":331,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":332,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":217,"character":10},"end":{"line":217,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":332,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":707}}}Content-Length: 210

{"jsonrpc":"2.0","id":333,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":17}}}
>>>
Content-Length: 248

{"id":333,"result":{"contents":{"kind":"markdown","value":"### function `checkAlarms`  \n\n---\n `void`  \n\n---\n```cpp\nvoid checkAlarms()\n```"},"range":{"start":{"line":271,"character":17},"end":{"line":271,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":334,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":37}}}
>>>
Content-Length: 40

{"id":334,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":335,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":39}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":335,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 313

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":708},"contentChanges":[{"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":39}},"rangeLength":0,"text":"\n    "}]}}
>>>
Content-Length: 963

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":245,"character":29},"end":{"line":245,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":252,"character":12},"end":{"line":252,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":284,"character":11},"end":{"line":284,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":216,"character":29},"end":{"line":216,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:324:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":708}}}Content-Length: 311

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":709},"contentChanges":[{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":4}},"rangeLength":4,"text":"      "}]}}
>>>
Content-Length: 963

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":245,"character":29},"end":{"line":245,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":252,"character":12},"end":{"line":252,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":284,"character":11},"end":{"line":284,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":216,"character":29},"end":{"line":216,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:324:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":709}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":710},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":6}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 963

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":245,"character":29},"end":{"line":245,"character":30}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":252,"character":12},"end":{"line":252,"character":13}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":284,"character":11},"end":{"line":284,"character":12}},"severity":1,"code":"function_definition_not_allowed","source":"clang","message":"Function definition is not allowed here"},{"range":{"start":{"line":216,"character":29},"end":{"line":216,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:324:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":711},"contentChanges":[{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":4}},"rangeLength":4,"text":"  }"}]}}
>>>
Content-Length: 175

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":336,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":3},"end":{"line":238,"character":3}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":336,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":711}}}Content-Length: 210

{"jsonrpc":"2.0","id":337,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":37}}}
>>>
Content-Length: 40

{"id":337,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":338,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":38}}}
>>>
Content-Length: 38

{"id":338,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":339,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":38},"end":{"line":240,"character":38}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":339,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":340,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":38}}}
>>>
Content-Length: 238

{"id":340,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","range":{"start":{"line":1346,"character":12},"end":{"line":1346,"character":39}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 98387

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n\t***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\t***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n\tthe FAQ page \"My application does not run, what could be wrong?\".  Have you\n\tdefined configASSERT()?\n\n\thttp://www.FreeRTOS.org/support - In return for receiving this top quality\n\tembedded software for free we request you assist our global community by\n\tparticipating in the support forum.\n\n\thttp://www.FreeRTOS.org/training - Investing in training allows your team to\n\tbe as productive as possible as early as possible.  Now you can receive\n\tFreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n\tLtd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n\t#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include <limits.h>\n\n#include \"list.h\"\n#include \"portmacro.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V8.2.0\"\n#define tskKERNEL_VERSION_MAJOR 8\n#define tskKERNEL_VERSION_MINOR 2\n#define tskKERNEL_VERSION_BUILD 0\n\n/**\n * @brief Argument of xTaskCreatePinnedToCore indicating that task has no affinity\n */\n#define tskNO_AFFINITY INT_MAX\n\n/**\n * task. h\n *\n * Type by which tasks are referenced.  For example, a call to xTaskCreate\n * returns (via a pointer parameter) an TaskHandle_t variable that can then\n * be used as a parameter to vTaskDelete to delete the task.\n *\n * \\ingroup Tasks\n */\ntypedef void * TaskHandle_t;\n\n/**\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/** Task states returned by eTaskGetState. */\ntypedef enum\n{\n\teRunning = 0,\t/*!< A task is querying the state of itself, so must be running. */\n\teReady,\t\t\t/*!< The task being queried is in a read or pending ready list. */\n\teBlocked,\t\t/*!< The task being queried is in the Blocked state. */\n\teSuspended,\t\t/*!< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\n\teDeleted\t\t/*!< The task being queried has been deleted, but its TCB has not yet been freed. */\n} eTaskState;\n\n/** Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\n\teNoAction = 0,\t\t\t\t/*!< Notify the task without updating its notify value. */\n\teSetBits,\t\t\t\t\t/*!< Set bits in the task's notification value. */\n\teIncrement,\t\t\t\t\t/*!< Increment the task's notification value. */\n\teSetValueWithOverwrite,\t\t/*!< Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n\teSetValueWithoutOverwrite\t/*!< Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/** @cond */\n/**\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\n\tBaseType_t xOverflowCount;\n\tTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/**\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\n\tvoid *pvBaseAddress;\n\tuint32_t ulLengthInBytes;\n\tuint32_t ulParameters;\n} MemoryRegion_t;\n\n/**\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\n\tTaskFunction_t pvTaskCode;\n\tconst char * const pcName;\t/*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tuint32_t usStackDepth;\n\tvoid *pvParameters;\n\tUBaseType_t uxPriority;\n\tStackType_t *puxStackBuffer;\n\tMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n} TaskParameters_t;\n/** @endcond */\n\n/**\n *  Used with the uxTaskGetSystemState() function to return the state of each task in the system.\n*/\ntypedef struct xTASK_STATUS\n{\n\tTaskHandle_t xHandle;\t\t\t/*!< The handle of the task to which the rest of the information in the structure relates. */\n\tconst char *pcTaskName;\t\t\t/*!< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tUBaseType_t xTaskNumber;\t\t/*!< A number unique to the task. */\n\teTaskState eCurrentState;\t\t/*!< The state in which the task existed when the structure was populated. */\n\tUBaseType_t uxCurrentPriority;\t/*!< The priority at which the task was running (may be inherited) when the structure was populated. */\n\tUBaseType_t uxBasePriority;\t\t/*!< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\n\tuint32_t ulRunTimeCounter;\t\t/*!< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\n\tStackType_t *pxStackBase;\t\t/*!< Points to the lowest address of the task's stack area. */\n\tuint32_t usStackHighWaterMark;\t/*!< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n#if configTASKLIST_INCLUDE_COREID\n\tBaseType_t xCoreID;\t\t\t\t/*!< Core this task is pinned to. This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. */\n#endif\n} TaskStatus_t;\n\n/**\n * Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n * We need this struct because TCB_t is defined (hidden) in tasks.c.\n */\ntypedef struct xTASK_SNAPSHOT\n{\n\tvoid        *pxTCB;         /*!< Address of task control block. */\n\tStackType_t *pxTopOfStack;  /*!< Points to the location of the last item placed on the tasks stack. */\n\tStackType_t *pxEndOfStack;  /*!< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\n\t\t\t\t\t\t\t\t\tpxTopOfStack > pxEndOfStack, stack grows lo2hi*/\n} TaskSnapshot_t;\n\n/**\n * Possible return values for eTaskConfirmSleepModeStatus().\n */\ntypedef enum\n{\n\teAbortSleep = 0,\t\t/*!< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\n\teStandardSleep,\t\t\t/*!< Enter a sleep mode that will not last any longer than the expected idle time. */\n\teNoTasksWaitingTimeout\t/*!< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n\n/**\n * Defines the priority used by the idle task.  This must not be modified.\n *\n * \\ingroup TaskUtils\n */\n#define tskIDLE_PRIORITY\t\t\t( ( UBaseType_t ) 0U )\n\n/**\n * task. h\n *\n * Macro for forcing a context switch.\n *\n * \\ingroup SchedulerControl\n */\n#define taskYIELD()\t\t\t\t\tportYIELD()\n\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskENTER_CRITICAL(mux)\t\tportENTER_CRITICAL(mux)\n#else\n#define taskENTER_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskENTER_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portENTER_CRITICAL(mux)'\\\"\") portENTER_CRITICAL(mux)\n#endif\n#define taskENTER_CRITICAL_ISR(mux)\t\tportENTER_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskEXIT_CRITICAL(mux)\t\t\tportEXIT_CRITICAL(mux)\n#else\n#define taskEXIT_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskEXIT_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portEXIT_CRITICAL(mux)'\\\"\") portEXIT_CRITICAL(mux)\n#endif\n#define taskEXIT_CRITICAL_ISR(mux)\t\tportEXIT_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to disable all maskable interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskDISABLE_INTERRUPTS()\tportDISABLE_INTERRUPTS()\n\n/**\n * task. h\n *\n * Macro to enable microcontroller interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskENABLE_INTERRUPTS()\t\tportENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED\t\t( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED\t( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING\t\t( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreate, but allows setting task affinity\n * in SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\tBaseType_t xTaskCreatePinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\tconst uint32_t usStackDepth,\n\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\tTaskHandle_t * const pvCreatedTask,\n\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID);\n\n#endif\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * See xTaskCreateStatic() for a version that does not use any dynamic memory\n * allocation.\n *\n * xTaskCreate() can only be used to create a task that has unrestricted\n * access to the entire microcontroller memory map.  Systems that include MPU\n * support can alternatively create an MPU constrained task using\n * xTaskCreateRestricted().\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *  // Task to be created.\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *   }\n *  }\n *\n *  // Function that creates a task.\n *  void vOtherFunction( void )\n *  {\n *  static uint8_t ucParameterToPass;\n *  TaskHandle_t xHandle = NULL;\n *\n *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass\n *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an\n *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time\n *   // the new task attempts to access it.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\n *      configASSERT( xHandle );\n *\n *   // Use the handle to delete the task.\n *      if( xHandle != NULL )\n *      {\n *       vTaskDelete( xHandle );\n *      }\n *  }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tstatic inline IRAM_ATTR BaseType_t xTaskCreate(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t usStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tTaskHandle_t * const pvCreatedTask)\n\t{\n\t\treturn xTaskCreatePinnedToCore( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask, tskNO_AFFINITY );\n\t}\n\n#endif\n\n\n\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreateStatic, but allows specifying\n * task affinity in an SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tTaskHandle_t xTaskCreateStaticPinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth,\n\t\t\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\t\t\tStackType_t * const pxStackBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tStaticTask_t * const pxTaskBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID );\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *\n *     // Dimensions the buffer that the task being created will use as its stack.\n *     // NOTE:  This is the number of bytes the stack will hold, not the number of\n *     // words as found in vanilla FreeRTOS.\n *     #define STACK_SIZE 200\n *\n *     // Structure that will hold the TCB of the task being created.\n *     StaticTask_t xTaskBuffer;\n *\n *     // Buffer that the task being created will use as its stack.  Note this is\n *     // an array of StackType_t variables.  The size of StackType_t is dependent on\n *     // the RTOS port.\n *     StackType_t xStack[ STACK_SIZE ];\n *\n *     // Function that implements the task being created.\n *     void vTaskCode( void * pvParameters )\n *     {\n *         // The parameter value is expected to be 1 as 1 is passed in the\n *         // pvParameters value in the call to xTaskCreateStatic().\n *         configASSERT( ( uint32_t ) pvParameters == 1UL );\n *\n *         for( ;; )\n *         {\n *             // Task code goes here.\n *         }\n *     }\n *\n *     // Function that creates a task.\n *     void vOtherFunction( void )\n *     {\n *         TaskHandle_t xHandle = NULL;\n *\n *         // Create the task without using any dynamic memory allocation.\n *         xHandle = xTaskCreateStatic(\n *                       vTaskCode,       // Function that implements the task.\n *                       \"NAME\",          // Text name for the task.\n *                       STACK_SIZE,      // Stack size in bytes, not words.\n *                       ( void * ) 1,    // Parameter passed into the task.\n *                       tskIDLE_PRIORITY,// Priority at which the task is created.\n *                       xStack,          // Array to use as the task's stack.\n *                       &xTaskBuffer );  // Variable to hold the task's data structure.\n *\n *         // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have\n *         // been created, and xHandle will be the task's handle.  Use the handle\n *         // to suspend the task.\n *         vTaskSuspend( xHandle );\n *     }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tstatic inline IRAM_ATTR TaskHandle_t xTaskCreateStatic(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t ulStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tStackType_t * const pxStackBuffer,\n\t\t\tStaticTask_t * const pxTaskBuffer)\n\t{\n\t\treturn xTaskCreateStaticPinnedToCore( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxStackBuffer, pxTaskBuffer, tskNO_AFFINITY );\n\t}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/** @cond */\n/**\n * xTaskCreateRestricted() should only be used in systems that include an MPU\n * implementation.\n *\n * Create a new task and add it to the list of tasks that are ready to run.\n * The function parameters define the memory regions and associated access\n * permissions allocated to the task.\n *\n * @param pxTaskDefinition Pointer to a structure that contains a member\n * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API\n * documentation) plus an optional stack buffer and the memory region\n * definitions.\n *\n * @param pxCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * Example usage:\n * @code{c}\n * // Create an TaskParameters_t structure that defines the task to be created.\n * static const TaskParameters_t xCheckTaskParameters =\n * {\n * \tvATask,\t\t// pvTaskCode - the function that implements the task.\n * \t\"ATask\",\t// pcName - just a text name for the task to assist debugging.\n * \t100,\t\t// usStackDepth\t- the stack size DEFINED IN BYTES.\n * \tNULL,\t\t// pvParameters - passed into the task function as the function parameters.\n * \t( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.\n * \tcStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\n *\n * \t// xRegions - Allocate up to three separate memory regions for access by\n * \t// the task, with appropriate access permissions.  Different processors have\n * \t// different memory alignment requirements - refer to the FreeRTOS documentation\n * \t// for full information.\n * \t{\n * \t\t// Base address\t\t\t\t\tLength\tParameters\n *         { cReadWriteArray,\t\t\t\t32,\t\tportMPU_REGION_READ_WRITE },\n *         { cReadOnlyArray,\t\t\t\t32,\t\tportMPU_REGION_READ_ONLY },\n *         { cPrivilegedOnlyAccessArray,\t128,\tportMPU_REGION_PRIVILEGED_READ_WRITE }\n * \t}\n * };\n *\n * int main( void )\n * {\n * TaskHandle_t xHandle;\n *\n * \t// Create a task from the const structure defined above.  The task handle\n * \t// is requested (the second parameter is not NULL) but in this case just for\n * \t// demonstration purposes as its not actually used.\n * \txTaskCreateRestricted( &xRegTest1Parameters, &xHandle );\n *\n * \t// Start the scheduler.\n * \tvTaskStartScheduler();\n *\n * \t// Will only get here if there was insufficient memory to create the idle\n * \t// and/or timer task.\n * \tfor( ;; );\n * }\n * @endcode\n * \\ingroup Tasks\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n\tBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n\n/**\n * Memory regions are assigned to a restricted task when the task is created by\n * a call to xTaskCreateRestricted().  These regions can be redefined using\n * vTaskAllocateMPURegions().\n *\n * @param xTask The handle of the task being updated.\n *\n * @param xRegions A pointer to an MemoryRegion_t structure that contains the\n * new memory region definitions.\n *\n * Example usage:\n *\n * @code{c}\n * // Define an array of MemoryRegion_t structures that configures an MPU region\n * // allowing read/write access for 1024 bytes starting at the beginning of the\n * // ucOneKByte array.  The other two of the maximum 3 definable regions are\n * // unused so set to zero.\n * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n * {\n * \t// Base address\t\tLength\t\tParameters\n * \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },\n * \t{ 0,\t\t\t\t0,\t\t\t0 },\n * \t{ 0,\t\t\t\t0,\t\t\t0 }\n * };\n *\n * void vATask( void *pvParameters )\n * {\n * \t// This task was created such that it has access to certain regions of\n * \t// memory as defined by the MPU configuration.  At some point it is\n * \t// desired that these MPU regions are replaced with that defined in the\n * \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n * \t// for this purpose.  NULL is used as the task handle to indicate that this\n * \t// function should modify the MPU regions of the calling task.\n * \tvTaskAllocateMPURegions( NULL, xAltRegions );\n *\n * \t// Now the task can continue its function, but from this point on can only\n * \t// access its stack and the ucOneKByte array (unless any other statically\n * \t// defined or shared regions have been declared elsewhere).\n * }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Remove a task from the RTOS real time kernel's management.\n *\n * The task being deleted will be removed from all ready, blocked, suspended\n * and event lists.\n *\n * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @note The idle task is responsible for freeing the kernel allocated\n * memory from tasks that have been deleted.  It is therefore important that\n * the idle task is not starved of microcontroller processing time if your\n * application makes any calls to vTaskDelete ().  Memory allocated by the\n * task code is not automatically freed, and should be freed before the task\n * is deleted.\n *\n * See the demo application file death.c for sample code that utilises\n * vTaskDelete ().\n *\n * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n * cause the calling task to be deleted.\n *\n * Example usage:\n * @code{c}\n *  void vOtherFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n * \t // Create the task, storing the handle.\n * \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n * \t // Use the handle to delete the task.\n * \t vTaskDelete( xHandle );\n *  }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\n/**\n * Delay a task for a given number of ticks.\n *\n * The actual time that the task remains blocked depends on the tick rate.\n * The constant portTICK_PERIOD_MS can be used to calculate real time from\n * the tick rate - with the resolution of one tick period.\n *\n * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * vTaskDelay() specifies a time at which the task wishes to unblock relative to\n * the time at which vTaskDelay() is called.  For example, specifying a block\n * period of 100 ticks will cause the task to unblock 100 ticks after\n * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n * of controlling the frequency of a periodic task as the path taken through the\n * code, as well as other task and interrupt activity, will effect the frequency\n * at which vTaskDelay() gets called and therefore the time at which the task\n * next executes.  See vTaskDelayUntil() for an alternative API function designed\n * to facilitate fixed frequency execution.  It does this by specifying an\n * absolute time (rather than a relative time) at which the calling task should\n * unblock.\n *\n * @param xTicksToDelay The amount of time, in tick periods, that\n * the calling task should block.\n *\n * Example usage:\n * @code{c}\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  // Block for 500ms.\n *  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n *\n * \t for( ;; )\n * \t {\n * \t\t // Simply toggle the LED every 500ms, blocking between each toggle.\n * \t\t vToggleLED();\n * \t\t vTaskDelay( xDelay );\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\n/**\n * Delay a task until a specified time.\n *\n * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * This function can be used by periodic tasks to ensure a constant execution frequency.\n *\n * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n * cause a task to block for the specified number of ticks from the time vTaskDelay () is\n * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n * execution frequency as the time between a task starting to execute and that task\n * calling vTaskDelay () may not be fixed [the task may take a different path though the\n * code between calls, or may get interrupted or preempted a different number of times\n * each time it executes].\n *\n * Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n * unblock.\n *\n * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick\n * rate - with the resolution of one tick period.\n *\n * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n * task was last unblocked.  The variable must be initialised with the current time\n * prior to its first use (see the example below).  Following this the variable is\n * automatically updated within vTaskDelayUntil ().\n *\n * @param xTimeIncrement The cycle time period.  The task will be unblocked at\n * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the\n * same xTimeIncrement parameter value will cause the task to execute with\n * a fixed interface period.\n *\n * Example usage:\n * @code{c}\n *  // Perform an action every 10 ticks.\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  TickType_t xLastWakeTime;\n *  const TickType_t xFrequency = 10;\n *\n * \t // Initialise the xLastWakeTime variable with the current time.\n * \t xLastWakeTime = xTaskGetTickCount ();\n * \t for( ;; )\n * \t {\n * \t\t // Wait for the next cycle.\n * \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );\n *\n * \t\t // Perform action here.\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the priority of any task.\n *\n * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to obtain the priority of the created task.\n *   // It was created with tskIDLE_PRIORITY, but may have changed\n *   // it itself.\n *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n *   {\n *       // The task has changed it's priority.\n *   }\n *\n *   // ...\n *\n *   // Is our priority higher than the created task?\n *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n *   {\n *       // Our priority (obtained using NULL handle) is higher.\n *   }\n * }\n * @endcode\n * \\ingroup TaskCtrl\n */\nUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * A version of uxTaskPriorityGet() that can be used from an ISR.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n */\nUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the state of any task.\n *\n * States are encoded by the eTaskState enumerated type.\n *\n * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.\n *\n * @return The state of xTask at the time the function was called.  Note the\n * state of the task might change between the function being called, and the\n * functions return value being tested by the calling task.\n */\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Set the priority of any task.\n *\n * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A context switch will occur before the function returns if the priority\n * being set is higher than the currently executing task.\n *\n * @param xTask Handle to the task for which the priority is being set.\n * Passing a NULL handle results in the priority of the calling task being set.\n *\n * @param uxNewPriority The priority to which the task will be set.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to raise the priority of the created task.\n *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n *\n *   // ...\n *\n *   // Use a NULL handle to raise our priority to the same value.\n *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\n/**\n * Suspend a task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * When suspended, a task will never get any microcontroller processing time,\n * no matter what its priority.\n *\n * Calls to vTaskSuspend are not accumulative -\n * i.e. calling vTaskSuspend () twice on the same task still only requires one\n * call to vTaskResume () to ready the suspended task.\n *\n * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n * handle will cause the calling task to be suspended.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Suspend ourselves.\n *   vTaskSuspend( NULL );\n *\n *   // We cannot get here unless another task calls vTaskResume\n *   // with our handle as the parameter.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes a suspended task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * vTaskResume ().\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Resume the suspended task ourselves.\n *   vTaskResume( xHandle );\n *\n *   // The created task will once again get microcontroller processing\n *   // time in accordance with its priority within the system.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/**\n * An implementation of vTaskResume() that can be called from within an ISR.\n *\n * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n * available.  See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * xTaskResumeFromISR ().\n *\n * xTaskResumeFromISR() should not be used to synchronise a task with an\n * interrupt if there is a chance that the interrupt could arrive prior to the\n * task being suspended - as this can lead to interrupts being missed. Use of a\n * semaphore as a synchronisation mechanism would avoid this eventuality.\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * @return pdTRUE if resuming the task should result in a context switch,\n * otherwise pdFALSE. This is used by the ISR to determine if a context switch\n * may be required following the ISR.\n *\n * \\ingroup TaskCtrl\n */\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n/** @cond */\n/**\n * Starts the real time kernel tick processing.\n *\n * After calling the kernel has control over which tasks are executed and when.\n *\n * See the demo application file main.c for an example of creating\n * tasks and starting the kernel.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will not get here unless a task calls vTaskEndScheduler ()\n *  }\n * @endcode\n *\n * \\ingroup SchedulerControl\n */\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Stops the real time kernel tick.\n *\n * @note At the time of writing only the x86 real mode port, which runs on a PC\n * in place of DOS, implements this function.\n *\n * All created tasks will be automatically deleted and multitasking\n * (either preemptive or cooperative) will stop.\n * Execution then resumes from the point where vTaskStartScheduler ()\n * was called, as if vTaskStartScheduler () had just returned.\n *\n * See the demo application file main. c in the demo/PC directory for an\n * example that uses vTaskEndScheduler ().\n *\n * vTaskEndScheduler () requires an exit function to be defined within the\n * portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n * performs hardware specific operations such as stopping the kernel tick.\n *\n * vTaskEndScheduler () will cause all of the resources allocated by the\n * kernel to be freed - but will not free resources allocated by application\n * tasks.\n *\n * Example usage:\n * @code{c}\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // At some point we want to end the real time kernel processing\n *       // so call ...\n *       vTaskEndScheduler ();\n *   }\n *  }\n *\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will only get here when the vTaskCode () task has called\n *   // vTaskEndScheduler ().  When we get here we are back to single task\n *   // execution.\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Suspends the scheduler without disabling interrupts.\n *\n * Context switches will not occur while the scheduler is suspended.\n *\n * After calling vTaskSuspendAll () the calling task will continue to execute\n * without risk of being swapped out until a call to xTaskResumeAll () has been\n * made.\n *\n * API functions that have the potential to cause a context switch (for example,\n * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n * is suspended.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the kernel\n *       // tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.\n *       xTaskResumeAll ();\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes scheduler activity after it was suspended by a call to\n * vTaskSuspendAll().\n *\n * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n * that were previously suspended by a call to vTaskSuspend().\n *\n * @return If resuming the scheduler caused a context switch then pdTRUE is\n *\t\t  returned, otherwise pdFALSE is returned.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the real\n *       // time kernel tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.  We want to force\n *       // a context switch - but there is no point if resuming the scheduler\n *       // caused a context switch already.\n *       if( !xTaskResumeAll () )\n *       {\n *            taskYIELD ();\n *       }\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\n/**\n * Get tick count\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get tick count from ISR\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * This is a version of xTaskGetTickCount() that is safe to be called from an\n * ISR - provided that TickType_t is the natural word size of the\n * microcontroller being used or interrupt nesting is either not supported or\n * not being used.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get current number of tasks\n *\n * @return The number of tasks that the real time kernel is currently managing.\n * This includes all ready, blocked and suspended tasks.  A task that\n * has been deleted but not yet freed by the idle task will also be\n * included in the count.\n *\n * \\ingroup TaskUtils\n */\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get task name\n *\n * @return The text (human readable) name of the task referenced by the handle\n * xTaskToQuery.  A task can query its own name by either passing in its own\n * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be\n * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.\n *\n * \\ingroup TaskUtils\n */\nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Returns the high water mark of the stack associated with xTask.\n *\n * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * High water mark is the minimum free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task started.\n * The smaller the returned number the closer the task has come to overflowing its stack.\n *\n * @param xTask Handle of the task associated with the stack to be checked.\n * Set xTask to NULL to check the stack of the calling task.\n *\n * @return The smallest amount of free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task referenced by\n * xTask was created.\n */\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Returns the start of the stack associated with xTask.\n *\n * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * Returns the highest stack memory address on architectures where the stack grows down\n * from high memory, and the lowest memory address on architectures where the\n * stack grows up from low memory.\n *\n * @param xTask Handle of the task associated with the stack returned.\n * Set xTask to NULL to return the stack of the calling task.\n *\n * @return A pointer to the start of the stack.\n */\nuint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n\t#if configUSE_APPLICATION_TASK_TAG == 1\n\t\t/**\n\t\t * Sets pxHookFunction to be the task hook function used by the task xTask.\n\t\t * @param xTask Handle of the task to set the hook function for\n\t\t *              Passing xTask as NULL has the effect of setting the calling\n\t\t *              tasks hook function.\n\t\t * @param pxHookFunction  Pointer to the hook function.\n\t\t */\n\t\tvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\n\t\t/**\n\t\t * Get the hook function assigned to given task.\n\t\t * @param xTask Handle of the task to get the hook function for\n\t\t *              Passing xTask as NULL has the effect of getting the calling\n\t\t *              tasks hook function.\n\t\t * @return The pxHookFunction value assigned to the task xTask.\n\t\t */\n\t\tTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\t#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )\n\n\t/**\n\t * Set local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t * @param xIndex The index of the pointer to set, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @param pvValue  Pointer value to set.\n\t */\n\tvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\n\n\n\t/**\n\t * Get local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToQuery  Task to get thread local storage pointer for\n\t * @param xIndex The index of the pointer to get, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @return  Pointer value\n\t */\n\tvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n\t#if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )\n\n\t\t/**\n\t\t * Prototype of local storage pointer deletion callback.\n\t\t */\n\t\ttypedef void (*TlsDeleteCallbackFunction_t)( int, void * );\n\n\t\t/**\n\t\t * Set local storage pointer and deletion callback.\n\t\t *\n\t\t * Each task contains an array of pointers that is dimensioned by the\n\t\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t\t * The kernel does not use the pointers itself, so the application writer\n\t\t * can use the pointers for any purpose they wish.\n\t\t *\n\t\t * Local storage pointers set for a task can reference dynamically\n\t\t * allocated resources. This function is similar to\n\t\t * vTaskSetThreadLocalStoragePointer, but provides a way to release\n\t\t * these resources when the task gets deleted. For each pointer,\n\t\t * a callback function can be set. This function will be called\n\t\t * when task is deleted, with the local storage pointer index\n\t\t * and value as arguments.\n\t\t *\n\t\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t\t * @param xIndex The index of the pointer to set, from 0 to\n\t\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t\t * @param pvValue  Pointer value to set.\n\t\t * @param pvDelCallback  Function to call to dispose of the local\n\t\t *                       storage pointer when the task is deleted.\n\t\t */\n\t\tvoid vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue, TlsDeleteCallbackFunction_t pvDelCallback);\n\t#endif\n\n#endif\n\n/**\n * Calls the hook function associated with xTask. Passing xTask as NULL has\n * the effect of calling the Running tasks (the calling task) hook function.\n *\n * @param xTask  Handle of the task to call the hook for.\n * @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n * wants.  The return value is the value returned by the task hook function\n * registered by the user.\n */\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\n/**\n * Get the handle of idle task for the current CPU.\n *\n * xTaskGetIdleTaskHandle() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @return The handle of the idle task.  It is not valid to call\n * xTaskGetIdleTaskHandle() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandle( void );\n\n/**\n * Get the handle of idle task for the given CPU.\n *\n * xTaskGetIdleTaskHandleForCPU() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @param cpuid The CPU to get the handle for\n *\n * @return Idle task handle of a given cpu. It is not valid to call\n * xTaskGetIdleTaskHandleForCPU() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandleForCPU( UBaseType_t cpuid );\n\n/**\n * Get the state of tasks in the system.\n *\n * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n * uxTaskGetSystemState() to be available.\n *\n * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n * the system.  TaskStatus_t structures contain, among other things, members\n * for the task handle, task name, task priority, task state, and total amount\n * of run time consumed by the task.  See the TaskStatus_t structure\n * definition in this file for the full member list.\n *\n * @note  This function is intended for debugging use only as its use results in\n * the scheduler remaining suspended for an extended period.\n *\n * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n * The array must contain at least one TaskStatus_t structure for each task\n * that is under the control of the RTOS.  The number of tasks under the control\n * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n *\n * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n * parameter.  The size is specified as the number of indexes in the array, or\n * the number of TaskStatus_t structures contained in the array, not by the\n * number of bytes in the array.\n *\n * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n * total run time (as defined by the run time stats clock, see\n * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.\n * pulTotalRunTime can be set to NULL to omit the total run time information.\n *\n * @return The number of TaskStatus_t structures that were populated by\n * uxTaskGetSystemState().  This should equal the number returned by the\n * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n * in the uxArraySize parameter was too small.\n *\n * Example usage:\n * @code{c}\n * // This example demonstrates how a human readable table of run time stats\n * // information is generated from raw data provided by uxTaskGetSystemState().\n * // The human readable table is written to pcWriteBuffer\n * void vTaskGetRunTimeStats( char *pcWriteBuffer )\n * {\n * TaskStatus_t *pxTaskStatusArray;\n * volatile UBaseType_t uxArraySize, x;\n * uint32_t ulTotalRunTime, ulStatsAsPercentage;\n *\n *  // Make sure the write buffer does not contain a string.\n *  *pcWriteBuffer = 0x00;\n *\n *  // Take a snapshot of the number of tasks in case it changes while this\n *  // function is executing.\n *  uxArraySize = uxTaskGetNumberOfTasks();\n *\n *  // Allocate a TaskStatus_t structure for each task.  An array could be\n *  // allocated statically at compile time.\n *  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n *\n *  if( pxTaskStatusArray != NULL )\n *  {\n *      // Generate raw status information about each task.\n *      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n *\n *      // For percentage calculations.\n *      ulTotalRunTime /= 100UL;\n *\n *      // Avoid divide by zero errors.\n *      if( ulTotalRunTime > 0 )\n *      {\n *          // For each populated position in the pxTaskStatusArray array,\n *          // format the raw data as human readable ASCII data\n *          for( x = 0; x < uxArraySize; x++ )\n *          {\n *              // What percentage of the total run time has the task used?\n *              // This will always be rounded down to the nearest integer.\n *              // ulTotalRunTimeDiv100 has already been divided by 100.\n *              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n *\n *              if( ulStatsAsPercentage > 0UL )\n *              {\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n *              }\n *              else\n *              {\n *                  // If the percentage is zero here then the task has\n *                  // consumed less than 1% of the total run time.\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n *              }\n *\n *              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n *          }\n *      }\n *\n *      // The array is no longer needed, free the memory it consumes.\n *      vPortFree( pxTaskStatusArray );\n *  }\n * }\n * @endcode\n */\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );\n\n/**\n * List all the current tasks.\n *\n * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n * both be defined as 1 for this function to be available.  See the\n * configuration section of the FreeRTOS.org website for more information.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Lists all the current tasks, along with their current state and stack\n * usage high water mark.\n *\n * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n * suspended ('S').\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays task\n * names, states and stack usage.\n *\n * vTaskList() has a dependency on the sprintf() C library function that might\n * bloat the code size, use a lot of stack, and provide different results on\n * different platforms.  An alternative, tiny, third party, and limited\n * functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState()\n * directly to get access to raw stats data, rather than indirectly through a\n * call to vTaskList().\n *\n * @param pcWriteBuffer A buffer into which the above mentioned details\n * will be written, in ASCII form.  This buffer is assumed to be large\n * enough to contain the generated report.  Approximately 40 bytes per\n * task should be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Get the state of running tasks as a string\n *\n * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n * must both be defined as 1 for this function to be available.  The application\n * must also then provide definitions for\n * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n * to configure a peripheral timer/counter and return the timers current count\n * value respectively.  The counter should be at least 10 times the frequency of\n * the tick count.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n * accumulated execution time being stored for each task.  The resolution\n * of the accumulated time value depends on the frequency of the timer\n * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n * Calling vTaskGetRunTimeStats() writes the total execution time of each\n * task into a buffer, both as an absolute count value and as a percentage\n * of the total system execution time.\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays the\n * amount of time each task has spent in the Running state in both absolute and\n * percentage terms.\n *\n * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n * that might bloat the code size, use a lot of stack, and provide different\n * results on different platforms.  An alternative, tiny, third party, and\n * limited functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState() directly\n * to get access to raw stats data, rather than indirectly through a call to\n * vTaskGetRunTimeStats().\n *\n * @param pcWriteBuffer A buffer into which the execution times will be\n * written, in ASCII form.  This buffer is assumed to be large enough to\n * contain the generated report.  Approximately 40 bytes per task should\n * be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Send task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\tupdated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\n/**\n * Send task notification from an ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotify() that can be used from an interrupt service routine\n * (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n * be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Wait for task notification\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n * will be cleared in the calling task's notification value before the task\n * checks to see if any notifications are pending, and optionally blocks if no\n * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n * the effect of resetting the task's notification value to 0.  Setting\n * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n *\n * @param ulBitsToClearOnExit If a notification is pending or received before\n * the calling task exits the xTaskNotifyWait() function then the task's\n * notification value (see the xTaskNotify() API function) is passed out using\n * the pulNotificationValue parameter.  Then any bits that are set in\n * ulBitsToClearOnExit will be cleared in the task's notification value (note\n * *pulNotificationValue is set before any bits are cleared).  Setting\n * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n * (if limits.h is not included) will have the effect of resetting the task's\n * notification value to 0 before the function exits.  Setting\n * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n * when the function exits (in which case the value passed out in\n * pulNotificationValue will match the task's notification value).\n *\n * @param pulNotificationValue Used to pass the task's notification value out\n * of the function.  Note the value passed out will not be effected by the\n * clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for a notification to be received, should a notification\n * not already be pending when xTaskNotifyWait() was called.  The task\n * will not consume any processing time while it is in the Blocked state.  This\n * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be\n * used to convert a time specified in milliseconds to a time specified in\n * ticks.\n *\n * @return If a notification was received (including notifications that were\n * already pending when xTaskNotifyWait was called) then pdPASS is\n * returned.  Otherwise pdFAIL is returned.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n/**\n * Simplified macro for sending task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * xTaskNotifyGive() is a helper macro intended for use when task notifications\n * are used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,\n * the equivalent action that instead uses a task notification is\n * xTaskNotifyGive().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the\n * eAction parameter set to eIncrement - so pdPASS is always returned.\n *\n * \\ingroup TaskNotifications\n */\n#define xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )\n\n/**\n * Simplified macro for sending task notification from ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotifyGive() that can be called from an interrupt service\n * routine (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * vTaskNotifyGiveFromISR() is intended for use when task notifications are\n * used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given from an ISR using the\n * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n * a task notification is vTaskNotifyGiveFromISR().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n * should be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * \\ingroup TaskNotifications\n */\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Simplified macro for receiving task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * ulTaskNotifyTake() is intended for use when a task notification is used as a\n * faster and lighter weight binary or counting semaphore alternative.  Actual\n * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the\n * equivalent action that instead uses a task notification is\n * ulTaskNotifyTake().\n *\n * When a task is using its notification value as a binary or counting semaphore\n * other tasks should send notifications to it using the xTaskNotifyGive()\n * macro, or xTaskNotify() function with the eAction parameter set to\n * eIncrement.\n *\n * ulTaskNotifyTake() can either clear the task's notification value to\n * zero on exit, in which case the notification value acts like a binary\n * semaphore, or decrement the task's notification value on exit, in which case\n * the notification value acts like a counting semaphore.\n *\n * A task can use ulTaskNotifyTake() to [optionally] block to wait for a\n * the task's notification value to be non-zero.  The task does not consume any\n * CPU time while it is in the Blocked state.\n *\n * Where as xTaskNotifyWait() will return when a notification is pending,\n * ulTaskNotifyTake() will return when the task's notification value is\n * not zero.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n * notification value is decremented when the function exits.  In this way the\n * notification value acts like a counting semaphore.  If xClearCountOnExit is\n * not pdFALSE then the task's notification value is cleared to zero when the\n * function exits.  In this way the notification value acts like a binary\n * semaphore.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for the task's notification value to be greater than zero,\n * should the count not already be greater than zero when\n * ulTaskNotifyTake() was called.  The task will not consume any processing\n * time while it is in the Blocked state.  This is specified in kernel ticks,\n * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time\n * specified in milliseconds to a time specified in ticks.\n *\n * @return The task's notification count before it is either cleared to zero or\n * decremented (see the xClearCountOnExit parameter).\n *\n * \\ingroup TaskNotifications\n */\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n/** @cond */\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * xTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n * Return the handle of the task running on a certain CPU. Because of\n * the nature of SMP processing, there is no guarantee that this\n * value will still be valid on return and should only be used for\n * debugging purposes.\n */\nTaskHandle_t xTaskGetCurrentTaskHandleForCPU( BaseType_t cpuid );\n\n\n/*\n * Capture the current time status for future reference.\n */\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n/*\n * Compare the time status now with that previously captured to see if the\n * timeout has expired.\n */\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n\n/*\n * Get the current core affinity of a task\n */\nBaseType_t xTaskGetAffinity( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/*\n * Only avilable when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nvoid *pvTaskIncrementMutexHeldCount( void );\n\n/*\n * This function fills array with TaskSnapshot_t structures for every task in the system.\n * Used by core dump facility to get snapshots of all tasks in the system.\n * Only available when configENABLE_TASK_SNAPSHOT is set to 1.\n * @param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.\n * @param uxArraySize Size of tasks snapshots array.\n * @param pxTcbSz Pointer to store size of TCB.\n * @return Number of elements stored in array.\n */\nUBaseType_t uxTaskGetSnapshotAll( TaskSnapshot_t * const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t * const pxTcbSz );\n\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n\n\n\n"}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h"}}}
>>>
Content-Length: 205

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":341,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":38},"end":{"line":239,"character":38}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":341,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":712},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":342,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":35},"end":{"line":239,"character":35}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":342,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":343,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":35}}}
>>>
Content-Length: 38

{"id":343,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":712}}}Content-Length: 285

{"jsonrpc":"2.0","id":344,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":35},"end":{"line":240,"character":35}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":344,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":713},"contentChanges":[{"range":{"start":{"line":240,"character":4},"end":{"line":240,"character":7}},"rangeLength":3,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":345,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":32},"end":{"line":240,"character":32}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":345,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":713}}}Content-Length: 209

{"jsonrpc":"2.0","id":346,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":0}}}
>>>
Content-Length: 40

{"id":346,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":347,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":234,"character":11}}}
>>>
Content-Length: 40

{"id":347,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":348,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":224,"character":10}}}
>>>
Content-Length: 40

{"id":348,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":349,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":219,"character":10}}}
>>>
Content-Length: 40

{"id":349,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":350,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":218,"character":23}}}
>>>
Content-Length: 40

{"id":350,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":351,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":218,"character":24}}}
>>>
Content-Length: 38

{"id":351,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":352,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":24}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":352,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":353,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":228,"character":13}}}
>>>
Content-Length: 40

{"id":353,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":714},"contentChanges":[{"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":24}},"rangeLength":0,"text":" "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":354,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":25},"end":{"line":218,"character":25}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":354,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":715},"contentChanges":[{"range":{"start":{"line":218,"character":25},"end":{"line":218,"character":25}},"rangeLength":0,"text":":"}]}}Content-Length: 266

{"jsonrpc":"2.0","id":355,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":218,"character":26},"context":{"triggerKind":2,"triggerCharacter":":"}}}
>>>
Content-Length: 69

{"id":355,"result":{"isIncomplete":false,"items":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":356,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":26},"end":{"line":218,"character":26}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":356,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":715}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":716},"contentChanges":[{"range":{"start":{"line":218,"character":26},"end":{"line":218,"character":26}},"rangeLength":0,"text":" "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":357,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":27},"end":{"line":218,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":357,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":716}}}Content-Length: 285

{"jsonrpc":"2.0","id":358,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":25},"end":{"line":218,"character":25}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":358,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":717},"contentChanges":[{"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":25}},"rangeLength":1,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":359,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":24}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":359,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":717}}}Content-Length: 210

{"jsonrpc":"2.0","id":360,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":225,"character":13}}}
>>>
Content-Length: 233

{"id":360,"result":{"contents":{"kind":"markdown","value":"### type-alias `esp_err_t`  \n\n---\n```cpp\ntypedef int32_t esp_err_t\n```"},"range":{"start":{"line":260,"character":4},"end":{"line":260,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":361,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":19}}}
>>>
Content-Length: 128

{"id":361,"result":[{"range":{"start":{"line":240,"character":19},"end":{"line":240,"character":46}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":362,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":19},"end":{"line":240,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":362,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":363,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":30}}}
>>>
Content-Length: 1078

{"id":363,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":275,"character":19},"end":{"line":275,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":364,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":31}}}
>>>
Content-Length: 238

{"id":364,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","range":{"start":{"line":1346,"character":12},"end":{"line":1346,"character":39}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":718},"contentChanges":[{"range":{"start":{"line":240,"character":0},"end":{"line":241,"character":0}},"rangeLength":55,"text":""}]}}Content-Length: 98387

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n\t***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\t***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n\tthe FAQ page \"My application does not run, what could be wrong?\".  Have you\n\tdefined configASSERT()?\n\n\thttp://www.FreeRTOS.org/support - In return for receiving this top quality\n\tembedded software for free we request you assist our global community by\n\tparticipating in the support forum.\n\n\thttp://www.FreeRTOS.org/training - Investing in training allows your team to\n\tbe as productive as possible as early as possible.  Now you can receive\n\tFreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n\tLtd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n\t#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include <limits.h>\n\n#include \"list.h\"\n#include \"portmacro.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V8.2.0\"\n#define tskKERNEL_VERSION_MAJOR 8\n#define tskKERNEL_VERSION_MINOR 2\n#define tskKERNEL_VERSION_BUILD 0\n\n/**\n * @brief Argument of xTaskCreatePinnedToCore indicating that task has no affinity\n */\n#define tskNO_AFFINITY INT_MAX\n\n/**\n * task. h\n *\n * Type by which tasks are referenced.  For example, a call to xTaskCreate\n * returns (via a pointer parameter) an TaskHandle_t variable that can then\n * be used as a parameter to vTaskDelete to delete the task.\n *\n * \\ingroup Tasks\n */\ntypedef void * TaskHandle_t;\n\n/**\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/** Task states returned by eTaskGetState. */\ntypedef enum\n{\n\teRunning = 0,\t/*!< A task is querying the state of itself, so must be running. */\n\teReady,\t\t\t/*!< The task being queried is in a read or pending ready list. */\n\teBlocked,\t\t/*!< The task being queried is in the Blocked state. */\n\teSuspended,\t\t/*!< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\n\teDeleted\t\t/*!< The task being queried has been deleted, but its TCB has not yet been freed. */\n} eTaskState;\n\n/** Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\n\teNoAction = 0,\t\t\t\t/*!< Notify the task without updating its notify value. */\n\teSetBits,\t\t\t\t\t/*!< Set bits in the task's notification value. */\n\teIncrement,\t\t\t\t\t/*!< Increment the task's notification value. */\n\teSetValueWithOverwrite,\t\t/*!< Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n\teSetValueWithoutOverwrite\t/*!< Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/** @cond */\n/**\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\n\tBaseType_t xOverflowCount;\n\tTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/**\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\n\tvoid *pvBaseAddress;\n\tuint32_t ulLengthInBytes;\n\tuint32_t ulParameters;\n} MemoryRegion_t;\n\n/**\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\n\tTaskFunction_t pvTaskCode;\n\tconst char * const pcName;\t/*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tuint32_t usStackDepth;\n\tvoid *pvParameters;\n\tUBaseType_t uxPriority;\n\tStackType_t *puxStackBuffer;\n\tMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n} TaskParameters_t;\n/** @endcond */\n\n/**\n *  Used with the uxTaskGetSystemState() function to return the state of each task in the system.\n*/\ntypedef struct xTASK_STATUS\n{\n\tTaskHandle_t xHandle;\t\t\t/*!< The handle of the task to which the rest of the information in the structure relates. */\n\tconst char *pcTaskName;\t\t\t/*!< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tUBaseType_t xTaskNumber;\t\t/*!< A number unique to the task. */\n\teTaskState eCurrentState;\t\t/*!< The state in which the task existed when the structure was populated. */\n\tUBaseType_t uxCurrentPriority;\t/*!< The priority at which the task was running (may be inherited) when the structure was populated. */\n\tUBaseType_t uxBasePriority;\t\t/*!< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\n\tuint32_t ulRunTimeCounter;\t\t/*!< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\n\tStackType_t *pxStackBase;\t\t/*!< Points to the lowest address of the task's stack area. */\n\tuint32_t usStackHighWaterMark;\t/*!< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n#if configTASKLIST_INCLUDE_COREID\n\tBaseType_t xCoreID;\t\t\t\t/*!< Core this task is pinned to. This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. */\n#endif\n} TaskStatus_t;\n\n/**\n * Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n * We need this struct because TCB_t is defined (hidden) in tasks.c.\n */\ntypedef struct xTASK_SNAPSHOT\n{\n\tvoid        *pxTCB;         /*!< Address of task control block. */\n\tStackType_t *pxTopOfStack;  /*!< Points to the location of the last item placed on the tasks stack. */\n\tStackType_t *pxEndOfStack;  /*!< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\n\t\t\t\t\t\t\t\t\tpxTopOfStack > pxEndOfStack, stack grows lo2hi*/\n} TaskSnapshot_t;\n\n/**\n * Possible return values for eTaskConfirmSleepModeStatus().\n */\ntypedef enum\n{\n\teAbortSleep = 0,\t\t/*!< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\n\teStandardSleep,\t\t\t/*!< Enter a sleep mode that will not last any longer than the expected idle time. */\n\teNoTasksWaitingTimeout\t/*!< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n\n/**\n * Defines the priority used by the idle task.  This must not be modified.\n *\n * \\ingroup TaskUtils\n */\n#define tskIDLE_PRIORITY\t\t\t( ( UBaseType_t ) 0U )\n\n/**\n * task. h\n *\n * Macro for forcing a context switch.\n *\n * \\ingroup SchedulerControl\n */\n#define taskYIELD()\t\t\t\t\tportYIELD()\n\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskENTER_CRITICAL(mux)\t\tportENTER_CRITICAL(mux)\n#else\n#define taskENTER_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskENTER_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portENTER_CRITICAL(mux)'\\\"\") portENTER_CRITICAL(mux)\n#endif\n#define taskENTER_CRITICAL_ISR(mux)\t\tportENTER_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskEXIT_CRITICAL(mux)\t\t\tportEXIT_CRITICAL(mux)\n#else\n#define taskEXIT_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskEXIT_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portEXIT_CRITICAL(mux)'\\\"\") portEXIT_CRITICAL(mux)\n#endif\n#define taskEXIT_CRITICAL_ISR(mux)\t\tportEXIT_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to disable all maskable interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskDISABLE_INTERRUPTS()\tportDISABLE_INTERRUPTS()\n\n/**\n * task. h\n *\n * Macro to enable microcontroller interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskENABLE_INTERRUPTS()\t\tportENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED\t\t( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED\t( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING\t\t( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreate, but allows setting task affinity\n * in SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\tBaseType_t xTaskCreatePinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\tconst uint32_t usStackDepth,\n\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\tTaskHandle_t * const pvCreatedTask,\n\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID);\n\n#endif\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * See xTaskCreateStatic() for a version that does not use any dynamic memory\n * allocation.\n *\n * xTaskCreate() can only be used to create a task that has unrestricted\n * access to the entire microcontroller memory map.  Systems that include MPU\n * support can alternatively create an MPU constrained task using\n * xTaskCreateRestricted().\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *  // Task to be created.\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *   }\n *  }\n *\n *  // Function that creates a task.\n *  void vOtherFunction( void )\n *  {\n *  static uint8_t ucParameterToPass;\n *  TaskHandle_t xHandle = NULL;\n *\n *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass\n *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an\n *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time\n *   // the new task attempts to access it.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\n *      configASSERT( xHandle );\n *\n *   // Use the handle to delete the task.\n *      if( xHandle != NULL )\n *      {\n *       vTaskDelete( xHandle );\n *      }\n *  }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tstatic inline IRAM_ATTR BaseType_t xTaskCreate(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t usStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tTaskHandle_t * const pvCreatedTask)\n\t{\n\t\treturn xTaskCreatePinnedToCore( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask, tskNO_AFFINITY );\n\t}\n\n#endif\n\n\n\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreateStatic, but allows specifying\n * task affinity in an SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tTaskHandle_t xTaskCreateStaticPinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth,\n\t\t\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\t\t\tStackType_t * const pxStackBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tStaticTask_t * const pxTaskBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID );\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *\n *     // Dimensions the buffer that the task being created will use as its stack.\n *     // NOTE:  This is the number of bytes the stack will hold, not the number of\n *     // words as found in vanilla FreeRTOS.\n *     #define STACK_SIZE 200\n *\n *     // Structure that will hold the TCB of the task being created.\n *     StaticTask_t xTaskBuffer;\n *\n *     // Buffer that the task being created will use as its stack.  Note this is\n *     // an array of StackType_t variables.  The size of StackType_t is dependent on\n *     // the RTOS port.\n *     StackType_t xStack[ STACK_SIZE ];\n *\n *     // Function that implements the task being created.\n *     void vTaskCode( void * pvParameters )\n *     {\n *         // The parameter value is expected to be 1 as 1 is passed in the\n *         // pvParameters value in the call to xTaskCreateStatic().\n *         configASSERT( ( uint32_t ) pvParameters == 1UL );\n *\n *         for( ;; )\n *         {\n *             // Task code goes here.\n *         }\n *     }\n *\n *     // Function that creates a task.\n *     void vOtherFunction( void )\n *     {\n *         TaskHandle_t xHandle = NULL;\n *\n *         // Create the task without using any dynamic memory allocation.\n *         xHandle = xTaskCreateStatic(\n *                       vTaskCode,       // Function that implements the task.\n *                       \"NAME\",          // Text name for the task.\n *                       STACK_SIZE,      // Stack size in bytes, not words.\n *                       ( void * ) 1,    // Parameter passed into the task.\n *                       tskIDLE_PRIORITY,// Priority at which the task is created.\n *                       xStack,          // Array to use as the task's stack.\n *                       &xTaskBuffer );  // Variable to hold the task's data structure.\n *\n *         // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have\n *         // been created, and xHandle will be the task's handle.  Use the handle\n *         // to suspend the task.\n *         vTaskSuspend( xHandle );\n *     }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tstatic inline IRAM_ATTR TaskHandle_t xTaskCreateStatic(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t ulStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tStackType_t * const pxStackBuffer,\n\t\t\tStaticTask_t * const pxTaskBuffer)\n\t{\n\t\treturn xTaskCreateStaticPinnedToCore( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxStackBuffer, pxTaskBuffer, tskNO_AFFINITY );\n\t}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/** @cond */\n/**\n * xTaskCreateRestricted() should only be used in systems that include an MPU\n * implementation.\n *\n * Create a new task and add it to the list of tasks that are ready to run.\n * The function parameters define the memory regions and associated access\n * permissions allocated to the task.\n *\n * @param pxTaskDefinition Pointer to a structure that contains a member\n * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API\n * documentation) plus an optional stack buffer and the memory region\n * definitions.\n *\n * @param pxCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * Example usage:\n * @code{c}\n * // Create an TaskParameters_t structure that defines the task to be created.\n * static const TaskParameters_t xCheckTaskParameters =\n * {\n * \tvATask,\t\t// pvTaskCode - the function that implements the task.\n * \t\"ATask\",\t// pcName - just a text name for the task to assist debugging.\n * \t100,\t\t// usStackDepth\t- the stack size DEFINED IN BYTES.\n * \tNULL,\t\t// pvParameters - passed into the task function as the function parameters.\n * \t( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.\n * \tcStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\n *\n * \t// xRegions - Allocate up to three separate memory regions for access by\n * \t// the task, with appropriate access permissions.  Different processors have\n * \t// different memory alignment requirements - refer to the FreeRTOS documentation\n * \t// for full information.\n * \t{\n * \t\t// Base address\t\t\t\t\tLength\tParameters\n *         { cReadWriteArray,\t\t\t\t32,\t\tportMPU_REGION_READ_WRITE },\n *         { cReadOnlyArray,\t\t\t\t32,\t\tportMPU_REGION_READ_ONLY },\n *         { cPrivilegedOnlyAccessArray,\t128,\tportMPU_REGION_PRIVILEGED_READ_WRITE }\n * \t}\n * };\n *\n * int main( void )\n * {\n * TaskHandle_t xHandle;\n *\n * \t// Create a task from the const structure defined above.  The task handle\n * \t// is requested (the second parameter is not NULL) but in this case just for\n * \t// demonstration purposes as its not actually used.\n * \txTaskCreateRestricted( &xRegTest1Parameters, &xHandle );\n *\n * \t// Start the scheduler.\n * \tvTaskStartScheduler();\n *\n * \t// Will only get here if there was insufficient memory to create the idle\n * \t// and/or timer task.\n * \tfor( ;; );\n * }\n * @endcode\n * \\ingroup Tasks\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n\tBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n\n/**\n * Memory regions are assigned to a restricted task when the task is created by\n * a call to xTaskCreateRestricted().  These regions can be redefined using\n * vTaskAllocateMPURegions().\n *\n * @param xTask The handle of the task being updated.\n *\n * @param xRegions A pointer to an MemoryRegion_t structure that contains the\n * new memory region definitions.\n *\n * Example usage:\n *\n * @code{c}\n * // Define an array of MemoryRegion_t structures that configures an MPU region\n * // allowing read/write access for 1024 bytes starting at the beginning of the\n * // ucOneKByte array.  The other two of the maximum 3 definable regions are\n * // unused so set to zero.\n * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n * {\n * \t// Base address\t\tLength\t\tParameters\n * \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },\n * \t{ 0,\t\t\t\t0,\t\t\t0 },\n * \t{ 0,\t\t\t\t0,\t\t\t0 }\n * };\n *\n * void vATask( void *pvParameters )\n * {\n * \t// This task was created such that it has access to certain regions of\n * \t// memory as defined by the MPU configuration.  At some point it is\n * \t// desired that these MPU regions are replaced with that defined in the\n * \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n * \t// for this purpose.  NULL is used as the task handle to indicate that this\n * \t// function should modify the MPU regions of the calling task.\n * \tvTaskAllocateMPURegions( NULL, xAltRegions );\n *\n * \t// Now the task can continue its function, but from this point on can only\n * \t// access its stack and the ucOneKByte array (unless any other statically\n * \t// defined or shared regions have been declared elsewhere).\n * }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Remove a task from the RTOS real time kernel's management.\n *\n * The task being deleted will be removed from all ready, blocked, suspended\n * and event lists.\n *\n * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @note The idle task is responsible for freeing the kernel allocated\n * memory from tasks that have been deleted.  It is therefore important that\n * the idle task is not starved of microcontroller processing time if your\n * application makes any calls to vTaskDelete ().  Memory allocated by the\n * task code is not automatically freed, and should be freed before the task\n * is deleted.\n *\n * See the demo application file death.c for sample code that utilises\n * vTaskDelete ().\n *\n * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n * cause the calling task to be deleted.\n *\n * Example usage:\n * @code{c}\n *  void vOtherFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n * \t // Create the task, storing the handle.\n * \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n * \t // Use the handle to delete the task.\n * \t vTaskDelete( xHandle );\n *  }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\n/**\n * Delay a task for a given number of ticks.\n *\n * The actual time that the task remains blocked depends on the tick rate.\n * The constant portTICK_PERIOD_MS can be used to calculate real time from\n * the tick rate - with the resolution of one tick period.\n *\n * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * vTaskDelay() specifies a time at which the task wishes to unblock relative to\n * the time at which vTaskDelay() is called.  For example, specifying a block\n * period of 100 ticks will cause the task to unblock 100 ticks after\n * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n * of controlling the frequency of a periodic task as the path taken through the\n * code, as well as other task and interrupt activity, will effect the frequency\n * at which vTaskDelay() gets called and therefore the time at which the task\n * next executes.  See vTaskDelayUntil() for an alternative API function designed\n * to facilitate fixed frequency execution.  It does this by specifying an\n * absolute time (rather than a relative time) at which the calling task should\n * unblock.\n *\n * @param xTicksToDelay The amount of time, in tick periods, that\n * the calling task should block.\n *\n * Example usage:\n * @code{c}\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  // Block for 500ms.\n *  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n *\n * \t for( ;; )\n * \t {\n * \t\t // Simply toggle the LED every 500ms, blocking between each toggle.\n * \t\t vToggleLED();\n * \t\t vTaskDelay( xDelay );\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\n/**\n * Delay a task until a specified time.\n *\n * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * This function can be used by periodic tasks to ensure a constant execution frequency.\n *\n * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n * cause a task to block for the specified number of ticks from the time vTaskDelay () is\n * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n * execution frequency as the time between a task starting to execute and that task\n * calling vTaskDelay () may not be fixed [the task may take a different path though the\n * code between calls, or may get interrupted or preempted a different number of times\n * each time it executes].\n *\n * Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n * unblock.\n *\n * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick\n * rate - with the resolution of one tick period.\n *\n * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n * task was last unblocked.  The variable must be initialised with the current time\n * prior to its first use (see the example below).  Following this the variable is\n * automatically updated within vTaskDelayUntil ().\n *\n * @param xTimeIncrement The cycle time period.  The task will be unblocked at\n * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the\n * same xTimeIncrement parameter value will cause the task to execute with\n * a fixed interface period.\n *\n * Example usage:\n * @code{c}\n *  // Perform an action every 10 ticks.\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  TickType_t xLastWakeTime;\n *  const TickType_t xFrequency = 10;\n *\n * \t // Initialise the xLastWakeTime variable with the current time.\n * \t xLastWakeTime = xTaskGetTickCount ();\n * \t for( ;; )\n * \t {\n * \t\t // Wait for the next cycle.\n * \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );\n *\n * \t\t // Perform action here.\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the priority of any task.\n *\n * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to obtain the priority of the created task.\n *   // It was created with tskIDLE_PRIORITY, but may have changed\n *   // it itself.\n *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n *   {\n *       // The task has changed it's priority.\n *   }\n *\n *   // ...\n *\n *   // Is our priority higher than the created task?\n *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n *   {\n *       // Our priority (obtained using NULL handle) is higher.\n *   }\n * }\n * @endcode\n * \\ingroup TaskCtrl\n */\nUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * A version of uxTaskPriorityGet() that can be used from an ISR.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n */\nUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the state of any task.\n *\n * States are encoded by the eTaskState enumerated type.\n *\n * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.\n *\n * @return The state of xTask at the time the function was called.  Note the\n * state of the task might change between the function being called, and the\n * functions return value being tested by the calling task.\n */\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Set the priority of any task.\n *\n * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A context switch will occur before the function returns if the priority\n * being set is higher than the currently executing task.\n *\n * @param xTask Handle to the task for which the priority is being set.\n * Passing a NULL handle results in the priority of the calling task being set.\n *\n * @param uxNewPriority The priority to which the task will be set.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to raise the priority of the created task.\n *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n *\n *   // ...\n *\n *   // Use a NULL handle to raise our priority to the same value.\n *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\n/**\n * Suspend a task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * When suspended, a task will never get any microcontroller processing time,\n * no matter what its priority.\n *\n * Calls to vTaskSuspend are not accumulative -\n * i.e. calling vTaskSuspend () twice on the same task still only requires one\n * call to vTaskResume () to ready the suspended task.\n *\n * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n * handle will cause the calling task to be suspended.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Suspend ourselves.\n *   vTaskSuspend( NULL );\n *\n *   // We cannot get here unless another task calls vTaskResume\n *   // with our handle as the parameter.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes a suspended task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * vTaskResume ().\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Resume the suspended task ourselves.\n *   vTaskResume( xHandle );\n *\n *   // The created task will once again get microcontroller processing\n *   // time in accordance with its priority within the system.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/**\n * An implementation of vTaskResume() that can be called from within an ISR.\n *\n * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n * available.  See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * xTaskResumeFromISR ().\n *\n * xTaskResumeFromISR() should not be used to synchronise a task with an\n * interrupt if there is a chance that the interrupt could arrive prior to the\n * task being suspended - as this can lead to interrupts being missed. Use of a\n * semaphore as a synchronisation mechanism would avoid this eventuality.\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * @return pdTRUE if resuming the task should result in a context switch,\n * otherwise pdFALSE. This is used by the ISR to determine if a context switch\n * may be required following the ISR.\n *\n * \\ingroup TaskCtrl\n */\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n/** @cond */\n/**\n * Starts the real time kernel tick processing.\n *\n * After calling the kernel has control over which tasks are executed and when.\n *\n * See the demo application file main.c for an example of creating\n * tasks and starting the kernel.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will not get here unless a task calls vTaskEndScheduler ()\n *  }\n * @endcode\n *\n * \\ingroup SchedulerControl\n */\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Stops the real time kernel tick.\n *\n * @note At the time of writing only the x86 real mode port, which runs on a PC\n * in place of DOS, implements this function.\n *\n * All created tasks will be automatically deleted and multitasking\n * (either preemptive or cooperative) will stop.\n * Execution then resumes from the point where vTaskStartScheduler ()\n * was called, as if vTaskStartScheduler () had just returned.\n *\n * See the demo application file main. c in the demo/PC directory for an\n * example that uses vTaskEndScheduler ().\n *\n * vTaskEndScheduler () requires an exit function to be defined within the\n * portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n * performs hardware specific operations such as stopping the kernel tick.\n *\n * vTaskEndScheduler () will cause all of the resources allocated by the\n * kernel to be freed - but will not free resources allocated by application\n * tasks.\n *\n * Example usage:\n * @code{c}\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // At some point we want to end the real time kernel processing\n *       // so call ...\n *       vTaskEndScheduler ();\n *   }\n *  }\n *\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will only get here when the vTaskCode () task has called\n *   // vTaskEndScheduler ().  When we get here we are back to single task\n *   // execution.\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Suspends the scheduler without disabling interrupts.\n *\n * Context switches will not occur while the scheduler is suspended.\n *\n * After calling vTaskSuspendAll () the calling task will continue to execute\n * without risk of being swapped out until a call to xTaskResumeAll () has been\n * made.\n *\n * API functions that have the potential to cause a context switch (for example,\n * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n * is suspended.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the kernel\n *       // tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.\n *       xTaskResumeAll ();\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes scheduler activity after it was suspended by a call to\n * vTaskSuspendAll().\n *\n * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n * that were previously suspended by a call to vTaskSuspend().\n *\n * @return If resuming the scheduler caused a context switch then pdTRUE is\n *\t\t  returned, otherwise pdFALSE is returned.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the real\n *       // time kernel tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.  We want to force\n *       // a context switch - but there is no point if resuming the scheduler\n *       // caused a context switch already.\n *       if( !xTaskResumeAll () )\n *       {\n *            taskYIELD ();\n *       }\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\n/**\n * Get tick count\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get tick count from ISR\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * This is a version of xTaskGetTickCount() that is safe to be called from an\n * ISR - provided that TickType_t is the natural word size of the\n * microcontroller being used or interrupt nesting is either not supported or\n * not being used.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get current number of tasks\n *\n * @return The number of tasks that the real time kernel is currently managing.\n * This includes all ready, blocked and suspended tasks.  A task that\n * has been deleted but not yet freed by the idle task will also be\n * included in the count.\n *\n * \\ingroup TaskUtils\n */\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get task name\n *\n * @return The text (human readable) name of the task referenced by the handle\n * xTaskToQuery.  A task can query its own name by either passing in its own\n * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be\n * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.\n *\n * \\ingroup TaskUtils\n */\nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Returns the high water mark of the stack associated with xTask.\n *\n * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * High water mark is the minimum free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task started.\n * The smaller the returned number the closer the task has come to overflowing its stack.\n *\n * @param xTask Handle of the task associated with the stack to be checked.\n * Set xTask to NULL to check the stack of the calling task.\n *\n * @return The smallest amount of free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task referenced by\n * xTask was created.\n */\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Returns the start of the stack associated with xTask.\n *\n * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * Returns the highest stack memory address on architectures where the stack grows down\n * from high memory, and the lowest memory address on architectures where the\n * stack grows up from low memory.\n *\n * @param xTask Handle of the task associated with the stack returned.\n * Set xTask to NULL to return the stack of the calling task.\n *\n * @return A pointer to the start of the stack.\n */\nuint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n\t#if configUSE_APPLICATION_TASK_TAG == 1\n\t\t/**\n\t\t * Sets pxHookFunction to be the task hook function used by the task xTask.\n\t\t * @param xTask Handle of the task to set the hook function for\n\t\t *              Passing xTask as NULL has the effect of setting the calling\n\t\t *              tasks hook function.\n\t\t * @param pxHookFunction  Pointer to the hook function.\n\t\t */\n\t\tvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\n\t\t/**\n\t\t * Get the hook function assigned to given task.\n\t\t * @param xTask Handle of the task to get the hook function for\n\t\t *              Passing xTask as NULL has the effect of getting the calling\n\t\t *              tasks hook function.\n\t\t * @return The pxHookFunction value assigned to the task xTask.\n\t\t */\n\t\tTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\t#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )\n\n\t/**\n\t * Set local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t * @param xIndex The index of the pointer to set, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @param pvValue  Pointer value to set.\n\t */\n\tvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\n\n\n\t/**\n\t * Get local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToQuery  Task to get thread local storage pointer for\n\t * @param xIndex The index of the pointer to get, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @return  Pointer value\n\t */\n\tvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n\t#if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )\n\n\t\t/**\n\t\t * Prototype of local storage pointer deletion callback.\n\t\t */\n\t\ttypedef void (*TlsDeleteCallbackFunction_t)( int, void * );\n\n\t\t/**\n\t\t * Set local storage pointer and deletion callback.\n\t\t *\n\t\t * Each task contains an array of pointers that is dimensioned by the\n\t\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t\t * The kernel does not use the pointers itself, so the application writer\n\t\t * can use the pointers for any purpose they wish.\n\t\t *\n\t\t * Local storage pointers set for a task can reference dynamically\n\t\t * allocated resources. This function is similar to\n\t\t * vTaskSetThreadLocalStoragePointer, but provides a way to release\n\t\t * these resources when the task gets deleted. For each pointer,\n\t\t * a callback function can be set. This function will be called\n\t\t * when task is deleted, with the local storage pointer index\n\t\t * and value as arguments.\n\t\t *\n\t\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t\t * @param xIndex The index of the pointer to set, from 0 to\n\t\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t\t * @param pvValue  Pointer value to set.\n\t\t * @param pvDelCallback  Function to call to dispose of the local\n\t\t *                       storage pointer when the task is deleted.\n\t\t */\n\t\tvoid vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue, TlsDeleteCallbackFunction_t pvDelCallback);\n\t#endif\n\n#endif\n\n/**\n * Calls the hook function associated with xTask. Passing xTask as NULL has\n * the effect of calling the Running tasks (the calling task) hook function.\n *\n * @param xTask  Handle of the task to call the hook for.\n * @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n * wants.  The return value is the value returned by the task hook function\n * registered by the user.\n */\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\n/**\n * Get the handle of idle task for the current CPU.\n *\n * xTaskGetIdleTaskHandle() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @return The handle of the idle task.  It is not valid to call\n * xTaskGetIdleTaskHandle() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandle( void );\n\n/**\n * Get the handle of idle task for the given CPU.\n *\n * xTaskGetIdleTaskHandleForCPU() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @param cpuid The CPU to get the handle for\n *\n * @return Idle task handle of a given cpu. It is not valid to call\n * xTaskGetIdleTaskHandleForCPU() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandleForCPU( UBaseType_t cpuid );\n\n/**\n * Get the state of tasks in the system.\n *\n * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n * uxTaskGetSystemState() to be available.\n *\n * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n * the system.  TaskStatus_t structures contain, among other things, members\n * for the task handle, task name, task priority, task state, and total amount\n * of run time consumed by the task.  See the TaskStatus_t structure\n * definition in this file for the full member list.\n *\n * @note  This function is intended for debugging use only as its use results in\n * the scheduler remaining suspended for an extended period.\n *\n * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n * The array must contain at least one TaskStatus_t structure for each task\n * that is under the control of the RTOS.  The number of tasks under the control\n * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n *\n * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n * parameter.  The size is specified as the number of indexes in the array, or\n * the number of TaskStatus_t structures contained in the array, not by the\n * number of bytes in the array.\n *\n * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n * total run time (as defined by the run time stats clock, see\n * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.\n * pulTotalRunTime can be set to NULL to omit the total run time information.\n *\n * @return The number of TaskStatus_t structures that were populated by\n * uxTaskGetSystemState().  This should equal the number returned by the\n * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n * in the uxArraySize parameter was too small.\n *\n * Example usage:\n * @code{c}\n * // This example demonstrates how a human readable table of run time stats\n * // information is generated from raw data provided by uxTaskGetSystemState().\n * // The human readable table is written to pcWriteBuffer\n * void vTaskGetRunTimeStats( char *pcWriteBuffer )\n * {\n * TaskStatus_t *pxTaskStatusArray;\n * volatile UBaseType_t uxArraySize, x;\n * uint32_t ulTotalRunTime, ulStatsAsPercentage;\n *\n *  // Make sure the write buffer does not contain a string.\n *  *pcWriteBuffer = 0x00;\n *\n *  // Take a snapshot of the number of tasks in case it changes while this\n *  // function is executing.\n *  uxArraySize = uxTaskGetNumberOfTasks();\n *\n *  // Allocate a TaskStatus_t structure for each task.  An array could be\n *  // allocated statically at compile time.\n *  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n *\n *  if( pxTaskStatusArray != NULL )\n *  {\n *      // Generate raw status information about each task.\n *      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n *\n *      // For percentage calculations.\n *      ulTotalRunTime /= 100UL;\n *\n *      // Avoid divide by zero errors.\n *      if( ulTotalRunTime > 0 )\n *      {\n *          // For each populated position in the pxTaskStatusArray array,\n *          // format the raw data as human readable ASCII data\n *          for( x = 0; x < uxArraySize; x++ )\n *          {\n *              // What percentage of the total run time has the task used?\n *              // This will always be rounded down to the nearest integer.\n *              // ulTotalRunTimeDiv100 has already been divided by 100.\n *              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n *\n *              if( ulStatsAsPercentage > 0UL )\n *              {\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n *              }\n *              else\n *              {\n *                  // If the percentage is zero here then the task has\n *                  // consumed less than 1% of the total run time.\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n *              }\n *\n *              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n *          }\n *      }\n *\n *      // The array is no longer needed, free the memory it consumes.\n *      vPortFree( pxTaskStatusArray );\n *  }\n * }\n * @endcode\n */\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );\n\n/**\n * List all the current tasks.\n *\n * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n * both be defined as 1 for this function to be available.  See the\n * configuration section of the FreeRTOS.org website for more information.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Lists all the current tasks, along with their current state and stack\n * usage high water mark.\n *\n * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n * suspended ('S').\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays task\n * names, states and stack usage.\n *\n * vTaskList() has a dependency on the sprintf() C library function that might\n * bloat the code size, use a lot of stack, and provide different results on\n * different platforms.  An alternative, tiny, third party, and limited\n * functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState()\n * directly to get access to raw stats data, rather than indirectly through a\n * call to vTaskList().\n *\n * @param pcWriteBuffer A buffer into which the above mentioned details\n * will be written, in ASCII form.  This buffer is assumed to be large\n * enough to contain the generated report.  Approximately 40 bytes per\n * task should be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Get the state of running tasks as a string\n *\n * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n * must both be defined as 1 for this function to be available.  The application\n * must also then provide definitions for\n * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n * to configure a peripheral timer/counter and return the timers current count\n * value respectively.  The counter should be at least 10 times the frequency of\n * the tick count.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n * accumulated execution time being stored for each task.  The resolution\n * of the accumulated time value depends on the frequency of the timer\n * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n * Calling vTaskGetRunTimeStats() writes the total execution time of each\n * task into a buffer, both as an absolute count value and as a percentage\n * of the total system execution time.\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays the\n * amount of time each task has spent in the Running state in both absolute and\n * percentage terms.\n *\n * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n * that might bloat the code size, use a lot of stack, and provide different\n * results on different platforms.  An alternative, tiny, third party, and\n * limited functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState() directly\n * to get access to raw stats data, rather than indirectly through a call to\n * vTaskGetRunTimeStats().\n *\n * @param pcWriteBuffer A buffer into which the execution times will be\n * written, in ASCII form.  This buffer is assumed to be large enough to\n * contain the generated report.  Approximately 40 bytes per task should\n * be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Send task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\tupdated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\n/**\n * Send task notification from an ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotify() that can be used from an interrupt service routine\n * (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n * be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Wait for task notification\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n * will be cleared in the calling task's notification value before the task\n * checks to see if any notifications are pending, and optionally blocks if no\n * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n * the effect of resetting the task's notification value to 0.  Setting\n * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n *\n * @param ulBitsToClearOnExit If a notification is pending or received before\n * the calling task exits the xTaskNotifyWait() function then the task's\n * notification value (see the xTaskNotify() API function) is passed out using\n * the pulNotificationValue parameter.  Then any bits that are set in\n * ulBitsToClearOnExit will be cleared in the task's notification value (note\n * *pulNotificationValue is set before any bits are cleared).  Setting\n * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n * (if limits.h is not included) will have the effect of resetting the task's\n * notification value to 0 before the function exits.  Setting\n * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n * when the function exits (in which case the value passed out in\n * pulNotificationValue will match the task's notification value).\n *\n * @param pulNotificationValue Used to pass the task's notification value out\n * of the function.  Note the value passed out will not be effected by the\n * clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for a notification to be received, should a notification\n * not already be pending when xTaskNotifyWait() was called.  The task\n * will not consume any processing time while it is in the Blocked state.  This\n * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be\n * used to convert a time specified in milliseconds to a time specified in\n * ticks.\n *\n * @return If a notification was received (including notifications that were\n * already pending when xTaskNotifyWait was called) then pdPASS is\n * returned.  Otherwise pdFAIL is returned.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n/**\n * Simplified macro for sending task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * xTaskNotifyGive() is a helper macro intended for use when task notifications\n * are used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,\n * the equivalent action that instead uses a task notification is\n * xTaskNotifyGive().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the\n * eAction parameter set to eIncrement - so pdPASS is always returned.\n *\n * \\ingroup TaskNotifications\n */\n#define xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )\n\n/**\n * Simplified macro for sending task notification from ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotifyGive() that can be called from an interrupt service\n * routine (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * vTaskNotifyGiveFromISR() is intended for use when task notifications are\n * used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given from an ISR using the\n * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n * a task notification is vTaskNotifyGiveFromISR().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n * should be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * \\ingroup TaskNotifications\n */\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Simplified macro for receiving task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * ulTaskNotifyTake() is intended for use when a task notification is used as a\n * faster and lighter weight binary or counting semaphore alternative.  Actual\n * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the\n * equivalent action that instead uses a task notification is\n * ulTaskNotifyTake().\n *\n * When a task is using its notification value as a binary or counting semaphore\n * other tasks should send notifications to it using the xTaskNotifyGive()\n * macro, or xTaskNotify() function with the eAction parameter set to\n * eIncrement.\n *\n * ulTaskNotifyTake() can either clear the task's notification value to\n * zero on exit, in which case the notification value acts like a binary\n * semaphore, or decrement the task's notification value on exit, in which case\n * the notification value acts like a counting semaphore.\n *\n * A task can use ulTaskNotifyTake() to [optionally] block to wait for a\n * the task's notification value to be non-zero.  The task does not consume any\n * CPU time while it is in the Blocked state.\n *\n * Where as xTaskNotifyWait() will return when a notification is pending,\n * ulTaskNotifyTake() will return when the task's notification value is\n * not zero.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n * notification value is decremented when the function exits.  In this way the\n * notification value acts like a counting semaphore.  If xClearCountOnExit is\n * not pdFALSE then the task's notification value is cleared to zero when the\n * function exits.  In this way the notification value acts like a binary\n * semaphore.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for the task's notification value to be greater than zero,\n * should the count not already be greater than zero when\n * ulTaskNotifyTake() was called.  The task will not consume any processing\n * time while it is in the Blocked state.  This is specified in kernel ticks,\n * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time\n * specified in milliseconds to a time specified in ticks.\n *\n * @return The task's notification count before it is either cleared to zero or\n * decremented (see the xClearCountOnExit parameter).\n *\n * \\ingroup TaskNotifications\n */\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n/** @cond */\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * xTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n * Return the handle of the task running on a certain CPU. Because of\n * the nature of SMP processing, there is no guarantee that this\n * value will still be valid on return and should only be used for\n * debugging purposes.\n */\nTaskHandle_t xTaskGetCurrentTaskHandleForCPU( BaseType_t cpuid );\n\n\n/*\n * Capture the current time status for future reference.\n */\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n/*\n * Compare the time status now with that previously captured to see if the\n * timeout has expired.\n */\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n\n/*\n * Get the current core affinity of a task\n */\nBaseType_t xTaskGetAffinity( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/*\n * Only avilable when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nvoid *pvTaskIncrementMutexHeldCount( void );\n\n/*\n * This function fills array with TaskSnapshot_t structures for every task in the system.\n * Used by core dump facility to get snapshots of all tasks in the system.\n * Only available when configENABLE_TASK_SNAPSHOT is set to 1.\n * @param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.\n * @param uxArraySize Size of tasks snapshots array.\n * @param pxTcbSz Pointer to store size of TCB.\n * @return Number of elements stored in array.\n */\nUBaseType_t uxTaskGetSnapshotAll( TaskSnapshot_t * const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t * const pxTcbSz );\n\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n\n\n\n"}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h"}}}
>>>
Content-Length: 205

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":365,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":30}}}
>>>
Content-Length: 40

{"id":365,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":718}}}Content-Length: 361

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":719},"contentChanges":[{"range":{"start":{"line":240,"character":0},"end":{"line":240,"character":0}},"rangeLength":0,"text":"    Serial.println(uxTaskGetStackHighWaterMark(NULL));\n"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":366,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":19},"end":{"line":240,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":366,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":719}}}Content-Length: 285

{"jsonrpc":"2.0","id":367,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":19},"end":{"line":240,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":367,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":720},"contentChanges":[{"range":{"start":{"line":239,"character":19},"end":{"line":240,"character":19}},"rangeLength":39,"text":""}]}}
>>>
Content-Length: 521

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":239,"character":17},"end":{"line":239,"character":54}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":216,"character":29},"end":{"line":216,"character":30}},"severity":3,"message":"To match this '{'\n\nEsp_Master.ino.cpp:323:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 457

{"jsonrpc":"2.0","id":368,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":19},"end":{"line":239,"character":19}},"context":{"diagnostics":[{"range":{"start":{"line":239,"character":17},"end":{"line":239,"character":54}},"message":"Expected expression","severity":1,"code":"expected_expression","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":368,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 348

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":721},"contentChanges":[{"range":{"start":{"line":239,"character":19},"end":{"line":239,"character":19}},"rangeLength":0,"text":"Overflow Stack :\");\n    Serial.println("}]}}
>>>
Content-Length: 175

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":721}}}Content-Length: 285

{"jsonrpc":"2.0","id":369,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":19},"end":{"line":240,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":369,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":370,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":19}}}
>>>
Content-Length: 38

{"id":370,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":371,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":19},"end":{"line":239,"character":19}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":371,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":372,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":16},"end":{"line":239,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":372,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":373,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":16}}}
>>>
Content-Length: 849

{"id":373,"result":[{"range":{"start":{"line":107,"character":9},"end":{"line":107,"character":14}},"kind":1},{"range":{"start":{"line":109,"character":9},"end":{"line":109,"character":14}},"kind":1},{"range":{"start":{"line":111,"character":9},"end":{"line":111,"character":14}},"kind":1},{"range":{"start":{"line":113,"character":9},"end":{"line":113,"character":14}},"kind":1},{"range":{"start":{"line":115,"character":9},"end":{"line":115,"character":14}},"kind":1},{"range":{"start":{"line":117,"character":9},"end":{"line":117,"character":14}},"kind":1},{"range":{"start":{"line":128,"character":9},"end":{"line":128,"character":14}},"kind":1},{"range":{"start":{"line":218,"character":11},"end":{"line":218,"character":16}},"kind":1},{"range":{"start":{"line":239,"character":11},"end":{"line":239,"character":16}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":374,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":16},"end":{"line":239,"character":16}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":374,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":722},"contentChanges":[{"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":24}},"rangeLength":0,"text":" "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":375,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":25},"end":{"line":218,"character":25}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":375,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":722}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":723},"contentChanges":[{"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":25}},"rangeLength":1,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":376,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":218,"character":24},"end":{"line":218,"character":24}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":376,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":723}}}Content-Length: 210

{"jsonrpc":"2.0","id":377,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":25}}}
>>>
Content-Length: 279

{"id":377,"result":{"contents":{"kind":"markdown","value":"### macro `portTICK_PERIOD_MS`  \n\n---\n```cpp\n#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)\n```"},"range":{"start":{"line":272,"character":19},"end":{"line":272,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":378,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":26}}}
>>>
Content-Length: 128

{"id":378,"result":[{"range":{"start":{"line":240,"character":19},"end":{"line":240,"character":46}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":379,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":26}}}
>>>
Content-Length: 1078

{"id":379,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":275,"character":19},"end":{"line":275,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":380,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":26},"end":{"line":240,"character":26}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":380,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":381,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":26}}}
>>>
Content-Length: 238

{"id":381,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","range":{"start":{"line":1346,"character":12},"end":{"line":1346,"character":39}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 98387

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n\t***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\t***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n\tthe FAQ page \"My application does not run, what could be wrong?\".  Have you\n\tdefined configASSERT()?\n\n\thttp://www.FreeRTOS.org/support - In return for receiving this top quality\n\tembedded software for free we request you assist our global community by\n\tparticipating in the support forum.\n\n\thttp://www.FreeRTOS.org/training - Investing in training allows your team to\n\tbe as productive as possible as early as possible.  Now you can receive\n\tFreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n\tLtd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n\t#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include <limits.h>\n\n#include \"list.h\"\n#include \"portmacro.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V8.2.0\"\n#define tskKERNEL_VERSION_MAJOR 8\n#define tskKERNEL_VERSION_MINOR 2\n#define tskKERNEL_VERSION_BUILD 0\n\n/**\n * @brief Argument of xTaskCreatePinnedToCore indicating that task has no affinity\n */\n#define tskNO_AFFINITY INT_MAX\n\n/**\n * task. h\n *\n * Type by which tasks are referenced.  For example, a call to xTaskCreate\n * returns (via a pointer parameter) an TaskHandle_t variable that can then\n * be used as a parameter to vTaskDelete to delete the task.\n *\n * \\ingroup Tasks\n */\ntypedef void * TaskHandle_t;\n\n/**\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/** Task states returned by eTaskGetState. */\ntypedef enum\n{\n\teRunning = 0,\t/*!< A task is querying the state of itself, so must be running. */\n\teReady,\t\t\t/*!< The task being queried is in a read or pending ready list. */\n\teBlocked,\t\t/*!< The task being queried is in the Blocked state. */\n\teSuspended,\t\t/*!< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\n\teDeleted\t\t/*!< The task being queried has been deleted, but its TCB has not yet been freed. */\n} eTaskState;\n\n/** Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\n\teNoAction = 0,\t\t\t\t/*!< Notify the task without updating its notify value. */\n\teSetBits,\t\t\t\t\t/*!< Set bits in the task's notification value. */\n\teIncrement,\t\t\t\t\t/*!< Increment the task's notification value. */\n\teSetValueWithOverwrite,\t\t/*!< Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n\teSetValueWithoutOverwrite\t/*!< Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/** @cond */\n/**\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\n\tBaseType_t xOverflowCount;\n\tTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/**\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\n\tvoid *pvBaseAddress;\n\tuint32_t ulLengthInBytes;\n\tuint32_t ulParameters;\n} MemoryRegion_t;\n\n/**\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\n\tTaskFunction_t pvTaskCode;\n\tconst char * const pcName;\t/*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tuint32_t usStackDepth;\n\tvoid *pvParameters;\n\tUBaseType_t uxPriority;\n\tStackType_t *puxStackBuffer;\n\tMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n} TaskParameters_t;\n/** @endcond */\n\n/**\n *  Used with the uxTaskGetSystemState() function to return the state of each task in the system.\n*/\ntypedef struct xTASK_STATUS\n{\n\tTaskHandle_t xHandle;\t\t\t/*!< The handle of the task to which the rest of the information in the structure relates. */\n\tconst char *pcTaskName;\t\t\t/*!< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tUBaseType_t xTaskNumber;\t\t/*!< A number unique to the task. */\n\teTaskState eCurrentState;\t\t/*!< The state in which the task existed when the structure was populated. */\n\tUBaseType_t uxCurrentPriority;\t/*!< The priority at which the task was running (may be inherited) when the structure was populated. */\n\tUBaseType_t uxBasePriority;\t\t/*!< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\n\tuint32_t ulRunTimeCounter;\t\t/*!< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\n\tStackType_t *pxStackBase;\t\t/*!< Points to the lowest address of the task's stack area. */\n\tuint32_t usStackHighWaterMark;\t/*!< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n#if configTASKLIST_INCLUDE_COREID\n\tBaseType_t xCoreID;\t\t\t\t/*!< Core this task is pinned to. This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. */\n#endif\n} TaskStatus_t;\n\n/**\n * Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n * We need this struct because TCB_t is defined (hidden) in tasks.c.\n */\ntypedef struct xTASK_SNAPSHOT\n{\n\tvoid        *pxTCB;         /*!< Address of task control block. */\n\tStackType_t *pxTopOfStack;  /*!< Points to the location of the last item placed on the tasks stack. */\n\tStackType_t *pxEndOfStack;  /*!< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\n\t\t\t\t\t\t\t\t\tpxTopOfStack > pxEndOfStack, stack grows lo2hi*/\n} TaskSnapshot_t;\n\n/**\n * Possible return values for eTaskConfirmSleepModeStatus().\n */\ntypedef enum\n{\n\teAbortSleep = 0,\t\t/*!< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\n\teStandardSleep,\t\t\t/*!< Enter a sleep mode that will not last any longer than the expected idle time. */\n\teNoTasksWaitingTimeout\t/*!< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n\n/**\n * Defines the priority used by the idle task.  This must not be modified.\n *\n * \\ingroup TaskUtils\n */\n#define tskIDLE_PRIORITY\t\t\t( ( UBaseType_t ) 0U )\n\n/**\n * task. h\n *\n * Macro for forcing a context switch.\n *\n * \\ingroup SchedulerControl\n */\n#define taskYIELD()\t\t\t\t\tportYIELD()\n\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskENTER_CRITICAL(mux)\t\tportENTER_CRITICAL(mux)\n#else\n#define taskENTER_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskENTER_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portENTER_CRITICAL(mux)'\\\"\") portENTER_CRITICAL(mux)\n#endif\n#define taskENTER_CRITICAL_ISR(mux)\t\tportENTER_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskEXIT_CRITICAL(mux)\t\t\tportEXIT_CRITICAL(mux)\n#else\n#define taskEXIT_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskEXIT_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portEXIT_CRITICAL(mux)'\\\"\") portEXIT_CRITICAL(mux)\n#endif\n#define taskEXIT_CRITICAL_ISR(mux)\t\tportEXIT_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to disable all maskable interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskDISABLE_INTERRUPTS()\tportDISABLE_INTERRUPTS()\n\n/**\n * task. h\n *\n * Macro to enable microcontroller interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskENABLE_INTERRUPTS()\t\tportENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED\t\t( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED\t( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING\t\t( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreate, but allows setting task affinity\n * in SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\tBaseType_t xTaskCreatePinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\tconst uint32_t usStackDepth,\n\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\tTaskHandle_t * const pvCreatedTask,\n\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID);\n\n#endif\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * See xTaskCreateStatic() for a version that does not use any dynamic memory\n * allocation.\n *\n * xTaskCreate() can only be used to create a task that has unrestricted\n * access to the entire microcontroller memory map.  Systems that include MPU\n * support can alternatively create an MPU constrained task using\n * xTaskCreateRestricted().\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *  // Task to be created.\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *   }\n *  }\n *\n *  // Function that creates a task.\n *  void vOtherFunction( void )\n *  {\n *  static uint8_t ucParameterToPass;\n *  TaskHandle_t xHandle = NULL;\n *\n *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass\n *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an\n *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time\n *   // the new task attempts to access it.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\n *      configASSERT( xHandle );\n *\n *   // Use the handle to delete the task.\n *      if( xHandle != NULL )\n *      {\n *       vTaskDelete( xHandle );\n *      }\n *  }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tstatic inline IRAM_ATTR BaseType_t xTaskCreate(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t usStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tTaskHandle_t * const pvCreatedTask)\n\t{\n\t\treturn xTaskCreatePinnedToCore( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask, tskNO_AFFINITY );\n\t}\n\n#endif\n\n\n\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreateStatic, but allows specifying\n * task affinity in an SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tTaskHandle_t xTaskCreateStaticPinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth,\n\t\t\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\t\t\tStackType_t * const pxStackBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tStaticTask_t * const pxTaskBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID );\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *\n *     // Dimensions the buffer that the task being created will use as its stack.\n *     // NOTE:  This is the number of bytes the stack will hold, not the number of\n *     // words as found in vanilla FreeRTOS.\n *     #define STACK_SIZE 200\n *\n *     // Structure that will hold the TCB of the task being created.\n *     StaticTask_t xTaskBuffer;\n *\n *     // Buffer that the task being created will use as its stack.  Note this is\n *     // an array of StackType_t variables.  The size of StackType_t is dependent on\n *     // the RTOS port.\n *     StackType_t xStack[ STACK_SIZE ];\n *\n *     // Function that implements the task being created.\n *     void vTaskCode( void * pvParameters )\n *     {\n *         // The parameter value is expected to be 1 as 1 is passed in the\n *         // pvParameters value in the call to xTaskCreateStatic().\n *         configASSERT( ( uint32_t ) pvParameters == 1UL );\n *\n *         for( ;; )\n *         {\n *             // Task code goes here.\n *         }\n *     }\n *\n *     // Function that creates a task.\n *     void vOtherFunction( void )\n *     {\n *         TaskHandle_t xHandle = NULL;\n *\n *         // Create the task without using any dynamic memory allocation.\n *         xHandle = xTaskCreateStatic(\n *                       vTaskCode,       // Function that implements the task.\n *                       \"NAME\",          // Text name for the task.\n *                       STACK_SIZE,      // Stack size in bytes, not words.\n *                       ( void * ) 1,    // Parameter passed into the task.\n *                       tskIDLE_PRIORITY,// Priority at which the task is created.\n *                       xStack,          // Array to use as the task's stack.\n *                       &xTaskBuffer );  // Variable to hold the task's data structure.\n *\n *         // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have\n *         // been created, and xHandle will be the task's handle.  Use the handle\n *         // to suspend the task.\n *         vTaskSuspend( xHandle );\n *     }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tstatic inline IRAM_ATTR TaskHandle_t xTaskCreateStatic(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t ulStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tStackType_t * const pxStackBuffer,\n\t\t\tStaticTask_t * const pxTaskBuffer)\n\t{\n\t\treturn xTaskCreateStaticPinnedToCore( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxStackBuffer, pxTaskBuffer, tskNO_AFFINITY );\n\t}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/** @cond */\n/**\n * xTaskCreateRestricted() should only be used in systems that include an MPU\n * implementation.\n *\n * Create a new task and add it to the list of tasks that are ready to run.\n * The function parameters define the memory regions and associated access\n * permissions allocated to the task.\n *\n * @param pxTaskDefinition Pointer to a structure that contains a member\n * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API\n * documentation) plus an optional stack buffer and the memory region\n * definitions.\n *\n * @param pxCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * Example usage:\n * @code{c}\n * // Create an TaskParameters_t structure that defines the task to be created.\n * static const TaskParameters_t xCheckTaskParameters =\n * {\n * \tvATask,\t\t// pvTaskCode - the function that implements the task.\n * \t\"ATask\",\t// pcName - just a text name for the task to assist debugging.\n * \t100,\t\t// usStackDepth\t- the stack size DEFINED IN BYTES.\n * \tNULL,\t\t// pvParameters - passed into the task function as the function parameters.\n * \t( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.\n * \tcStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\n *\n * \t// xRegions - Allocate up to three separate memory regions for access by\n * \t// the task, with appropriate access permissions.  Different processors have\n * \t// different memory alignment requirements - refer to the FreeRTOS documentation\n * \t// for full information.\n * \t{\n * \t\t// Base address\t\t\t\t\tLength\tParameters\n *         { cReadWriteArray,\t\t\t\t32,\t\tportMPU_REGION_READ_WRITE },\n *         { cReadOnlyArray,\t\t\t\t32,\t\tportMPU_REGION_READ_ONLY },\n *         { cPrivilegedOnlyAccessArray,\t128,\tportMPU_REGION_PRIVILEGED_READ_WRITE }\n * \t}\n * };\n *\n * int main( void )\n * {\n * TaskHandle_t xHandle;\n *\n * \t// Create a task from the const structure defined above.  The task handle\n * \t// is requested (the second parameter is not NULL) but in this case just for\n * \t// demonstration purposes as its not actually used.\n * \txTaskCreateRestricted( &xRegTest1Parameters, &xHandle );\n *\n * \t// Start the scheduler.\n * \tvTaskStartScheduler();\n *\n * \t// Will only get here if there was insufficient memory to create the idle\n * \t// and/or timer task.\n * \tfor( ;; );\n * }\n * @endcode\n * \\ingroup Tasks\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n\tBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n\n/**\n * Memory regions are assigned to a restricted task when the task is created by\n * a call to xTaskCreateRestricted().  These regions can be redefined using\n * vTaskAllocateMPURegions().\n *\n * @param xTask The handle of the task being updated.\n *\n * @param xRegions A pointer to an MemoryRegion_t structure that contains the\n * new memory region definitions.\n *\n * Example usage:\n *\n * @code{c}\n * // Define an array of MemoryRegion_t structures that configures an MPU region\n * // allowing read/write access for 1024 bytes starting at the beginning of the\n * // ucOneKByte array.  The other two of the maximum 3 definable regions are\n * // unused so set to zero.\n * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n * {\n * \t// Base address\t\tLength\t\tParameters\n * \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },\n * \t{ 0,\t\t\t\t0,\t\t\t0 },\n * \t{ 0,\t\t\t\t0,\t\t\t0 }\n * };\n *\n * void vATask( void *pvParameters )\n * {\n * \t// This task was created such that it has access to certain regions of\n * \t// memory as defined by the MPU configuration.  At some point it is\n * \t// desired that these MPU regions are replaced with that defined in the\n * \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n * \t// for this purpose.  NULL is used as the task handle to indicate that this\n * \t// function should modify the MPU regions of the calling task.\n * \tvTaskAllocateMPURegions( NULL, xAltRegions );\n *\n * \t// Now the task can continue its function, but from this point on can only\n * \t// access its stack and the ucOneKByte array (unless any other statically\n * \t// defined or shared regions have been declared elsewhere).\n * }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Remove a task from the RTOS real time kernel's management.\n *\n * The task being deleted will be removed from all ready, blocked, suspended\n * and event lists.\n *\n * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @note The idle task is responsible for freeing the kernel allocated\n * memory from tasks that have been deleted.  It is therefore important that\n * the idle task is not starved of microcontroller processing time if your\n * application makes any calls to vTaskDelete ().  Memory allocated by the\n * task code is not automatically freed, and should be freed before the task\n * is deleted.\n *\n * See the demo application file death.c for sample code that utilises\n * vTaskDelete ().\n *\n * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n * cause the calling task to be deleted.\n *\n * Example usage:\n * @code{c}\n *  void vOtherFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n * \t // Create the task, storing the handle.\n * \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n * \t // Use the handle to delete the task.\n * \t vTaskDelete( xHandle );\n *  }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\n/**\n * Delay a task for a given number of ticks.\n *\n * The actual time that the task remains blocked depends on the tick rate.\n * The constant portTICK_PERIOD_MS can be used to calculate real time from\n * the tick rate - with the resolution of one tick period.\n *\n * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * vTaskDelay() specifies a time at which the task wishes to unblock relative to\n * the time at which vTaskDelay() is called.  For example, specifying a block\n * period of 100 ticks will cause the task to unblock 100 ticks after\n * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n * of controlling the frequency of a periodic task as the path taken through the\n * code, as well as other task and interrupt activity, will effect the frequency\n * at which vTaskDelay() gets called and therefore the time at which the task\n * next executes.  See vTaskDelayUntil() for an alternative API function designed\n * to facilitate fixed frequency execution.  It does this by specifying an\n * absolute time (rather than a relative time) at which the calling task should\n * unblock.\n *\n * @param xTicksToDelay The amount of time, in tick periods, that\n * the calling task should block.\n *\n * Example usage:\n * @code{c}\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  // Block for 500ms.\n *  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n *\n * \t for( ;; )\n * \t {\n * \t\t // Simply toggle the LED every 500ms, blocking between each toggle.\n * \t\t vToggleLED();\n * \t\t vTaskDelay( xDelay );\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\n/**\n * Delay a task until a specified time.\n *\n * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * This function can be used by periodic tasks to ensure a constant execution frequency.\n *\n * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n * cause a task to block for the specified number of ticks from the time vTaskDelay () is\n * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n * execution frequency as the time between a task starting to execute and that task\n * calling vTaskDelay () may not be fixed [the task may take a different path though the\n * code between calls, or may get interrupted or preempted a different number of times\n * each time it executes].\n *\n * Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n * unblock.\n *\n * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick\n * rate - with the resolution of one tick period.\n *\n * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n * task was last unblocked.  The variable must be initialised with the current time\n * prior to its first use (see the example below).  Following this the variable is\n * automatically updated within vTaskDelayUntil ().\n *\n * @param xTimeIncrement The cycle time period.  The task will be unblocked at\n * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the\n * same xTimeIncrement parameter value will cause the task to execute with\n * a fixed interface period.\n *\n * Example usage:\n * @code{c}\n *  // Perform an action every 10 ticks.\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  TickType_t xLastWakeTime;\n *  const TickType_t xFrequency = 10;\n *\n * \t // Initialise the xLastWakeTime variable with the current time.\n * \t xLastWakeTime = xTaskGetTickCount ();\n * \t for( ;; )\n * \t {\n * \t\t // Wait for the next cycle.\n * \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );\n *\n * \t\t // Perform action here.\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the priority of any task.\n *\n * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to obtain the priority of the created task.\n *   // It was created with tskIDLE_PRIORITY, but may have changed\n *   // it itself.\n *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n *   {\n *       // The task has changed it's priority.\n *   }\n *\n *   // ...\n *\n *   // Is our priority higher than the created task?\n *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n *   {\n *       // Our priority (obtained using NULL handle) is higher.\n *   }\n * }\n * @endcode\n * \\ingroup TaskCtrl\n */\nUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * A version of uxTaskPriorityGet() that can be used from an ISR.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n */\nUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the state of any task.\n *\n * States are encoded by the eTaskState enumerated type.\n *\n * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.\n *\n * @return The state of xTask at the time the function was called.  Note the\n * state of the task might change between the function being called, and the\n * functions return value being tested by the calling task.\n */\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Set the priority of any task.\n *\n * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A context switch will occur before the function returns if the priority\n * being set is higher than the currently executing task.\n *\n * @param xTask Handle to the task for which the priority is being set.\n * Passing a NULL handle results in the priority of the calling task being set.\n *\n * @param uxNewPriority The priority to which the task will be set.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to raise the priority of the created task.\n *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n *\n *   // ...\n *\n *   // Use a NULL handle to raise our priority to the same value.\n *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\n/**\n * Suspend a task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * When suspended, a task will never get any microcontroller processing time,\n * no matter what its priority.\n *\n * Calls to vTaskSuspend are not accumulative -\n * i.e. calling vTaskSuspend () twice on the same task still only requires one\n * call to vTaskResume () to ready the suspended task.\n *\n * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n * handle will cause the calling task to be suspended.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Suspend ourselves.\n *   vTaskSuspend( NULL );\n *\n *   // We cannot get here unless another task calls vTaskResume\n *   // with our handle as the parameter.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes a suspended task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * vTaskResume ().\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Resume the suspended task ourselves.\n *   vTaskResume( xHandle );\n *\n *   // The created task will once again get microcontroller processing\n *   // time in accordance with its priority within the system.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/**\n * An implementation of vTaskResume() that can be called from within an ISR.\n *\n * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n * available.  See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * xTaskResumeFromISR ().\n *\n * xTaskResumeFromISR() should not be used to synchronise a task with an\n * interrupt if there is a chance that the interrupt could arrive prior to the\n * task being suspended - as this can lead to interrupts being missed. Use of a\n * semaphore as a synchronisation mechanism would avoid this eventuality.\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * @return pdTRUE if resuming the task should result in a context switch,\n * otherwise pdFALSE. This is used by the ISR to determine if a context switch\n * may be required following the ISR.\n *\n * \\ingroup TaskCtrl\n */\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n/** @cond */\n/**\n * Starts the real time kernel tick processing.\n *\n * After calling the kernel has control over which tasks are executed and when.\n *\n * See the demo application file main.c for an example of creating\n * tasks and starting the kernel.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will not get here unless a task calls vTaskEndScheduler ()\n *  }\n * @endcode\n *\n * \\ingroup SchedulerControl\n */\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Stops the real time kernel tick.\n *\n * @note At the time of writing only the x86 real mode port, which runs on a PC\n * in place of DOS, implements this function.\n *\n * All created tasks will be automatically deleted and multitasking\n * (either preemptive or cooperative) will stop.\n * Execution then resumes from the point where vTaskStartScheduler ()\n * was called, as if vTaskStartScheduler () had just returned.\n *\n * See the demo application file main. c in the demo/PC directory for an\n * example that uses vTaskEndScheduler ().\n *\n * vTaskEndScheduler () requires an exit function to be defined within the\n * portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n * performs hardware specific operations such as stopping the kernel tick.\n *\n * vTaskEndScheduler () will cause all of the resources allocated by the\n * kernel to be freed - but will not free resources allocated by application\n * tasks.\n *\n * Example usage:\n * @code{c}\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // At some point we want to end the real time kernel processing\n *       // so call ...\n *       vTaskEndScheduler ();\n *   }\n *  }\n *\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will only get here when the vTaskCode () task has called\n *   // vTaskEndScheduler ().  When we get here we are back to single task\n *   // execution.\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Suspends the scheduler without disabling interrupts.\n *\n * Context switches will not occur while the scheduler is suspended.\n *\n * After calling vTaskSuspendAll () the calling task will continue to execute\n * without risk of being swapped out until a call to xTaskResumeAll () has been\n * made.\n *\n * API functions that have the potential to cause a context switch (for example,\n * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n * is suspended.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the kernel\n *       // tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.\n *       xTaskResumeAll ();\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes scheduler activity after it was suspended by a call to\n * vTaskSuspendAll().\n *\n * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n * that were previously suspended by a call to vTaskSuspend().\n *\n * @return If resuming the scheduler caused a context switch then pdTRUE is\n *\t\t  returned, otherwise pdFALSE is returned.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the real\n *       // time kernel tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.  We want to force\n *       // a context switch - but there is no point if resuming the scheduler\n *       // caused a context switch already.\n *       if( !xTaskResumeAll () )\n *       {\n *            taskYIELD ();\n *       }\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\n/**\n * Get tick count\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get tick count from ISR\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * This is a version of xTaskGetTickCount() that is safe to be called from an\n * ISR - provided that TickType_t is the natural word size of the\n * microcontroller being used or interrupt nesting is either not supported or\n * not being used.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get current number of tasks\n *\n * @return The number of tasks that the real time kernel is currently managing.\n * This includes all ready, blocked and suspended tasks.  A task that\n * has been deleted but not yet freed by the idle task will also be\n * included in the count.\n *\n * \\ingroup TaskUtils\n */\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get task name\n *\n * @return The text (human readable) name of the task referenced by the handle\n * xTaskToQuery.  A task can query its own name by either passing in its own\n * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be\n * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.\n *\n * \\ingroup TaskUtils\n */\nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Returns the high water mark of the stack associated with xTask.\n *\n * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * High water mark is the minimum free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task started.\n * The smaller the returned number the closer the task has come to overflowing its stack.\n *\n * @param xTask Handle of the task associated with the stack to be checked.\n * Set xTask to NULL to check the stack of the calling task.\n *\n * @return The smallest amount of free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task referenced by\n * xTask was created.\n */\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Returns the start of the stack associated with xTask.\n *\n * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * Returns the highest stack memory address on architectures where the stack grows down\n * from high memory, and the lowest memory address on architectures where the\n * stack grows up from low memory.\n *\n * @param xTask Handle of the task associated with the stack returned.\n * Set xTask to NULL to return the stack of the calling task.\n *\n * @return A pointer to the start of the stack.\n */\nuint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n\t#if configUSE_APPLICATION_TASK_TAG == 1\n\t\t/**\n\t\t * Sets pxHookFunction to be the task hook function used by the task xTask.\n\t\t * @param xTask Handle of the task to set the hook function for\n\t\t *              Passing xTask as NULL has the effect of setting the calling\n\t\t *              tasks hook function.\n\t\t * @param pxHookFunction  Pointer to the hook function.\n\t\t */\n\t\tvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\n\t\t/**\n\t\t * Get the hook function assigned to given task.\n\t\t * @param xTask Handle of the task to get the hook function for\n\t\t *              Passing xTask as NULL has the effect of getting the calling\n\t\t *              tasks hook function.\n\t\t * @return The pxHookFunction value assigned to the task xTask.\n\t\t */\n\t\tTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\t#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )\n\n\t/**\n\t * Set local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t * @param xIndex The index of the pointer to set, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @param pvValue  Pointer value to set.\n\t */\n\tvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\n\n\n\t/**\n\t * Get local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToQuery  Task to get thread local storage pointer for\n\t * @param xIndex The index of the pointer to get, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @return  Pointer value\n\t */\n\tvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n\t#if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )\n\n\t\t/**\n\t\t * Prototype of local storage pointer deletion callback.\n\t\t */\n\t\ttypedef void (*TlsDeleteCallbackFunction_t)( int, void * );\n\n\t\t/**\n\t\t * Set local storage pointer and deletion callback.\n\t\t *\n\t\t * Each task contains an array of pointers that is dimensioned by the\n\t\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t\t * The kernel does not use the pointers itself, so the application writer\n\t\t * can use the pointers for any purpose they wish.\n\t\t *\n\t\t * Local storage pointers set for a task can reference dynamically\n\t\t * allocated resources. This function is similar to\n\t\t * vTaskSetThreadLocalStoragePointer, but provides a way to release\n\t\t * these resources when the task gets deleted. For each pointer,\n\t\t * a callback function can be set. This function will be called\n\t\t * when task is deleted, with the local storage pointer index\n\t\t * and value as arguments.\n\t\t *\n\t\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t\t * @param xIndex The index of the pointer to set, from 0 to\n\t\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t\t * @param pvValue  Pointer value to set.\n\t\t * @param pvDelCallback  Function to call to dispose of the local\n\t\t *                       storage pointer when the task is deleted.\n\t\t */\n\t\tvoid vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue, TlsDeleteCallbackFunction_t pvDelCallback);\n\t#endif\n\n#endif\n\n/**\n * Calls the hook function associated with xTask. Passing xTask as NULL has\n * the effect of calling the Running tasks (the calling task) hook function.\n *\n * @param xTask  Handle of the task to call the hook for.\n * @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n * wants.  The return value is the value returned by the task hook function\n * registered by the user.\n */\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\n/**\n * Get the handle of idle task for the current CPU.\n *\n * xTaskGetIdleTaskHandle() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @return The handle of the idle task.  It is not valid to call\n * xTaskGetIdleTaskHandle() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandle( void );\n\n/**\n * Get the handle of idle task for the given CPU.\n *\n * xTaskGetIdleTaskHandleForCPU() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @param cpuid The CPU to get the handle for\n *\n * @return Idle task handle of a given cpu. It is not valid to call\n * xTaskGetIdleTaskHandleForCPU() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandleForCPU( UBaseType_t cpuid );\n\n/**\n * Get the state of tasks in the system.\n *\n * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n * uxTaskGetSystemState() to be available.\n *\n * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n * the system.  TaskStatus_t structures contain, among other things, members\n * for the task handle, task name, task priority, task state, and total amount\n * of run time consumed by the task.  See the TaskStatus_t structure\n * definition in this file for the full member list.\n *\n * @note  This function is intended for debugging use only as its use results in\n * the scheduler remaining suspended for an extended period.\n *\n * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n * The array must contain at least one TaskStatus_t structure for each task\n * that is under the control of the RTOS.  The number of tasks under the control\n * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n *\n * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n * parameter.  The size is specified as the number of indexes in the array, or\n * the number of TaskStatus_t structures contained in the array, not by the\n * number of bytes in the array.\n *\n * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n * total run time (as defined by the run time stats clock, see\n * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.\n * pulTotalRunTime can be set to NULL to omit the total run time information.\n *\n * @return The number of TaskStatus_t structures that were populated by\n * uxTaskGetSystemState().  This should equal the number returned by the\n * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n * in the uxArraySize parameter was too small.\n *\n * Example usage:\n * @code{c}\n * // This example demonstrates how a human readable table of run time stats\n * // information is generated from raw data provided by uxTaskGetSystemState().\n * // The human readable table is written to pcWriteBuffer\n * void vTaskGetRunTimeStats( char *pcWriteBuffer )\n * {\n * TaskStatus_t *pxTaskStatusArray;\n * volatile UBaseType_t uxArraySize, x;\n * uint32_t ulTotalRunTime, ulStatsAsPercentage;\n *\n *  // Make sure the write buffer does not contain a string.\n *  *pcWriteBuffer = 0x00;\n *\n *  // Take a snapshot of the number of tasks in case it changes while this\n *  // function is executing.\n *  uxArraySize = uxTaskGetNumberOfTasks();\n *\n *  // Allocate a TaskStatus_t structure for each task.  An array could be\n *  // allocated statically at compile time.\n *  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n *\n *  if( pxTaskStatusArray != NULL )\n *  {\n *      // Generate raw status information about each task.\n *      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n *\n *      // For percentage calculations.\n *      ulTotalRunTime /= 100UL;\n *\n *      // Avoid divide by zero errors.\n *      if( ulTotalRunTime > 0 )\n *      {\n *          // For each populated position in the pxTaskStatusArray array,\n *          // format the raw data as human readable ASCII data\n *          for( x = 0; x < uxArraySize; x++ )\n *          {\n *              // What percentage of the total run time has the task used?\n *              // This will always be rounded down to the nearest integer.\n *              // ulTotalRunTimeDiv100 has already been divided by 100.\n *              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n *\n *              if( ulStatsAsPercentage > 0UL )\n *              {\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n *              }\n *              else\n *              {\n *                  // If the percentage is zero here then the task has\n *                  // consumed less than 1% of the total run time.\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n *              }\n *\n *              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n *          }\n *      }\n *\n *      // The array is no longer needed, free the memory it consumes.\n *      vPortFree( pxTaskStatusArray );\n *  }\n * }\n * @endcode\n */\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );\n\n/**\n * List all the current tasks.\n *\n * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n * both be defined as 1 for this function to be available.  See the\n * configuration section of the FreeRTOS.org website for more information.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Lists all the current tasks, along with their current state and stack\n * usage high water mark.\n *\n * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n * suspended ('S').\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays task\n * names, states and stack usage.\n *\n * vTaskList() has a dependency on the sprintf() C library function that might\n * bloat the code size, use a lot of stack, and provide different results on\n * different platforms.  An alternative, tiny, third party, and limited\n * functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState()\n * directly to get access to raw stats data, rather than indirectly through a\n * call to vTaskList().\n *\n * @param pcWriteBuffer A buffer into which the above mentioned details\n * will be written, in ASCII form.  This buffer is assumed to be large\n * enough to contain the generated report.  Approximately 40 bytes per\n * task should be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Get the state of running tasks as a string\n *\n * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n * must both be defined as 1 for this function to be available.  The application\n * must also then provide definitions for\n * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n * to configure a peripheral timer/counter and return the timers current count\n * value respectively.  The counter should be at least 10 times the frequency of\n * the tick count.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n * accumulated execution time being stored for each task.  The resolution\n * of the accumulated time value depends on the frequency of the timer\n * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n * Calling vTaskGetRunTimeStats() writes the total execution time of each\n * task into a buffer, both as an absolute count value and as a percentage\n * of the total system execution time.\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays the\n * amount of time each task has spent in the Running state in both absolute and\n * percentage terms.\n *\n * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n * that might bloat the code size, use a lot of stack, and provide different\n * results on different platforms.  An alternative, tiny, third party, and\n * limited functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState() directly\n * to get access to raw stats data, rather than indirectly through a call to\n * vTaskGetRunTimeStats().\n *\n * @param pcWriteBuffer A buffer into which the execution times will be\n * written, in ASCII form.  This buffer is assumed to be large enough to\n * contain the generated report.  Approximately 40 bytes per task should\n * be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Send task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\tupdated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\n/**\n * Send task notification from an ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotify() that can be used from an interrupt service routine\n * (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n * be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Wait for task notification\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n * will be cleared in the calling task's notification value before the task\n * checks to see if any notifications are pending, and optionally blocks if no\n * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n * the effect of resetting the task's notification value to 0.  Setting\n * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n *\n * @param ulBitsToClearOnExit If a notification is pending or received before\n * the calling task exits the xTaskNotifyWait() function then the task's\n * notification value (see the xTaskNotify() API function) is passed out using\n * the pulNotificationValue parameter.  Then any bits that are set in\n * ulBitsToClearOnExit will be cleared in the task's notification value (note\n * *pulNotificationValue is set before any bits are cleared).  Setting\n * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n * (if limits.h is not included) will have the effect of resetting the task's\n * notification value to 0 before the function exits.  Setting\n * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n * when the function exits (in which case the value passed out in\n * pulNotificationValue will match the task's notification value).\n *\n * @param pulNotificationValue Used to pass the task's notification value out\n * of the function.  Note the value passed out will not be effected by the\n * clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for a notification to be received, should a notification\n * not already be pending when xTaskNotifyWait() was called.  The task\n * will not consume any processing time while it is in the Blocked state.  This\n * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be\n * used to convert a time specified in milliseconds to a time specified in\n * ticks.\n *\n * @return If a notification was received (including notifications that were\n * already pending when xTaskNotifyWait was called) then pdPASS is\n * returned.  Otherwise pdFAIL is returned.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n/**\n * Simplified macro for sending task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * xTaskNotifyGive() is a helper macro intended for use when task notifications\n * are used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,\n * the equivalent action that instead uses a task notification is\n * xTaskNotifyGive().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the\n * eAction parameter set to eIncrement - so pdPASS is always returned.\n *\n * \\ingroup TaskNotifications\n */\n#define xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )\n\n/**\n * Simplified macro for sending task notification from ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotifyGive() that can be called from an interrupt service\n * routine (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * vTaskNotifyGiveFromISR() is intended for use when task notifications are\n * used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given from an ISR using the\n * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n * a task notification is vTaskNotifyGiveFromISR().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n * should be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * \\ingroup TaskNotifications\n */\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Simplified macro for receiving task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * ulTaskNotifyTake() is intended for use when a task notification is used as a\n * faster and lighter weight binary or counting semaphore alternative.  Actual\n * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the\n * equivalent action that instead uses a task notification is\n * ulTaskNotifyTake().\n *\n * When a task is using its notification value as a binary or counting semaphore\n * other tasks should send notifications to it using the xTaskNotifyGive()\n * macro, or xTaskNotify() function with the eAction parameter set to\n * eIncrement.\n *\n * ulTaskNotifyTake() can either clear the task's notification value to\n * zero on exit, in which case the notification value acts like a binary\n * semaphore, or decrement the task's notification value on exit, in which case\n * the notification value acts like a counting semaphore.\n *\n * A task can use ulTaskNotifyTake() to [optionally] block to wait for a\n * the task's notification value to be non-zero.  The task does not consume any\n * CPU time while it is in the Blocked state.\n *\n * Where as xTaskNotifyWait() will return when a notification is pending,\n * ulTaskNotifyTake() will return when the task's notification value is\n * not zero.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n * notification value is decremented when the function exits.  In this way the\n * notification value acts like a counting semaphore.  If xClearCountOnExit is\n * not pdFALSE then the task's notification value is cleared to zero when the\n * function exits.  In this way the notification value acts like a binary\n * semaphore.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for the task's notification value to be greater than zero,\n * should the count not already be greater than zero when\n * ulTaskNotifyTake() was called.  The task will not consume any processing\n * time while it is in the Blocked state.  This is specified in kernel ticks,\n * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time\n * specified in milliseconds to a time specified in ticks.\n *\n * @return The task's notification count before it is either cleared to zero or\n * decremented (see the xClearCountOnExit parameter).\n *\n * \\ingroup TaskNotifications\n */\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n/** @cond */\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * xTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n * Return the handle of the task running on a certain CPU. Because of\n * the nature of SMP processing, there is no guarantee that this\n * value will still be valid on return and should only be used for\n * debugging purposes.\n */\nTaskHandle_t xTaskGetCurrentTaskHandleForCPU( BaseType_t cpuid );\n\n\n/*\n * Capture the current time status for future reference.\n */\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n/*\n * Compare the time status now with that previously captured to see if the\n * timeout has expired.\n */\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n\n/*\n * Get the current core affinity of a task\n */\nBaseType_t xTaskGetAffinity( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/*\n * Only avilable when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nvoid *pvTaskIncrementMutexHeldCount( void );\n\n/*\n * This function fills array with TaskSnapshot_t structures for every task in the system.\n * Used by core dump facility to get snapshots of all tasks in the system.\n * Only available when configENABLE_TASK_SNAPSHOT is set to 1.\n * @param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.\n * @param uxArraySize Size of tasks snapshots array.\n * @param pxTcbSz Pointer to store size of TCB.\n * @return Number of elements stored in array.\n */\nUBaseType_t uxTaskGetSnapshotAll( TaskSnapshot_t * const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t * const pxTcbSz );\n\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n\n\n\n"}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h"}}}
>>>
Content-Length: 205

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":382,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":26}}}
>>>
Content-Length: 1078

{"id":382,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":275,"character":19},"end":{"line":275,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":383,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":16}}}
>>>
Content-Length: 213

{"id":383,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","range":{"start":{"line":86,"character":14},"end":{"line":86,"character":19}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 8355

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","languageId":"cpp","version":1,"text":"/*\n Print.cpp - Base class that provides print() and println()\n Copyright (c) 2008 David A. Mellis.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 23 November 2006 by David A. Mellis\n Modified December 2014 by Ivan Grokhotkov\n Modified May 2015 by Michael C. Miller - ESP31B progmem support\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"Arduino.h\"\n\n#include \"Print.h\"\nextern \"C\" {\n    #include \"time.h\"\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\n/* default implementation: may be overridden */\nsize_t Print::write(const uint8_t *buffer, size_t size)\n{\n    size_t n = 0;\n    while(size--) {\n        n += write(*buffer++);\n    }\n    return n;\n}\n\nsize_t Print::printf(const char *format, ...)\n{\n    char loc_buf[64];\n    char * temp = loc_buf;\n    va_list arg;\n    va_list copy;\n    va_start(arg, format);\n    va_copy(copy, arg);\n    int len = vsnprintf(temp, sizeof(loc_buf), format, copy);\n    va_end(copy);\n    if(len < 0) {\n        va_end(arg);\n        return 0;\n    };\n    if(len >= sizeof(loc_buf)){\n        temp = (char*) malloc(len+1);\n        if(temp == NULL) {\n            va_end(arg);\n            return 0;\n        }\n        len = vsnprintf(temp, len+1, format, arg);\n    }\n    va_end(arg);\n    len = write((uint8_t*)temp, len);\n    if(temp != loc_buf){\n        free(temp);\n    }\n    return len;\n}\n\nsize_t Print::print(const __FlashStringHelper *ifsh)\n{\n    return print(reinterpret_cast<const char *>(ifsh));\n}\n\nsize_t Print::print(const String &s)\n{\n    return write(s.c_str(), s.length());\n}\n\nsize_t Print::print(const char str[])\n{\n    return write(str);\n}\n\nsize_t Print::print(char c)\n{\n    return write(c);\n}\n\nsize_t Print::print(unsigned char b, int base)\n{\n    return print((unsigned long) b, base);\n}\n\nsize_t Print::print(int n, int base)\n{\n    return print((long) n, base);\n}\n\nsize_t Print::print(unsigned int n, int base)\n{\n    return print((unsigned long) n, base);\n}\n\nsize_t Print::print(long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long n, int base)\n{\n    if(base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(long long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long long n, int base)\n{\n    if (base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(double n, int digits)\n{\n    return printFloat(n, digits);\n}\n\nsize_t Print::println(const __FlashStringHelper *ifsh)\n{\n    size_t n = print(ifsh);\n    n += println();\n    return n;\n}\n\nsize_t Print::print(const Printable& x)\n{\n    return x.printTo(*this);\n}\n\nsize_t Print::print(struct tm * timeinfo, const char * format)\n{\n    const char * f = format;\n    if(!f){\n        f = \"%c\";\n    }\n    char buf[64];\n    size_t written = strftime(buf, 64, f, timeinfo);\n    if(written == 0){\n        return written;\n    }\n    return print(buf);\n}\n\nsize_t Print::println(void)\n{\n    return print(\"\\r\\n\");\n}\n\nsize_t Print::println(const String &s)\n{\n    size_t n = print(s);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const char c[])\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(char c)\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned char b, int base)\n{\n    size_t n = print(b, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(double num, int digits)\n{\n    size_t n = print(num, digits);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const Printable& x)\n{\n    size_t n = print(x);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(struct tm * timeinfo, const char * format)\n{\n    size_t n = print(timeinfo, format);\n    n += println();\n    return n;\n}\n\n// Private Methods /////////////////////////////////////////////////////////////\n\nsize_t Print::printNumber(unsigned long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char *str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if(base < 2) {\n        base = 10;\n    }\n\n    do {\n        char c = n % base;\n        n /= base;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printNumber(unsigned long long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char* str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if (base < 2) {\n        base = 10;\n    }\n\n    do {\n        auto m = n;\n        n /= base;\n        char c = m - base * n;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printFloat(double number, uint8_t digits)\n{\n    size_t n = 0;\n\n    if(isnan(number)) {\n        return print(\"nan\");\n    }\n    if(isinf(number)) {\n        return print(\"inf\");\n    }\n    if(number > 4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n    if(number < -4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n\n    // Handle negative numbers\n    if(number < 0.0) {\n        n += print('-');\n        number = -number;\n    }\n\n    // Round correctly so that print(1.999, 2) prints as \"2.00\"\n    double rounding = 0.5;\n    for(uint8_t i = 0; i < digits; ++i) {\n        rounding /= 10.0;\n    }\n\n    number += rounding;\n\n    // Extract the integer part of the number and print it\n    unsigned long int_part = (unsigned long) number;\n    double remainder = number - (double) int_part;\n    n += print(int_part);\n\n    // Print the decimal point, but only if there are digits beyond\n    if(digits > 0) {\n        n += print(\".\");\n    }\n\n    // Extract digits from the remainder one at a time\n    while(digits-- > 0) {\n        remainder *= 10.0;\n        int toPrint = int(remainder);\n        n += print(toPrint);\n        remainder -= toPrint;\n    }\n\n    return n;\n}\n"}}}Content-Length: 174

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp"}}}
>>>
Content-Length: 184

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":384,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":15}}}
>>>
Content-Length: 313

{"id":384,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":274,"character":11},"end":{"line":274,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":385,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":15}}}
>>>
Content-Length: 849

{"id":385,"result":[{"range":{"start":{"line":107,"character":9},"end":{"line":107,"character":14}},"kind":1},{"range":{"start":{"line":109,"character":9},"end":{"line":109,"character":14}},"kind":1},{"range":{"start":{"line":111,"character":9},"end":{"line":111,"character":14}},"kind":1},{"range":{"start":{"line":113,"character":9},"end":{"line":113,"character":14}},"kind":1},{"range":{"start":{"line":115,"character":9},"end":{"line":115,"character":14}},"kind":1},{"range":{"start":{"line":117,"character":9},"end":{"line":117,"character":14}},"kind":1},{"range":{"start":{"line":128,"character":9},"end":{"line":128,"character":14}},"kind":1},{"range":{"start":{"line":218,"character":11},"end":{"line":218,"character":16}},"kind":1},{"range":{"start":{"line":239,"character":11},"end":{"line":239,"character":16}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":386,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":15}}}
>>>
Content-Length: 213

{"id":386,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","range":{"start":{"line":86,"character":14},"end":{"line":86,"character":19}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":387,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":15},"end":{"line":239,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":387,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 8355

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","languageId":"cpp","version":1,"text":"/*\n Print.cpp - Base class that provides print() and println()\n Copyright (c) 2008 David A. Mellis.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 23 November 2006 by David A. Mellis\n Modified December 2014 by Ivan Grokhotkov\n Modified May 2015 by Michael C. Miller - ESP31B progmem support\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"Arduino.h\"\n\n#include \"Print.h\"\nextern \"C\" {\n    #include \"time.h\"\n}\n\n// Public Methods //////////////////////////////////////////////////////////////\n\n/* default implementation: may be overridden */\nsize_t Print::write(const uint8_t *buffer, size_t size)\n{\n    size_t n = 0;\n    while(size--) {\n        n += write(*buffer++);\n    }\n    return n;\n}\n\nsize_t Print::printf(const char *format, ...)\n{\n    char loc_buf[64];\n    char * temp = loc_buf;\n    va_list arg;\n    va_list copy;\n    va_start(arg, format);\n    va_copy(copy, arg);\n    int len = vsnprintf(temp, sizeof(loc_buf), format, copy);\n    va_end(copy);\n    if(len < 0) {\n        va_end(arg);\n        return 0;\n    };\n    if(len >= sizeof(loc_buf)){\n        temp = (char*) malloc(len+1);\n        if(temp == NULL) {\n            va_end(arg);\n            return 0;\n        }\n        len = vsnprintf(temp, len+1, format, arg);\n    }\n    va_end(arg);\n    len = write((uint8_t*)temp, len);\n    if(temp != loc_buf){\n        free(temp);\n    }\n    return len;\n}\n\nsize_t Print::print(const __FlashStringHelper *ifsh)\n{\n    return print(reinterpret_cast<const char *>(ifsh));\n}\n\nsize_t Print::print(const String &s)\n{\n    return write(s.c_str(), s.length());\n}\n\nsize_t Print::print(const char str[])\n{\n    return write(str);\n}\n\nsize_t Print::print(char c)\n{\n    return write(c);\n}\n\nsize_t Print::print(unsigned char b, int base)\n{\n    return print((unsigned long) b, base);\n}\n\nsize_t Print::print(int n, int base)\n{\n    return print((long) n, base);\n}\n\nsize_t Print::print(unsigned int n, int base)\n{\n    return print((unsigned long) n, base);\n}\n\nsize_t Print::print(long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long n, int base)\n{\n    if(base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(long long n, int base)\n{\n    int t = 0;\n    if (base == 10 && n < 0) {\n        t = print('-');\n        n = -n;\n    }\n    return printNumber(static_cast<unsigned long long>(n), base) + t;\n}\n\nsize_t Print::print(unsigned long long n, int base)\n{\n    if (base == 0) {\n        return write(n);\n    } else {\n        return printNumber(n, base);\n    }\n}\n\nsize_t Print::print(double n, int digits)\n{\n    return printFloat(n, digits);\n}\n\nsize_t Print::println(const __FlashStringHelper *ifsh)\n{\n    size_t n = print(ifsh);\n    n += println();\n    return n;\n}\n\nsize_t Print::print(const Printable& x)\n{\n    return x.printTo(*this);\n}\n\nsize_t Print::print(struct tm * timeinfo, const char * format)\n{\n    const char * f = format;\n    if(!f){\n        f = \"%c\";\n    }\n    char buf[64];\n    size_t written = strftime(buf, 64, f, timeinfo);\n    if(written == 0){\n        return written;\n    }\n    return print(buf);\n}\n\nsize_t Print::println(void)\n{\n    return print(\"\\r\\n\");\n}\n\nsize_t Print::println(const String &s)\n{\n    size_t n = print(s);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const char c[])\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(char c)\n{\n    size_t n = print(c);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned char b, int base)\n{\n    size_t n = print(b, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned int num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(unsigned long long num, int base)\n{\n    size_t n = print(num, base);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(double num, int digits)\n{\n    size_t n = print(num, digits);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(const Printable& x)\n{\n    size_t n = print(x);\n    n += println();\n    return n;\n}\n\nsize_t Print::println(struct tm * timeinfo, const char * format)\n{\n    size_t n = print(timeinfo, format);\n    n += println();\n    return n;\n}\n\n// Private Methods /////////////////////////////////////////////////////////////\n\nsize_t Print::printNumber(unsigned long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char *str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if(base < 2) {\n        base = 10;\n    }\n\n    do {\n        char c = n % base;\n        n /= base;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printNumber(unsigned long long n, uint8_t base)\n{\n    char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.\n    char* str = &buf[sizeof(buf) - 1];\n\n    *str = '\\0';\n\n    // prevent crash if called with base == 1\n    if (base < 2) {\n        base = 10;\n    }\n\n    do {\n        auto m = n;\n        n /= base;\n        char c = m - base * n;\n\n        *--str = c < 10 ? c + '0' : c + 'A' - 10;\n    } while (n);\n\n    return write(str);\n}\n\nsize_t Print::printFloat(double number, uint8_t digits)\n{\n    size_t n = 0;\n\n    if(isnan(number)) {\n        return print(\"nan\");\n    }\n    if(isinf(number)) {\n        return print(\"inf\");\n    }\n    if(number > 4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n    if(number < -4294967040.0) {\n        return print(\"ovf\");    // constant determined empirically\n    }\n\n    // Handle negative numbers\n    if(number < 0.0) {\n        n += print('-');\n        number = -number;\n    }\n\n    // Round correctly so that print(1.999, 2) prints as \"2.00\"\n    double rounding = 0.5;\n    for(uint8_t i = 0; i < digits; ++i) {\n        rounding /= 10.0;\n    }\n\n    number += rounding;\n\n    // Extract the integer part of the number and print it\n    unsigned long int_part = (unsigned long) number;\n    double remainder = number - (double) int_part;\n    n += print(int_part);\n\n    // Print the decimal point, but only if there are digits beyond\n    if(digits > 0) {\n        n += print(\".\");\n    }\n\n    // Extract digits from the remainder one at a time\n    while(digits-- > 0) {\n        remainder *= 10.0;\n        int toPrint = int(remainder);\n        n += print(toPrint);\n        remainder -= toPrint;\n    }\n\n    return n;\n}\n"}}}Content-Length: 224

{"jsonrpc":"2.0","id":388,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp"},"position":{"line":108,"character":18}}}
>>>
Content-Length: 1047

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"severity":1,"code":"drv_unknown_argument","source":"clang","message":"Unknown argument: '-fstrict-volatile-bitfields'"},{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"severity":1,"code":"drv_unknown_argument_with_suggestion","source":"clang","message":"Unknown argument '-mlongcalls'; did you mean '-mlong-calls'?"},{"range":{"start":{"line":27,"character":9},"end":{"line":27,"character":20}},"severity":1,"code":"unknown_typename","source":"clang","message":"In included file: unknown type name 'pthread_t'\n\n/home/manos/.arduino15/packages/esp32/tools/xtensa-esp32-elf-gcc/1.22.0-97-gc752ad5-5.2.0/bin/../lib/gcc/xtensa-esp32-elf/5.2.0/../../../../xtensa-esp32-elf/include/c++/5.2.0/xtensa-esp32-elf/bits/gthr-default.h:47:9:\nnote: error occurred here"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":388,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 219

{"jsonrpc":"2.0","id":389,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp"},"position":{"line":108,"character":18}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":389}}
>>>
Content-Length: 40

{"id":389,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 174

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp"}}}
>>>
Content-Length: 184

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/Print.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":390,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":236,"character":10}}}
>>>
Content-Length: 247

{"id":390,"result":{"contents":{"kind":"markdown","value":"### function `checkAlarms`  \n\n---\n `void`  \n\n---\n```cpp\nvoid checkAlarms()\n```"},"range":{"start":{"line":271,"character":4},"end":{"line":271,"character":15}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":391,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":241,"character":9}}}
>>>
Content-Length: 40

{"id":391,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":392,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":12}}}
>>>
Content-Length: 341

{"id":392,"result":{"contents":{"kind":"markdown","value":"### instance-method `println`  \n\n---\n `size_t`  \nParameters:  \n- `unsigned int`\n- `int = 10`\n\n---\n```cpp\n// In Print\npublic: size_t println(unsigned int, int = 10)\n```"},"range":{"start":{"line":275,"character":11},"end":{"line":275,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":393,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":15},"end":{"line":239,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":393,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":394,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":12}}}
>>>
Content-Length: 313

{"id":394,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":274,"character":11},"end":{"line":274,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":395,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":13}}}
>>>
Content-Length: 313

{"id":395,"result":{"contents":{"kind":"markdown","value":"### instance-method `print`  \n\n---\n `size_t`  \nParameters:  \n- `const char *`\n\n---\n```cpp\n// In Print\npublic: size_t print(const char[])\n```"},"range":{"start":{"line":274,"character":11},"end":{"line":274,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":396,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":240,"character":14}}}
>>>
Content-Length: 341

{"id":396,"result":{"contents":{"kind":"markdown","value":"### instance-method `println`  \n\n---\n `size_t`  \nParameters:  \n- `unsigned int`\n- `int = 10`\n\n---\n```cpp\n// In Print\npublic: size_t println(unsigned int, int = 10)\n```"},"range":{"start":{"line":275,"character":11},"end":{"line":275,"character":18}}},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":397,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":4},"end":{"line":240,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 366

{"id":397,"result":[{"title":"Extract to function","kind":"refactor","command":{"title":"Extract to function","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractFunction","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":274,"character":4},"end":{"line":275,"character":54}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":398,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}
>>>
Content-Length: 270

{"id":398,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":274,"character":4},"end":{"line":274,"character":10}}},"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":399,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}
>>>
Content-Length: 222

{"id":399,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":724},"contentChanges":[{"range":{"start":{"line":239,"character":4},"end":{"line":240,"character":54}},"rangeLength":89,"text":""}]}}Content-Length: 209

{"jsonrpc":"2.0","id":400,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}Content-Length: 64


>>>
Content-Length: 40

{"id":400,"result":null,"jsonrpc":"2.0"}
<<<
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":400}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":724}}}Content-Length: 221

{"jsonrpc":"2.0","id":401,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":4}}}
>>>
Content-Length: 397

{"id":401,"result":[{"range":{"start":{"line":188,"character":4},"end":{"line":188,"character":14}},"kind":1},{"range":{"start":{"line":192,"character":4},"end":{"line":192,"character":14}},"kind":1},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":14}},"kind":1},{"range":{"start":{"line":247,"character":4},"end":{"line":247,"character":14}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":402,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}
>>>
Content-Length: 40

{"id":402,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":403,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}
>>>
Content-Length: 40

{"id":403,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":404,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":404,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":405,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":4}}}
>>>
Content-Length: 40

{"id":405,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":406,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":2},"end":{"line":238,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":406,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":725},"contentChanges":[{"range":{"start":{"line":238,"character":2},"end":{"line":238,"character":2}},"rangeLength":0,"text":"\n  "}]}}Content-Length: 283

{"jsonrpc":"2.0","id":407,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":2},"end":{"line":239,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":407,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":725}}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":726},"contentChanges":[{"range":{"start":{"line":237,"character":2},"end":{"line":237,"character":2}},"rangeLength":0,"text":"\n  "}]}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":726}}}Content-Length: 397

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":727},"contentChanges":[{"range":{"start":{"line":237,"character":2},"end":{"line":237,"character":2}},"rangeLength":0,"text":"Serial.print(\" Overflow Stack :\");\n    Serial.println(uxTaskGetStackHighWaterMark(NULL));"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":408,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":54},"end":{"line":238,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":408,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":727}}}Content-Length: 285

{"jsonrpc":"2.0","id":409,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":36},"end":{"line":237,"character":36}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":409,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":410,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":9},"end":{"line":237,"character":9}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":410,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":411,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":8},"end":{"line":237,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":411,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":412,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":2},"end":{"line":237,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":412,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":728},"contentChanges":[{"range":{"start":{"line":237,"character":2},"end":{"line":237,"character":2}},"rangeLength":0,"text":"  "}]}}Content-Length: 283

{"jsonrpc":"2.0","id":413,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":413,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":728}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":728}}}Content-Length: 210

{"jsonrpc":"2.0","id":414,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":22}}}
>>>
Content-Length: 1078

{"id":414,"result":{"contents":{"kind":"markdown","value":"### function `uxTaskGetStackHighWaterMark`  \n\n---\n `UBaseType_t`  \nParameters:  \n- `TaskHandle_t xTask`\n\nReturns the high water mark of the stack associated with xTask.  \nINCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.  \nHigh water mark is the minimum free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task started.  \nThe smaller the returned number the closer the task has come to overflowing its stack.  \n@param xTask Handle of the task associated with the stack to be checked.  \nSet xTask to NULL to check the stack of the calling task.  \n@return The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created.  \n\n---\n```cpp\nUBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)\n```"},"range":{"start":{"line":273,"character":19},"end":{"line":273,"character":46}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":415,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":8}}}
>>>
Content-Length: 40

{"id":415,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":416,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":269,"character":6}}}
>>>
Content-Length: 216

{"id":416,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":304,"character":4},"end":{"line":304,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":417,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":269,"character":6}}}
>>>
Content-Length: 216

{"id":417,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":304,"character":4},"end":{"line":304,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":418,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":6}}}
>>>
Content-Length: 38

{"id":418,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":419,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":419,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":420,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":5}}}
>>>
Content-Length: 40

{"id":420,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":421,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":5}}}
>>>
Content-Length: 40

{"id":421,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":422,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":7}}}
>>>
Content-Length: 40

{"id":422,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":423,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":8}}}
>>>
Content-Length: 670

{"id":423,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":8},"end":{"line":312,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":424,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":424,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":425,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":8}}}
>>>
Content-Length: 670

{"id":425,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":8},"end":{"line":312,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":426,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":8},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":426,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":427,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":8}}}
>>>
Content-Length: 236

{"id":427,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","range":{"start":{"line":431,"character":36},"end":{"line":431,"character":47}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 98387

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n\t***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\t***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n\tthe FAQ page \"My application does not run, what could be wrong?\".  Have you\n\tdefined configASSERT()?\n\n\thttp://www.FreeRTOS.org/support - In return for receiving this top quality\n\tembedded software for free we request you assist our global community by\n\tparticipating in the support forum.\n\n\thttp://www.FreeRTOS.org/training - Investing in training allows your team to\n\tbe as productive as possible as early as possible.  Now you can receive\n\tFreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n\tLtd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n\t#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include <limits.h>\n\n#include \"list.h\"\n#include \"portmacro.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V8.2.0\"\n#define tskKERNEL_VERSION_MAJOR 8\n#define tskKERNEL_VERSION_MINOR 2\n#define tskKERNEL_VERSION_BUILD 0\n\n/**\n * @brief Argument of xTaskCreatePinnedToCore indicating that task has no affinity\n */\n#define tskNO_AFFINITY INT_MAX\n\n/**\n * task. h\n *\n * Type by which tasks are referenced.  For example, a call to xTaskCreate\n * returns (via a pointer parameter) an TaskHandle_t variable that can then\n * be used as a parameter to vTaskDelete to delete the task.\n *\n * \\ingroup Tasks\n */\ntypedef void * TaskHandle_t;\n\n/**\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/** Task states returned by eTaskGetState. */\ntypedef enum\n{\n\teRunning = 0,\t/*!< A task is querying the state of itself, so must be running. */\n\teReady,\t\t\t/*!< The task being queried is in a read or pending ready list. */\n\teBlocked,\t\t/*!< The task being queried is in the Blocked state. */\n\teSuspended,\t\t/*!< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\n\teDeleted\t\t/*!< The task being queried has been deleted, but its TCB has not yet been freed. */\n} eTaskState;\n\n/** Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\n\teNoAction = 0,\t\t\t\t/*!< Notify the task without updating its notify value. */\n\teSetBits,\t\t\t\t\t/*!< Set bits in the task's notification value. */\n\teIncrement,\t\t\t\t\t/*!< Increment the task's notification value. */\n\teSetValueWithOverwrite,\t\t/*!< Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n\teSetValueWithoutOverwrite\t/*!< Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/** @cond */\n/**\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\n\tBaseType_t xOverflowCount;\n\tTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/**\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\n\tvoid *pvBaseAddress;\n\tuint32_t ulLengthInBytes;\n\tuint32_t ulParameters;\n} MemoryRegion_t;\n\n/**\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\n\tTaskFunction_t pvTaskCode;\n\tconst char * const pcName;\t/*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tuint32_t usStackDepth;\n\tvoid *pvParameters;\n\tUBaseType_t uxPriority;\n\tStackType_t *puxStackBuffer;\n\tMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n} TaskParameters_t;\n/** @endcond */\n\n/**\n *  Used with the uxTaskGetSystemState() function to return the state of each task in the system.\n*/\ntypedef struct xTASK_STATUS\n{\n\tTaskHandle_t xHandle;\t\t\t/*!< The handle of the task to which the rest of the information in the structure relates. */\n\tconst char *pcTaskName;\t\t\t/*!< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tUBaseType_t xTaskNumber;\t\t/*!< A number unique to the task. */\n\teTaskState eCurrentState;\t\t/*!< The state in which the task existed when the structure was populated. */\n\tUBaseType_t uxCurrentPriority;\t/*!< The priority at which the task was running (may be inherited) when the structure was populated. */\n\tUBaseType_t uxBasePriority;\t\t/*!< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\n\tuint32_t ulRunTimeCounter;\t\t/*!< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\n\tStackType_t *pxStackBase;\t\t/*!< Points to the lowest address of the task's stack area. */\n\tuint32_t usStackHighWaterMark;\t/*!< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n#if configTASKLIST_INCLUDE_COREID\n\tBaseType_t xCoreID;\t\t\t\t/*!< Core this task is pinned to. This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. */\n#endif\n} TaskStatus_t;\n\n/**\n * Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n * We need this struct because TCB_t is defined (hidden) in tasks.c.\n */\ntypedef struct xTASK_SNAPSHOT\n{\n\tvoid        *pxTCB;         /*!< Address of task control block. */\n\tStackType_t *pxTopOfStack;  /*!< Points to the location of the last item placed on the tasks stack. */\n\tStackType_t *pxEndOfStack;  /*!< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\n\t\t\t\t\t\t\t\t\tpxTopOfStack > pxEndOfStack, stack grows lo2hi*/\n} TaskSnapshot_t;\n\n/**\n * Possible return values for eTaskConfirmSleepModeStatus().\n */\ntypedef enum\n{\n\teAbortSleep = 0,\t\t/*!< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\n\teStandardSleep,\t\t\t/*!< Enter a sleep mode that will not last any longer than the expected idle time. */\n\teNoTasksWaitingTimeout\t/*!< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n\n/**\n * Defines the priority used by the idle task.  This must not be modified.\n *\n * \\ingroup TaskUtils\n */\n#define tskIDLE_PRIORITY\t\t\t( ( UBaseType_t ) 0U )\n\n/**\n * task. h\n *\n * Macro for forcing a context switch.\n *\n * \\ingroup SchedulerControl\n */\n#define taskYIELD()\t\t\t\t\tportYIELD()\n\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskENTER_CRITICAL(mux)\t\tportENTER_CRITICAL(mux)\n#else\n#define taskENTER_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskENTER_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portENTER_CRITICAL(mux)'\\\"\") portENTER_CRITICAL(mux)\n#endif\n#define taskENTER_CRITICAL_ISR(mux)\t\tportENTER_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskEXIT_CRITICAL(mux)\t\t\tportEXIT_CRITICAL(mux)\n#else\n#define taskEXIT_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskEXIT_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portEXIT_CRITICAL(mux)'\\\"\") portEXIT_CRITICAL(mux)\n#endif\n#define taskEXIT_CRITICAL_ISR(mux)\t\tportEXIT_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to disable all maskable interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskDISABLE_INTERRUPTS()\tportDISABLE_INTERRUPTS()\n\n/**\n * task. h\n *\n * Macro to enable microcontroller interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskENABLE_INTERRUPTS()\t\tportENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED\t\t( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED\t( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING\t\t( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreate, but allows setting task affinity\n * in SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\tBaseType_t xTaskCreatePinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\tconst uint32_t usStackDepth,\n\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\tTaskHandle_t * const pvCreatedTask,\n\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID);\n\n#endif\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * See xTaskCreateStatic() for a version that does not use any dynamic memory\n * allocation.\n *\n * xTaskCreate() can only be used to create a task that has unrestricted\n * access to the entire microcontroller memory map.  Systems that include MPU\n * support can alternatively create an MPU constrained task using\n * xTaskCreateRestricted().\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *  // Task to be created.\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *   }\n *  }\n *\n *  // Function that creates a task.\n *  void vOtherFunction( void )\n *  {\n *  static uint8_t ucParameterToPass;\n *  TaskHandle_t xHandle = NULL;\n *\n *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass\n *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an\n *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time\n *   // the new task attempts to access it.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\n *      configASSERT( xHandle );\n *\n *   // Use the handle to delete the task.\n *      if( xHandle != NULL )\n *      {\n *       vTaskDelete( xHandle );\n *      }\n *  }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tstatic inline IRAM_ATTR BaseType_t xTaskCreate(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t usStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tTaskHandle_t * const pvCreatedTask)\n\t{\n\t\treturn xTaskCreatePinnedToCore( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask, tskNO_AFFINITY );\n\t}\n\n#endif\n\n\n\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreateStatic, but allows specifying\n * task affinity in an SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tTaskHandle_t xTaskCreateStaticPinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth,\n\t\t\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\t\t\tStackType_t * const pxStackBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tStaticTask_t * const pxTaskBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID );\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *\n *     // Dimensions the buffer that the task being created will use as its stack.\n *     // NOTE:  This is the number of bytes the stack will hold, not the number of\n *     // words as found in vanilla FreeRTOS.\n *     #define STACK_SIZE 200\n *\n *     // Structure that will hold the TCB of the task being created.\n *     StaticTask_t xTaskBuffer;\n *\n *     // Buffer that the task being created will use as its stack.  Note this is\n *     // an array of StackType_t variables.  The size of StackType_t is dependent on\n *     // the RTOS port.\n *     StackType_t xStack[ STACK_SIZE ];\n *\n *     // Function that implements the task being created.\n *     void vTaskCode( void * pvParameters )\n *     {\n *         // The parameter value is expected to be 1 as 1 is passed in the\n *         // pvParameters value in the call to xTaskCreateStatic().\n *         configASSERT( ( uint32_t ) pvParameters == 1UL );\n *\n *         for( ;; )\n *         {\n *             // Task code goes here.\n *         }\n *     }\n *\n *     // Function that creates a task.\n *     void vOtherFunction( void )\n *     {\n *         TaskHandle_t xHandle = NULL;\n *\n *         // Create the task without using any dynamic memory allocation.\n *         xHandle = xTaskCreateStatic(\n *                       vTaskCode,       // Function that implements the task.\n *                       \"NAME\",          // Text name for the task.\n *                       STACK_SIZE,      // Stack size in bytes, not words.\n *                       ( void * ) 1,    // Parameter passed into the task.\n *                       tskIDLE_PRIORITY,// Priority at which the task is created.\n *                       xStack,          // Array to use as the task's stack.\n *                       &xTaskBuffer );  // Variable to hold the task's data structure.\n *\n *         // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have\n *         // been created, and xHandle will be the task's handle.  Use the handle\n *         // to suspend the task.\n *         vTaskSuspend( xHandle );\n *     }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tstatic inline IRAM_ATTR TaskHandle_t xTaskCreateStatic(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t ulStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tStackType_t * const pxStackBuffer,\n\t\t\tStaticTask_t * const pxTaskBuffer)\n\t{\n\t\treturn xTaskCreateStaticPinnedToCore( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxStackBuffer, pxTaskBuffer, tskNO_AFFINITY );\n\t}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/** @cond */\n/**\n * xTaskCreateRestricted() should only be used in systems that include an MPU\n * implementation.\n *\n * Create a new task and add it to the list of tasks that are ready to run.\n * The function parameters define the memory regions and associated access\n * permissions allocated to the task.\n *\n * @param pxTaskDefinition Pointer to a structure that contains a member\n * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API\n * documentation) plus an optional stack buffer and the memory region\n * definitions.\n *\n * @param pxCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * Example usage:\n * @code{c}\n * // Create an TaskParameters_t structure that defines the task to be created.\n * static const TaskParameters_t xCheckTaskParameters =\n * {\n * \tvATask,\t\t// pvTaskCode - the function that implements the task.\n * \t\"ATask\",\t// pcName - just a text name for the task to assist debugging.\n * \t100,\t\t// usStackDepth\t- the stack size DEFINED IN BYTES.\n * \tNULL,\t\t// pvParameters - passed into the task function as the function parameters.\n * \t( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.\n * \tcStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\n *\n * \t// xRegions - Allocate up to three separate memory regions for access by\n * \t// the task, with appropriate access permissions.  Different processors have\n * \t// different memory alignment requirements - refer to the FreeRTOS documentation\n * \t// for full information.\n * \t{\n * \t\t// Base address\t\t\t\t\tLength\tParameters\n *         { cReadWriteArray,\t\t\t\t32,\t\tportMPU_REGION_READ_WRITE },\n *         { cReadOnlyArray,\t\t\t\t32,\t\tportMPU_REGION_READ_ONLY },\n *         { cPrivilegedOnlyAccessArray,\t128,\tportMPU_REGION_PRIVILEGED_READ_WRITE }\n * \t}\n * };\n *\n * int main( void )\n * {\n * TaskHandle_t xHandle;\n *\n * \t// Create a task from the const structure defined above.  The task handle\n * \t// is requested (the second parameter is not NULL) but in this case just for\n * \t// demonstration purposes as its not actually used.\n * \txTaskCreateRestricted( &xRegTest1Parameters, &xHandle );\n *\n * \t// Start the scheduler.\n * \tvTaskStartScheduler();\n *\n * \t// Will only get here if there was insufficient memory to create the idle\n * \t// and/or timer task.\n * \tfor( ;; );\n * }\n * @endcode\n * \\ingroup Tasks\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n\tBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n\n/**\n * Memory regions are assigned to a restricted task when the task is created by\n * a call to xTaskCreateRestricted().  These regions can be redefined using\n * vTaskAllocateMPURegions().\n *\n * @param xTask The handle of the task being updated.\n *\n * @param xRegions A pointer to an MemoryRegion_t structure that contains the\n * new memory region definitions.\n *\n * Example usage:\n *\n * @code{c}\n * // Define an array of MemoryRegion_t structures that configures an MPU region\n * // allowing read/write access for 1024 bytes starting at the beginning of the\n * // ucOneKByte array.  The other two of the maximum 3 definable regions are\n * // unused so set to zero.\n * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n * {\n * \t// Base address\t\tLength\t\tParameters\n * \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },\n * \t{ 0,\t\t\t\t0,\t\t\t0 },\n * \t{ 0,\t\t\t\t0,\t\t\t0 }\n * };\n *\n * void vATask( void *pvParameters )\n * {\n * \t// This task was created such that it has access to certain regions of\n * \t// memory as defined by the MPU configuration.  At some point it is\n * \t// desired that these MPU regions are replaced with that defined in the\n * \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n * \t// for this purpose.  NULL is used as the task handle to indicate that this\n * \t// function should modify the MPU regions of the calling task.\n * \tvTaskAllocateMPURegions( NULL, xAltRegions );\n *\n * \t// Now the task can continue its function, but from this point on can only\n * \t// access its stack and the ucOneKByte array (unless any other statically\n * \t// defined or shared regions have been declared elsewhere).\n * }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Remove a task from the RTOS real time kernel's management.\n *\n * The task being deleted will be removed from all ready, blocked, suspended\n * and event lists.\n *\n * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @note The idle task is responsible for freeing the kernel allocated\n * memory from tasks that have been deleted.  It is therefore important that\n * the idle task is not starved of microcontroller processing time if your\n * application makes any calls to vTaskDelete ().  Memory allocated by the\n * task code is not automatically freed, and should be freed before the task\n * is deleted.\n *\n * See the demo application file death.c for sample code that utilises\n * vTaskDelete ().\n *\n * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n * cause the calling task to be deleted.\n *\n * Example usage:\n * @code{c}\n *  void vOtherFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n * \t // Create the task, storing the handle.\n * \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n * \t // Use the handle to delete the task.\n * \t vTaskDelete( xHandle );\n *  }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\n/**\n * Delay a task for a given number of ticks.\n *\n * The actual time that the task remains blocked depends on the tick rate.\n * The constant portTICK_PERIOD_MS can be used to calculate real time from\n * the tick rate - with the resolution of one tick period.\n *\n * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * vTaskDelay() specifies a time at which the task wishes to unblock relative to\n * the time at which vTaskDelay() is called.  For example, specifying a block\n * period of 100 ticks will cause the task to unblock 100 ticks after\n * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n * of controlling the frequency of a periodic task as the path taken through the\n * code, as well as other task and interrupt activity, will effect the frequency\n * at which vTaskDelay() gets called and therefore the time at which the task\n * next executes.  See vTaskDelayUntil() for an alternative API function designed\n * to facilitate fixed frequency execution.  It does this by specifying an\n * absolute time (rather than a relative time) at which the calling task should\n * unblock.\n *\n * @param xTicksToDelay The amount of time, in tick periods, that\n * the calling task should block.\n *\n * Example usage:\n * @code{c}\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  // Block for 500ms.\n *  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n *\n * \t for( ;; )\n * \t {\n * \t\t // Simply toggle the LED every 500ms, blocking between each toggle.\n * \t\t vToggleLED();\n * \t\t vTaskDelay( xDelay );\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\n/**\n * Delay a task until a specified time.\n *\n * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * This function can be used by periodic tasks to ensure a constant execution frequency.\n *\n * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n * cause a task to block for the specified number of ticks from the time vTaskDelay () is\n * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n * execution frequency as the time between a task starting to execute and that task\n * calling vTaskDelay () may not be fixed [the task may take a different path though the\n * code between calls, or may get interrupted or preempted a different number of times\n * each time it executes].\n *\n * Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n * unblock.\n *\n * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick\n * rate - with the resolution of one tick period.\n *\n * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n * task was last unblocked.  The variable must be initialised with the current time\n * prior to its first use (see the example below).  Following this the variable is\n * automatically updated within vTaskDelayUntil ().\n *\n * @param xTimeIncrement The cycle time period.  The task will be unblocked at\n * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the\n * same xTimeIncrement parameter value will cause the task to execute with\n * a fixed interface period.\n *\n * Example usage:\n * @code{c}\n *  // Perform an action every 10 ticks.\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  TickType_t xLastWakeTime;\n *  const TickType_t xFrequency = 10;\n *\n * \t // Initialise the xLastWakeTime variable with the current time.\n * \t xLastWakeTime = xTaskGetTickCount ();\n * \t for( ;; )\n * \t {\n * \t\t // Wait for the next cycle.\n * \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );\n *\n * \t\t // Perform action here.\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the priority of any task.\n *\n * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to obtain the priority of the created task.\n *   // It was created with tskIDLE_PRIORITY, but may have changed\n *   // it itself.\n *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n *   {\n *       // The task has changed it's priority.\n *   }\n *\n *   // ...\n *\n *   // Is our priority higher than the created task?\n *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n *   {\n *       // Our priority (obtained using NULL handle) is higher.\n *   }\n * }\n * @endcode\n * \\ingroup TaskCtrl\n */\nUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * A version of uxTaskPriorityGet() that can be used from an ISR.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n */\nUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the state of any task.\n *\n * States are encoded by the eTaskState enumerated type.\n *\n * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.\n *\n * @return The state of xTask at the time the function was called.  Note the\n * state of the task might change between the function being called, and the\n * functions return value being tested by the calling task.\n */\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Set the priority of any task.\n *\n * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A context switch will occur before the function returns if the priority\n * being set is higher than the currently executing task.\n *\n * @param xTask Handle to the task for which the priority is being set.\n * Passing a NULL handle results in the priority of the calling task being set.\n *\n * @param uxNewPriority The priority to which the task will be set.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to raise the priority of the created task.\n *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n *\n *   // ...\n *\n *   // Use a NULL handle to raise our priority to the same value.\n *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\n/**\n * Suspend a task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * When suspended, a task will never get any microcontroller processing time,\n * no matter what its priority.\n *\n * Calls to vTaskSuspend are not accumulative -\n * i.e. calling vTaskSuspend () twice on the same task still only requires one\n * call to vTaskResume () to ready the suspended task.\n *\n * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n * handle will cause the calling task to be suspended.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Suspend ourselves.\n *   vTaskSuspend( NULL );\n *\n *   // We cannot get here unless another task calls vTaskResume\n *   // with our handle as the parameter.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes a suspended task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * vTaskResume ().\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Resume the suspended task ourselves.\n *   vTaskResume( xHandle );\n *\n *   // The created task will once again get microcontroller processing\n *   // time in accordance with its priority within the system.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/**\n * An implementation of vTaskResume() that can be called from within an ISR.\n *\n * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n * available.  See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * xTaskResumeFromISR ().\n *\n * xTaskResumeFromISR() should not be used to synchronise a task with an\n * interrupt if there is a chance that the interrupt could arrive prior to the\n * task being suspended - as this can lead to interrupts being missed. Use of a\n * semaphore as a synchronisation mechanism would avoid this eventuality.\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * @return pdTRUE if resuming the task should result in a context switch,\n * otherwise pdFALSE. This is used by the ISR to determine if a context switch\n * may be required following the ISR.\n *\n * \\ingroup TaskCtrl\n */\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n/** @cond */\n/**\n * Starts the real time kernel tick processing.\n *\n * After calling the kernel has control over which tasks are executed and when.\n *\n * See the demo application file main.c for an example of creating\n * tasks and starting the kernel.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will not get here unless a task calls vTaskEndScheduler ()\n *  }\n * @endcode\n *\n * \\ingroup SchedulerControl\n */\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Stops the real time kernel tick.\n *\n * @note At the time of writing only the x86 real mode port, which runs on a PC\n * in place of DOS, implements this function.\n *\n * All created tasks will be automatically deleted and multitasking\n * (either preemptive or cooperative) will stop.\n * Execution then resumes from the point where vTaskStartScheduler ()\n * was called, as if vTaskStartScheduler () had just returned.\n *\n * See the demo application file main. c in the demo/PC directory for an\n * example that uses vTaskEndScheduler ().\n *\n * vTaskEndScheduler () requires an exit function to be defined within the\n * portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n * performs hardware specific operations such as stopping the kernel tick.\n *\n * vTaskEndScheduler () will cause all of the resources allocated by the\n * kernel to be freed - but will not free resources allocated by application\n * tasks.\n *\n * Example usage:\n * @code{c}\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // At some point we want to end the real time kernel processing\n *       // so call ...\n *       vTaskEndScheduler ();\n *   }\n *  }\n *\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will only get here when the vTaskCode () task has called\n *   // vTaskEndScheduler ().  When we get here we are back to single task\n *   // execution.\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Suspends the scheduler without disabling interrupts.\n *\n * Context switches will not occur while the scheduler is suspended.\n *\n * After calling vTaskSuspendAll () the calling task will continue to execute\n * without risk of being swapped out until a call to xTaskResumeAll () has been\n * made.\n *\n * API functions that have the potential to cause a context switch (for example,\n * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n * is suspended.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the kernel\n *       // tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.\n *       xTaskResumeAll ();\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes scheduler activity after it was suspended by a call to\n * vTaskSuspendAll().\n *\n * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n * that were previously suspended by a call to vTaskSuspend().\n *\n * @return If resuming the scheduler caused a context switch then pdTRUE is\n *\t\t  returned, otherwise pdFALSE is returned.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the real\n *       // time kernel tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.  We want to force\n *       // a context switch - but there is no point if resuming the scheduler\n *       // caused a context switch already.\n *       if( !xTaskResumeAll () )\n *       {\n *            taskYIELD ();\n *       }\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\n/**\n * Get tick count\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get tick count from ISR\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * This is a version of xTaskGetTickCount() that is safe to be called from an\n * ISR - provided that TickType_t is the natural word size of the\n * microcontroller being used or interrupt nesting is either not supported or\n * not being used.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get current number of tasks\n *\n * @return The number of tasks that the real time kernel is currently managing.\n * This includes all ready, blocked and suspended tasks.  A task that\n * has been deleted but not yet freed by the idle task will also be\n * included in the count.\n *\n * \\ingroup TaskUtils\n */\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get task name\n *\n * @return The text (human readable) name of the task referenced by the handle\n * xTaskToQuery.  A task can query its own name by either passing in its own\n * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be\n * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.\n *\n * \\ingroup TaskUtils\n */\nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Returns the high water mark of the stack associated with xTask.\n *\n * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * High water mark is the minimum free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task started.\n * The smaller the returned number the closer the task has come to overflowing its stack.\n *\n * @param xTask Handle of the task associated with the stack to be checked.\n * Set xTask to NULL to check the stack of the calling task.\n *\n * @return The smallest amount of free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task referenced by\n * xTask was created.\n */\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Returns the start of the stack associated with xTask.\n *\n * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * Returns the highest stack memory address on architectures where the stack grows down\n * from high memory, and the lowest memory address on architectures where the\n * stack grows up from low memory.\n *\n * @param xTask Handle of the task associated with the stack returned.\n * Set xTask to NULL to return the stack of the calling task.\n *\n * @return A pointer to the start of the stack.\n */\nuint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n\t#if configUSE_APPLICATION_TASK_TAG == 1\n\t\t/**\n\t\t * Sets pxHookFunction to be the task hook function used by the task xTask.\n\t\t * @param xTask Handle of the task to set the hook function for\n\t\t *              Passing xTask as NULL has the effect of setting the calling\n\t\t *              tasks hook function.\n\t\t * @param pxHookFunction  Pointer to the hook function.\n\t\t */\n\t\tvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\n\t\t/**\n\t\t * Get the hook function assigned to given task.\n\t\t * @param xTask Handle of the task to get the hook function for\n\t\t *              Passing xTask as NULL has the effect of getting the calling\n\t\t *              tasks hook function.\n\t\t * @return The pxHookFunction value assigned to the task xTask.\n\t\t */\n\t\tTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\t#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )\n\n\t/**\n\t * Set local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t * @param xIndex The index of the pointer to set, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @param pvValue  Pointer value to set.\n\t */\n\tvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\n\n\n\t/**\n\t * Get local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToQuery  Task to get thread local storage pointer for\n\t * @param xIndex The index of the pointer to get, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @return  Pointer value\n\t */\n\tvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n\t#if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )\n\n\t\t/**\n\t\t * Prototype of local storage pointer deletion callback.\n\t\t */\n\t\ttypedef void (*TlsDeleteCallbackFunction_t)( int, void * );\n\n\t\t/**\n\t\t * Set local storage pointer and deletion callback.\n\t\t *\n\t\t * Each task contains an array of pointers that is dimensioned by the\n\t\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t\t * The kernel does not use the pointers itself, so the application writer\n\t\t * can use the pointers for any purpose they wish.\n\t\t *\n\t\t * Local storage pointers set for a task can reference dynamically\n\t\t * allocated resources. This function is similar to\n\t\t * vTaskSetThreadLocalStoragePointer, but provides a way to release\n\t\t * these resources when the task gets deleted. For each pointer,\n\t\t * a callback function can be set. This function will be called\n\t\t * when task is deleted, with the local storage pointer index\n\t\t * and value as arguments.\n\t\t *\n\t\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t\t * @param xIndex The index of the pointer to set, from 0 to\n\t\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t\t * @param pvValue  Pointer value to set.\n\t\t * @param pvDelCallback  Function to call to dispose of the local\n\t\t *                       storage pointer when the task is deleted.\n\t\t */\n\t\tvoid vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue, TlsDeleteCallbackFunction_t pvDelCallback);\n\t#endif\n\n#endif\n\n/**\n * Calls the hook function associated with xTask. Passing xTask as NULL has\n * the effect of calling the Running tasks (the calling task) hook function.\n *\n * @param xTask  Handle of the task to call the hook for.\n * @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n * wants.  The return value is the value returned by the task hook function\n * registered by the user.\n */\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\n/**\n * Get the handle of idle task for the current CPU.\n *\n * xTaskGetIdleTaskHandle() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @return The handle of the idle task.  It is not valid to call\n * xTaskGetIdleTaskHandle() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandle( void );\n\n/**\n * Get the handle of idle task for the given CPU.\n *\n * xTaskGetIdleTaskHandleForCPU() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @param cpuid The CPU to get the handle for\n *\n * @return Idle task handle of a given cpu. It is not valid to call\n * xTaskGetIdleTaskHandleForCPU() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandleForCPU( UBaseType_t cpuid );\n\n/**\n * Get the state of tasks in the system.\n *\n * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n * uxTaskGetSystemState() to be available.\n *\n * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n * the system.  TaskStatus_t structures contain, among other things, members\n * for the task handle, task name, task priority, task state, and total amount\n * of run time consumed by the task.  See the TaskStatus_t structure\n * definition in this file for the full member list.\n *\n * @note  This function is intended for debugging use only as its use results in\n * the scheduler remaining suspended for an extended period.\n *\n * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n * The array must contain at least one TaskStatus_t structure for each task\n * that is under the control of the RTOS.  The number of tasks under the control\n * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n *\n * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n * parameter.  The size is specified as the number of indexes in the array, or\n * the number of TaskStatus_t structures contained in the array, not by the\n * number of bytes in the array.\n *\n * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n * total run time (as defined by the run time stats clock, see\n * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.\n * pulTotalRunTime can be set to NULL to omit the total run time information.\n *\n * @return The number of TaskStatus_t structures that were populated by\n * uxTaskGetSystemState().  This should equal the number returned by the\n * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n * in the uxArraySize parameter was too small.\n *\n * Example usage:\n * @code{c}\n * // This example demonstrates how a human readable table of run time stats\n * // information is generated from raw data provided by uxTaskGetSystemState().\n * // The human readable table is written to pcWriteBuffer\n * void vTaskGetRunTimeStats( char *pcWriteBuffer )\n * {\n * TaskStatus_t *pxTaskStatusArray;\n * volatile UBaseType_t uxArraySize, x;\n * uint32_t ulTotalRunTime, ulStatsAsPercentage;\n *\n *  // Make sure the write buffer does not contain a string.\n *  *pcWriteBuffer = 0x00;\n *\n *  // Take a snapshot of the number of tasks in case it changes while this\n *  // function is executing.\n *  uxArraySize = uxTaskGetNumberOfTasks();\n *\n *  // Allocate a TaskStatus_t structure for each task.  An array could be\n *  // allocated statically at compile time.\n *  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n *\n *  if( pxTaskStatusArray != NULL )\n *  {\n *      // Generate raw status information about each task.\n *      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n *\n *      // For percentage calculations.\n *      ulTotalRunTime /= 100UL;\n *\n *      // Avoid divide by zero errors.\n *      if( ulTotalRunTime > 0 )\n *      {\n *          // For each populated position in the pxTaskStatusArray array,\n *          // format the raw data as human readable ASCII data\n *          for( x = 0; x < uxArraySize; x++ )\n *          {\n *              // What percentage of the total run time has the task used?\n *              // This will always be rounded down to the nearest integer.\n *              // ulTotalRunTimeDiv100 has already been divided by 100.\n *              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n *\n *              if( ulStatsAsPercentage > 0UL )\n *              {\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n *              }\n *              else\n *              {\n *                  // If the percentage is zero here then the task has\n *                  // consumed less than 1% of the total run time.\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n *              }\n *\n *              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n *          }\n *      }\n *\n *      // The array is no longer needed, free the memory it consumes.\n *      vPortFree( pxTaskStatusArray );\n *  }\n * }\n * @endcode\n */\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );\n\n/**\n * List all the current tasks.\n *\n * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n * both be defined as 1 for this function to be available.  See the\n * configuration section of the FreeRTOS.org website for more information.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Lists all the current tasks, along with their current state and stack\n * usage high water mark.\n *\n * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n * suspended ('S').\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays task\n * names, states and stack usage.\n *\n * vTaskList() has a dependency on the sprintf() C library function that might\n * bloat the code size, use a lot of stack, and provide different results on\n * different platforms.  An alternative, tiny, third party, and limited\n * functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState()\n * directly to get access to raw stats data, rather than indirectly through a\n * call to vTaskList().\n *\n * @param pcWriteBuffer A buffer into which the above mentioned details\n * will be written, in ASCII form.  This buffer is assumed to be large\n * enough to contain the generated report.  Approximately 40 bytes per\n * task should be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Get the state of running tasks as a string\n *\n * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n * must both be defined as 1 for this function to be available.  The application\n * must also then provide definitions for\n * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n * to configure a peripheral timer/counter and return the timers current count\n * value respectively.  The counter should be at least 10 times the frequency of\n * the tick count.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n * accumulated execution time being stored for each task.  The resolution\n * of the accumulated time value depends on the frequency of the timer\n * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n * Calling vTaskGetRunTimeStats() writes the total execution time of each\n * task into a buffer, both as an absolute count value and as a percentage\n * of the total system execution time.\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays the\n * amount of time each task has spent in the Running state in both absolute and\n * percentage terms.\n *\n * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n * that might bloat the code size, use a lot of stack, and provide different\n * results on different platforms.  An alternative, tiny, third party, and\n * limited functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState() directly\n * to get access to raw stats data, rather than indirectly through a call to\n * vTaskGetRunTimeStats().\n *\n * @param pcWriteBuffer A buffer into which the execution times will be\n * written, in ASCII form.  This buffer is assumed to be large enough to\n * contain the generated report.  Approximately 40 bytes per task should\n * be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Send task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\tupdated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\n/**\n * Send task notification from an ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotify() that can be used from an interrupt service routine\n * (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n * be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Wait for task notification\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n * will be cleared in the calling task's notification value before the task\n * checks to see if any notifications are pending, and optionally blocks if no\n * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n * the effect of resetting the task's notification value to 0.  Setting\n * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n *\n * @param ulBitsToClearOnExit If a notification is pending or received before\n * the calling task exits the xTaskNotifyWait() function then the task's\n * notification value (see the xTaskNotify() API function) is passed out using\n * the pulNotificationValue parameter.  Then any bits that are set in\n * ulBitsToClearOnExit will be cleared in the task's notification value (note\n * *pulNotificationValue is set before any bits are cleared).  Setting\n * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n * (if limits.h is not included) will have the effect of resetting the task's\n * notification value to 0 before the function exits.  Setting\n * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n * when the function exits (in which case the value passed out in\n * pulNotificationValue will match the task's notification value).\n *\n * @param pulNotificationValue Used to pass the task's notification value out\n * of the function.  Note the value passed out will not be effected by the\n * clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for a notification to be received, should a notification\n * not already be pending when xTaskNotifyWait() was called.  The task\n * will not consume any processing time while it is in the Blocked state.  This\n * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be\n * used to convert a time specified in milliseconds to a time specified in\n * ticks.\n *\n * @return If a notification was received (including notifications that were\n * already pending when xTaskNotifyWait was called) then pdPASS is\n * returned.  Otherwise pdFAIL is returned.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n/**\n * Simplified macro for sending task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * xTaskNotifyGive() is a helper macro intended for use when task notifications\n * are used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,\n * the equivalent action that instead uses a task notification is\n * xTaskNotifyGive().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the\n * eAction parameter set to eIncrement - so pdPASS is always returned.\n *\n * \\ingroup TaskNotifications\n */\n#define xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )\n\n/**\n * Simplified macro for sending task notification from ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotifyGive() that can be called from an interrupt service\n * routine (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * vTaskNotifyGiveFromISR() is intended for use when task notifications are\n * used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given from an ISR using the\n * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n * a task notification is vTaskNotifyGiveFromISR().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n * should be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * \\ingroup TaskNotifications\n */\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Simplified macro for receiving task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * ulTaskNotifyTake() is intended for use when a task notification is used as a\n * faster and lighter weight binary or counting semaphore alternative.  Actual\n * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the\n * equivalent action that instead uses a task notification is\n * ulTaskNotifyTake().\n *\n * When a task is using its notification value as a binary or counting semaphore\n * other tasks should send notifications to it using the xTaskNotifyGive()\n * macro, or xTaskNotify() function with the eAction parameter set to\n * eIncrement.\n *\n * ulTaskNotifyTake() can either clear the task's notification value to\n * zero on exit, in which case the notification value acts like a binary\n * semaphore, or decrement the task's notification value on exit, in which case\n * the notification value acts like a counting semaphore.\n *\n * A task can use ulTaskNotifyTake() to [optionally] block to wait for a\n * the task's notification value to be non-zero.  The task does not consume any\n * CPU time while it is in the Blocked state.\n *\n * Where as xTaskNotifyWait() will return when a notification is pending,\n * ulTaskNotifyTake() will return when the task's notification value is\n * not zero.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n * notification value is decremented when the function exits.  In this way the\n * notification value acts like a counting semaphore.  If xClearCountOnExit is\n * not pdFALSE then the task's notification value is cleared to zero when the\n * function exits.  In this way the notification value acts like a binary\n * semaphore.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for the task's notification value to be greater than zero,\n * should the count not already be greater than zero when\n * ulTaskNotifyTake() was called.  The task will not consume any processing\n * time while it is in the Blocked state.  This is specified in kernel ticks,\n * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time\n * specified in milliseconds to a time specified in ticks.\n *\n * @return The task's notification count before it is either cleared to zero or\n * decremented (see the xClearCountOnExit parameter).\n *\n * \\ingroup TaskNotifications\n */\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n/** @cond */\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * xTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n * Return the handle of the task running on a certain CPU. Because of\n * the nature of SMP processing, there is no guarantee that this\n * value will still be valid on return and should only be used for\n * debugging purposes.\n */\nTaskHandle_t xTaskGetCurrentTaskHandleForCPU( BaseType_t cpuid );\n\n\n/*\n * Capture the current time status for future reference.\n */\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n/*\n * Compare the time status now with that previously captured to see if the\n * timeout has expired.\n */\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n\n/*\n * Get the current core affinity of a task\n */\nBaseType_t xTaskGetAffinity( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/*\n * Only avilable when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nvoid *pvTaskIncrementMutexHeldCount( void );\n\n/*\n * This function fills array with TaskSnapshot_t structures for every task in the system.\n * Used by core dump facility to get snapshots of all tasks in the system.\n * Only available when configENABLE_TASK_SNAPSHOT is set to 1.\n * @param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.\n * @param uxArraySize Size of tasks snapshots array.\n * @param pxTcbSz Pointer to store size of TCB.\n * @return Number of elements stored in array.\n */\nUBaseType_t uxTaskGetSnapshotAll( TaskSnapshot_t * const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t * const pxTcbSz );\n\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n\n\n\n"}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h"}}}
>>>
Content-Length: 205

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":428,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":8}}}
>>>
Content-Length: 670

{"id":428,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":8},"end":{"line":312,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":429,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":8}}}
>>>
Content-Length: 670

{"id":429,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":8},"end":{"line":312,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":430,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":4},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":430,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":268,"character":4},"end":{"line":268,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":729},"contentChanges":[{"range":{"start":{"line":268,"character":4},"end":{"line":268,"character":8}},"rangeLength":4,"text":"1"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":431,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":431,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":729}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":730},"contentChanges":[{"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":5}},"rangeLength":0,"text":"5"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":731},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":732},"contentChanges":[{"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":432,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":8},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":432,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":732}}}Content-Length: 209

{"jsonrpc":"2.0","id":433,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":2}}}
>>>
Content-Length: 40

{"id":433,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":434,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":0}}}
>>>
Content-Length: 40

{"id":434,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":435,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":0}}}
>>>
Content-Length: 40

{"id":435,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":436,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":18}}}
>>>
Content-Length: 40

{"id":436,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":437,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":18}}}
>>>
Content-Length: 40

{"id":437,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":438,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":19}}}
>>>
Content-Length: 40

{"id":438,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":439,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":3}}}
>>>
Content-Length: 175

{"id":439,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":440,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":278,"character":10}}}
>>>
Content-Length: 40

{"id":440,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":441,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":11}}}
>>>
Content-Length: 40

{"id":441,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":442,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":278,"character":9}}}
>>>
Content-Length: 670

{"id":442,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":313,"character":8},"end":{"line":313,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":443,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":7}}}
>>>
Content-Length: 40

{"id":443,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":444,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":269,"character":6}}}
>>>
Content-Length: 216

{"id":444,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":304,"character":4},"end":{"line":304,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":445,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":7}}}
>>>
Content-Length: 38

{"id":445,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":446,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":446,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":447,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":447,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":448,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":448,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":449,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":8},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":449,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":450,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":4},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":450,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":268,"character":4},"end":{"line":268,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":451,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":5}}}
>>>
Content-Length: 38

{"id":451,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":452,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":452,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":268,"character":5},"end":{"line":268,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":733},"contentChanges":[{"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":8}},"rangeLength":3,"text":"1"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":453,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":453,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":733}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":734},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"6"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":735},"contentChanges":[{"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":454,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":8},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":454,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":735}}}Content-Length: 209

{"jsonrpc":"2.0","id":455,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":8}}}
>>>
Content-Length: 175

{"id":455,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":456,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":9}}}
>>>
Content-Length: 175

{"id":456,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":457,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":9}}}
>>>
Content-Length: 175

{"id":457,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":458,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":7}}}
>>>
Content-Length: 40

{"id":458,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":459,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":271,"character":11}}}
>>>
Content-Length: 40

{"id":459,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":460,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":11}}}
>>>
Content-Length: 40

{"id":460,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":461,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":11}}}
>>>
Content-Length: 40

{"id":461,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":462,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":11}}}
>>>
Content-Length: 40

{"id":462,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":463,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":11}}}
>>>
Content-Length: 40

{"id":463,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":464,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":8}}}
>>>
Content-Length: 40

{"id":464,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":465,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":8}}}
>>>
Content-Length: 40

{"id":465,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":466,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":8}}}
>>>
Content-Length: 40

{"id":466,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":467,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":12}}}
>>>
Content-Length: 671

{"id":467,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":309,"character":2},"end":{"line":309,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":468,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":7}}}
>>>
Content-Length: 175

{"id":468,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":469,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":286,"character":7}}}
>>>
Content-Length: 175

{"id":469,"error":{"code":0,"message":"Document is not available: file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":470,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":274,"character":10}}}
>>>
Content-Length: 671

{"id":470,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":309,"character":2},"end":{"line":309,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":471,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":7}}}
>>>
Content-Length: 40

{"id":471,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":472,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":7}}}
>>>
Content-Length: 38

{"id":472,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":473,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":473,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":474,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":278,"character":2}}}
>>>
Content-Length: 40

{"id":474,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":736},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":475,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":475,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":737},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"2"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":476,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":476,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":737}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":738},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":739},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"3"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":477,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":477,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":740},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":741},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"4"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":478,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":478,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":741}}}Content-Length: 209

{"jsonrpc":"2.0","id":479,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":8}}}
>>>
Content-Length: 216

{"id":479,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":315,"character":4},"end":{"line":315,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":480,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":21}}}
>>>
Content-Length: 40

{"id":480,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":481,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":25}}}
>>>
Content-Length: 40

{"id":481,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":482,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":268,"character":6}}}
>>>
Content-Length: 38

{"id":482,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":483,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":483,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":742},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":7}},"rangeLength":1,"text":""}]}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":743},"contentChanges":[{"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":484,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":484,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":744},"contentChanges":[{"range":{"start":{"line":268,"character":5},"end":{"line":268,"character":5}},"rangeLength":0,"text":"2"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":485,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":485,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":745},"contentChanges":[{"range":{"start":{"line":268,"character":6},"end":{"line":268,"character":6}},"rangeLength":0,"text":"0"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":746},"contentChanges":[{"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":486,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":8},"end":{"line":268,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":486,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":747},"contentChanges":[{"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":8}},"rangeLength":1,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":487,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":268,"character":7},"end":{"line":268,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":487,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":747}}}Content-Length: 209

{"jsonrpc":"2.0","id":488,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":269,"character":7}}}
>>>
Content-Length: 216

{"id":488,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":304,"character":4},"end":{"line":304,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":489,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":26}}}
>>>
Content-Length: 279

{"id":489,"result":{"contents":{"kind":"markdown","value":"### macro `portTICK_PERIOD_MS`  \n\n---\n```cpp\n#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)\n```"},"range":{"start":{"line":274,"character":19},"end":{"line":274,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":490,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":27}}}
>>>
Content-Length: 38

{"id":490,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":491,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":27},"end":{"line":239,"character":27}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 391

{"id":491,"result":[{"title":"Expand macro 'portTICK_PERIOD_MS'","kind":"refactor","command":{"title":"Expand macro 'portTICK_PERIOD_MS'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":274,"character":27},"end":{"line":274,"character":27}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":492,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":27}}}
>>>
Content-Length: 240

{"id":492,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/portmacro.h","range":{"start":{"line":365,"character":8},"end":{"line":365,"character":26}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 24079

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/portmacro.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that has become a de facto standard.             *\n     *                                                                       *\n     *    Help yourself get started quickly and support the FreeRTOS         *\n     *    project by purchasing a FreeRTOS tutorial book, reference          *\n     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *\n     *                                                                       *\n     *    Thank you!                                                         *\n     *                                                                       *\n    ***************************************************************************\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available from the following\n    link: http://www.freertos.org/a00114.html\n\n    1 tab == 4 spaces!\n\n    ***************************************************************************\n     *                                                                       *\n     *    Having a problem?  Start by reading the FAQ \"My application does   *\n     *    not run, what could be wrong?\"                                     *\n     *                                                                       *\n     *    http://www.FreeRTOS.org/FAQHelp.html                               *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org - Documentation, books, training, latest versions,\n    license and Real Time Engineers Ltd. contact details.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High\n    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n#ifndef PORTMACRO_H\n#define PORTMACRO_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef __ASSEMBLER__\n\n#include <stdint.h>\n\n#include <xtensa/hal.h>\n#include <xtensa/config/core.h>\n#include <xtensa/config/system.h>\t/* required for XSHAL_CLIB */\n#include <xtensa/xtruntime.h>\n#include \"esp_crosscore_int.h\"\n#include \"esp_timer.h\"              /* required for FreeRTOS run time stats */\n\n\n#include <esp_heap_caps.h>\n#include \"soc/soc_memory_layout.h\"\n\n//#include \"xtensa_context.h\"\n\n/*-----------------------------------------------------------\n * Port specific definitions.\n *\n * The settings in this file configure FreeRTOS correctly for the\n * given hardware and compiler.\n *\n * These settings should not be altered.\n *-----------------------------------------------------------\n */\n\n/* Type definitions. */\n\n#define portCHAR\t\tint8_t\n#define portFLOAT\t\tfloat\n#define portDOUBLE\t\tdouble\n#define portLONG\t\tint32_t\n#define portSHORT\t\tint16_t\n#define portSTACK_TYPE\tuint8_t\n#define portBASE_TYPE\tint\n\ntypedef portSTACK_TYPE\t\t\tStackType_t;\ntypedef portBASE_TYPE\t\t\tBaseType_t;\ntypedef unsigned portBASE_TYPE\tUBaseType_t;\n\n#if( configUSE_16_BIT_TICKS == 1 )\n\ttypedef uint16_t TickType_t;\n\t#define portMAX_DELAY ( TickType_t ) 0xffff\n#else\n\ttypedef uint32_t TickType_t;\n\t#define portMAX_DELAY ( TickType_t ) 0xffffffffUL\n#endif\n/*-----------------------------------------------------------*/\n\n// portbenchmark\n#include \"portbenchmark.h\"\n\n#include \"sdkconfig.h\"\n#include \"esp_attr.h\"\n\n/* \"mux\" data structure (spinlock) */\ntypedef struct {\n\t/* owner field values:\n\t * 0                - Uninitialized (invalid)\n\t * portMUX_FREE_VAL - Mux is free, can be locked by either CPU\n\t * CORE_ID_PRO / CORE_ID_APP - Mux is locked to the particular core\n\t *\n\t * Any value other than portMUX_FREE_VAL, CORE_ID_PRO, CORE_ID_APP indicates corruption\n\t */\n\tuint32_t owner;\n\t/* count field:\n\t * If mux is unlocked, count should be zero.\n\t * If mux is locked, count is non-zero & represents the number of recursive locks on the mux.\n\t */\n\tuint32_t count;\n#ifdef CONFIG_FREERTOS_PORTMUX_DEBUG\n\tconst char *lastLockedFn;\n\tint lastLockedLine;\n#endif\n} portMUX_TYPE;\n\n#define portMUX_FREE_VAL\t\t0xB33FFFFF\n\n/* Special constants for vPortCPUAcquireMutexTimeout() */\n#define portMUX_NO_TIMEOUT      (-1)  /* When passed for 'timeout_cycles', spin forever if necessary */\n#define portMUX_TRY_LOCK        0     /* Try to acquire the spinlock a single time only */\n\n// Keep this in sync with the portMUX_TYPE struct definition please.\n#ifndef CONFIG_FREERTOS_PORTMUX_DEBUG\n#define portMUX_INITIALIZER_UNLOCKED {\t\t\t\t\t\\\n\t\t.owner = portMUX_FREE_VAL,\t\t\t\t\t\t\\\n\t\t.count = 0,\t\t\t\t\t\t\t\t\t\t\\\n\t}\n#else\n#define portMUX_INITIALIZER_UNLOCKED {\t\t\t\t\t\\\n\t\t.owner = portMUX_FREE_VAL,\t\t\t\t\t\t\\\n\t\t.count = 0,\t\t\t\t\t\t\t\t\t\t\\\n\t\t.lastLockedFn = \"(never locked)\",\t\t\t\t\\\n\t\t.lastLockedLine = -1\t\t\t\t\t\t\t\\\n\t}\n#endif\n\n\n#define portASSERT_IF_IN_ISR()        vPortAssertIfInISR()\nvoid vPortAssertIfInISR();\n\n#define portCRITICAL_NESTING_IN_TCB 1\n\n/*\nModifications to portENTER_CRITICAL.\n\nFor an introduction, see \"Critical Sections & Disabling Interrupts\" in docs/api-guides/freertos-smp.rst\n\nThe original portENTER_CRITICAL only disabled the ISRs. This is enough for single-CPU operation: by\ndisabling the interrupts, there is no task switch so no other tasks can meddle in the data, and because\ninterrupts are disabled, ISRs can't corrupt data structures either.\n\nFor multiprocessing, things get a bit more hairy. First of all, disabling the interrupts doesn't stop\nthe tasks or ISRs on the other processors meddling with our CPU. For tasks, this is solved by adding\na spinlock to the portENTER_CRITICAL macro. A task running on the other CPU accessing the same data will\nspinlock in the portENTER_CRITICAL code until the first CPU is done.\n\nFor ISRs, we now also need muxes: while portENTER_CRITICAL disabling interrupts will stop ISRs on the same\nCPU from meddling with the data, it does not stop interrupts on the other cores from interfering with the\ndata. For this, we also use a spinlock in the routines called by the ISR, but these spinlocks\ndo not disable the interrupts (because they already are).\n\nThis all assumes that interrupts are either entirely disabled or enabled. Interrupt priority levels\nwill break this scheme.\n\nRemark: For the ESP32, portENTER_CRITICAL and portENTER_CRITICAL_ISR both alias vTaskEnterCritical, meaning\nthat either function can be called both from ISR as well as task context. This is not standard FreeRTOS \nbehaviour; please keep this in mind if you need any compatibility with other FreeRTOS implementations.\n*/\nvoid vPortCPUInitializeMutex(portMUX_TYPE *mux);\n#ifdef CONFIG_FREERTOS_PORTMUX_DEBUG\nvoid vPortCPUAcquireMutex(portMUX_TYPE *mux, const char *function, int line);\nbool vPortCPUAcquireMutexTimeout(portMUX_TYPE *mux, int timeout_cycles, const char *function, int line);\nvoid vPortCPUReleaseMutex(portMUX_TYPE *mux, const char *function, int line);\n\n\nvoid vTaskEnterCritical( portMUX_TYPE *mux, const char *function, int line );\nvoid vTaskExitCritical( portMUX_TYPE *mux, const char *function, int line );\n\n#ifdef CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE\n/* Calling port*_CRITICAL from ISR context would cause an assert failure.\n * If the parent function is called from both ISR and Non-ISR context then call port*_CRITICAL_SAFE\n */\n#define portENTER_CRITICAL(mux)        do {                                                                                             \\\n                                            if(!xPortInIsrContext()) {                                                                  \\\n                                                vTaskEnterCritical(mux, __FUNCTION__, __LINE__);                                        \\\n                                            } else {                                                                                    \\\n                                                ets_printf(\"%s:%d (%s)- port*_CRITICAL called from ISR context!\\n\", __FILE__, __LINE__, \\\n                                                           __FUNCTION__);                                                               \\\n                                                abort();                                                                                \\\n                                            }                                                                                           \\\n                                       } while(0)\n\n#define portEXIT_CRITICAL(mux)        do {                                                                                              \\\n                                            if(!xPortInIsrContext()) {                                                                  \\\n                                                vTaskExitCritical(mux, __FUNCTION__, __LINE__);                                         \\\n                                            } else {                                                                                    \\\n                                                ets_printf(\"%s:%d (%s)- port*_CRITICAL called from ISR context!\\n\", __FILE__, __LINE__, \\\n                                                           __FUNCTION__);                                                               \\\n                                                abort();                                                                                \\\n                                            }                                                                                           \\\n                                       } while(0)\n#else\n#define portENTER_CRITICAL(mux)        vTaskEnterCritical(mux, __FUNCTION__, __LINE__)\n#define portEXIT_CRITICAL(mux)         vTaskExitCritical(mux, __FUNCTION__, __LINE__)\n#endif\n#define portENTER_CRITICAL_ISR(mux)    vTaskEnterCritical(mux, __FUNCTION__, __LINE__)\n#define portEXIT_CRITICAL_ISR(mux)     vTaskExitCritical(mux, __FUNCTION__, __LINE__)\n#else\nvoid vTaskExitCritical( portMUX_TYPE *mux );\nvoid vTaskEnterCritical( portMUX_TYPE *mux );\nvoid vPortCPUAcquireMutex(portMUX_TYPE *mux);\n\n/** @brief Acquire a portmux spinlock with a timeout\n *\n * @param mux Pointer to portmux to acquire.\n * @param timeout_cycles Timeout to spin, in CPU cycles. Pass portMUX_NO_TIMEOUT to wait forever,\n * portMUX_TRY_LOCK to try a single time to acquire the lock.\n *\n * @return true if mutex is successfully acquired, false on timeout.\n */\nbool vPortCPUAcquireMutexTimeout(portMUX_TYPE *mux, int timeout_cycles);\nvoid vPortCPUReleaseMutex(portMUX_TYPE *mux);\n\n#ifdef CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE\n/* Calling port*_CRITICAL from ISR context would cause an assert failure.\n * If the parent function is called from both ISR and Non-ISR context then call port*_CRITICAL_SAFE\n */\n#define portENTER_CRITICAL(mux)        do {                                                                                             \\\n                                            if(!xPortInIsrContext()) {                                                                  \\\n                                                vTaskEnterCritical(mux);                                                                \\\n                                            } else {                                                                                    \\\n                                                ets_printf(\"%s:%d (%s)- port*_CRITICAL called from ISR context!\\n\", __FILE__, __LINE__, \\\n                                                           __FUNCTION__);                                                               \\\n                                                abort();                                                                                \\\n                                            }                                                                                           \\\n                                       } while(0)\n\n#define portEXIT_CRITICAL(mux)        do {                                                                                              \\\n                                            if(!xPortInIsrContext()) {                                                                  \\\n                                                vTaskExitCritical(mux);                                                                 \\\n                                            } else {                                                                                    \\\n                                                ets_printf(\"%s:%d (%s)- port*_CRITICAL called from ISR context!\\n\", __FILE__, __LINE__, \\\n                                                           __FUNCTION__);                                                               \\\n                                                abort();                                                                                \\\n                                            }                                                                                           \\\n                                       } while(0)\n#else\n#define portENTER_CRITICAL(mux)        vTaskEnterCritical(mux)\n#define portEXIT_CRITICAL(mux)         vTaskExitCritical(mux)\n#endif\n#define portENTER_CRITICAL_ISR(mux)    vTaskEnterCritical(mux)\n#define portEXIT_CRITICAL_ISR(mux)     vTaskExitCritical(mux)\n#endif\n\n#define portENTER_CRITICAL_SAFE(mux)  do {                                             \\\n                                         if (xPortInIsrContext()) {                    \\\n                                             portENTER_CRITICAL_ISR(mux);              \\\n                                         } else {                                      \\\n                                             portENTER_CRITICAL(mux);                  \\\n                                         }                                             \\\n                                      } while(0)\n\n#define portEXIT_CRITICAL_SAFE(mux)  do {                                              \\\n                                         if (xPortInIsrContext()) {                    \\\n                                             portEXIT_CRITICAL_ISR(mux);               \\\n                                         } else {                                      \\\n                                             portEXIT_CRITICAL(mux);                   \\\n                                         }                                             \\\n                                      } while(0)\n\n\n// Critical section management. NW-TODO: replace XTOS_SET_INTLEVEL with more efficient version, if any?\n// These cannot be nested. They should be used with a lot of care and cannot be called from interrupt level.\n//\n// Only applies to one CPU. See notes above & below for reasons not to use these.\n#define portDISABLE_INTERRUPTS()      do { XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL); portbenchmarkINTERRUPT_DISABLE(); } while (0)\n#define portENABLE_INTERRUPTS()       do { portbenchmarkINTERRUPT_RESTORE(0); XTOS_SET_INTLEVEL(0); } while (0)\n\n// Cleaner solution allows nested interrupts disabling and restoring via local registers or stack.\n// They can be called from interrupts too.\n// WARNING: Only applies to current CPU. See notes above.\nstatic inline unsigned portENTER_CRITICAL_NESTED() {\n\tunsigned state = XTOS_SET_INTLEVEL(XCHAL_EXCM_LEVEL);\n\tportbenchmarkINTERRUPT_DISABLE();\n\treturn state;\n}\n#define portEXIT_CRITICAL_NESTED(state)   do { portbenchmarkINTERRUPT_RESTORE(state); XTOS_RESTORE_JUST_INTLEVEL(state); } while (0)\n\n// These FreeRTOS versions are similar to the nested versions above\n#define portSET_INTERRUPT_MASK_FROM_ISR()            portENTER_CRITICAL_NESTED()\n#define portCLEAR_INTERRUPT_MASK_FROM_ISR(state)     portEXIT_CRITICAL_NESTED(state)\n\n//Because the ROM routines don't necessarily handle a stack in external RAM correctly, we force\n//the stack memory to always be internal.\n#define portTcbMemoryCaps (MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT)\n#define portStackMemoryCaps (MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT)\n\n#define pvPortMallocTcbMem(size) heap_caps_malloc(size, portTcbMemoryCaps)\n#define pvPortMallocStackMem(size)  heap_caps_malloc(size, portStackMemoryCaps)\n\n//xTaskCreateStatic uses these functions to check incoming memory.\n#define portVALID_TCB_MEM(ptr) (esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr))\n#ifdef CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY\n#define portVALID_STACK_MEM(ptr) esp_ptr_byte_accessible(ptr)\n#else\n#define portVALID_STACK_MEM(ptr) (esp_ptr_internal(ptr) && esp_ptr_byte_accessible(ptr))\n#endif\n\n/*\n * Wrapper for the Xtensa compare-and-set instruction. This subroutine will atomically compare\n * *addr to 'compare'. If *addr == compare, *addr is set to *set. *set is updated with the previous\n * value of *addr (either 'compare' or some other value.)\n *\n * Warning: From the ISA docs: in some (unspecified) cases, the s32c1i instruction may return the\n * *bitwise inverse* of the old mem if the mem wasn't written. This doesn't seem to happen on the\n * ESP32 (portMUX assertions would fail).\n */\nstatic inline void uxPortCompareSet(volatile uint32_t *addr, uint32_t compare, uint32_t *set) {\n    __asm__ __volatile__ (\n        \"WSR \t    %2,SCOMPARE1 \\n\"\n        \"S32C1I     %0, %1, 0\t \\n\"\n        :\"=r\"(*set)\n        :\"r\"(addr), \"r\"(compare), \"0\"(*set)\n        );\n}\n\n\n/*-----------------------------------------------------------*/\n\n/* Architecture specifics. */\n#define portSTACK_GROWTH\t\t\t( -1 )\n#define portTICK_PERIOD_MS\t\t\t( ( TickType_t ) 1000 / configTICK_RATE_HZ )\n#define portBYTE_ALIGNMENT\t\t\t4\n#define portNOP()\t\t\t\t\tXT_NOP()\n/*-----------------------------------------------------------*/\n\n/* Fine resolution time */\n#define portGET_RUN_TIME_COUNTER_VALUE()  xthal_get_ccount()\n//ccount or esp_timer are initialized elsewhere\n#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()\n\n#ifdef CONFIG_FREERTOS_RUN_TIME_STATS_USING_ESP_TIMER\n/* Coarse resolution time (us) */\n#define portALT_GET_RUN_TIME_COUNTER_VALUE(x)    x = (uint32_t)esp_timer_get_time()\n#endif\n\n\n\n/* Kernel utilities. */\nvoid vPortYield( void );\nvoid _frxt_setup_switch( void );\n#define portYIELD()\t\t\t\t\tvPortYield()\n#define portYIELD_FROM_ISR()        {traceISR_EXIT_TO_SCHEDULER(); _frxt_setup_switch();}\n\nstatic inline uint32_t xPortGetCoreID();\n\n/* Yielding within an API call (when interrupts are off), means the yield should be delayed\n   until interrupts are re-enabled.\n\n   To do this, we use the \"cross-core\" interrupt as a trigger to yield on this core when interrupts are re-enabled.This\n   is the same interrupt & code path which is used to trigger a yield between CPUs, although in this case the yield is\n   happening on the same CPU.\n*/\n#define portYIELD_WITHIN_API() esp_crosscore_int_send_yield(xPortGetCoreID())\n\n/*-----------------------------------------------------------*/\n\n/* Task function macros as described on the FreeRTOS.org WEB site. */\n#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )\n#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )\n\n// When coprocessors are defined, we to maintain a pointer to coprocessors area.\n// We currently use a hack: redefine field xMPU_SETTINGS in TCB block as a structure that can hold:\n// MPU wrappers, coprocessor area pointer, trace code structure, and more if needed.\n// The field is normally used for memory protection. FreeRTOS should create another general purpose field.\ntypedef struct {\n\t#if XCHAL_CP_NUM > 0\n\tvolatile StackType_t* coproc_area; // Pointer to coprocessor save area; MUST BE FIRST\n\t#endif\n\n\t#if portUSING_MPU_WRAPPERS\n\t// Define here mpu_settings, which is port dependent\n\tint mpu_setting; // Just a dummy example here; MPU not ported to Xtensa yet\n\t#endif\n\n\t#if configUSE_TRACE_FACILITY_2\n\tstruct {\n\t\t// Cf. porttraceStamp()\n\t\tint taskstamp;        /* Stamp from inside task to see where we are */\n\t\tint taskstampcount;   /* A counter usually incremented when we restart the task's loop */\n\t} porttrace;\n\t#endif\n} xMPU_SETTINGS;\n\n// Main hack to use MPU_wrappers even when no MPU is defined (warning: mpu_setting should not be accessed; otherwise move this above xMPU_SETTINGS)\n#if (XCHAL_CP_NUM > 0 || configUSE_TRACE_FACILITY_2) && !portUSING_MPU_WRAPPERS   // If MPU wrappers not used, we still need to allocate coproc area\n\t#undef portUSING_MPU_WRAPPERS\n\t#define portUSING_MPU_WRAPPERS 1   // Enable it to allocate coproc area\n\t#define MPU_WRAPPERS_H             // Override mpu_wrapper.h to disable unwanted code\n\t#define PRIVILEGED_FUNCTION\n\t#define PRIVILEGED_DATA\n#endif\n\nextern void esp_vApplicationIdleHook( void );\nextern void esp_vApplicationTickHook( void );\n\n#ifndef CONFIG_FREERTOS_LEGACY_HOOKS\n#define vApplicationIdleHook    esp_vApplicationIdleHook\n#define vApplicationTickHook    esp_vApplicationTickHook\n#endif /* !CONFIG_FREERTOS_LEGACY_HOOKS */\n\nvoid _xt_coproc_release(volatile void * coproc_sa_base);\nvoid vApplicationSleep( TickType_t xExpectedIdleTime );\n\n#define portSUPPRESS_TICKS_AND_SLEEP( idleTime ) vApplicationSleep( idleTime )\n\n// porttrace\n#if configUSE_TRACE_FACILITY_2\n#include \"porttrace.h\"\n#endif\n\n// configASSERT_2 if requested\n#if configASSERT_2\n#include <stdio.h>\nvoid exit(int);\n#define configASSERT( x )   if (!(x)) { porttracePrint(-1); printf(\"\\nAssertion failed in %s:%d\\n\", __FILE__, __LINE__); exit(-1); }\n#endif\n\n#endif // __ASSEMBLER__\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* PORTMACRO_H */\n\n"}}}Content-Length: 200

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/portmacro.h"}}}
>>>
Content-Length: 210

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/portmacro.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":493,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":28},"end":{"line":239,"character":28}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 391

{"id":493,"result":[{"title":"Expand macro 'portTICK_PERIOD_MS'","kind":"refactor","command":{"title":"Expand macro 'portTICK_PERIOD_MS'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":274,"character":28},"end":{"line":274,"character":28}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":494,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":5},"end":{"line":239,"character":39}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 366

{"id":494,"result":[{"title":"Extract to function","kind":"refactor","command":{"title":"Extract to function","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractFunction","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":273,"character":5},"end":{"line":274,"character":39}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":495,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":6}}}
>>>
Content-Length: 270

{"id":495,"result":{"contents":{"kind":"markdown","value":"### variable `Serial`  \n\n---\nType: `class HardwareSerial`  \n\n---\n```cpp\nextern HardwareSerial Serial\n```"},"range":{"start":{"line":273,"character":4},"end":{"line":273,"character":10}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":496,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":239,"character":33}}}
>>>
Content-Length: 279

{"id":496,"result":{"contents":{"kind":"markdown","value":"### macro `portTICK_PERIOD_MS`  \n\n---\n```cpp\n#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)\n```"},"range":{"start":{"line":274,"character":19},"end":{"line":274,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":497,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":33},"end":{"line":239,"character":33}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 391

{"id":497,"result":[{"title":"Expand macro 'portTICK_PERIOD_MS'","kind":"refactor","command":{"title":"Expand macro 'portTICK_PERIOD_MS'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":274,"character":33},"end":{"line":274,"character":33}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":498,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":238,"character":54}}}
>>>
Content-Length: 40

{"id":498,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":499,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":238,"character":54},"end":{"line":238,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":499,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":500,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":4},"end":{"line":238,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 366

{"id":500,"result":[{"title":"Extract to function","kind":"refactor","command":{"title":"Extract to function","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractFunction","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":272,"character":4},"end":{"line":273,"character":54}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":501,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":3}}}
>>>
Content-Length: 40

{"id":501,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":502,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":4}}}
>>>
Content-Length: 222

{"id":502,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 214

{"jsonrpc":"2.0","id":503,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":4}}}
>>>
Content-Length: 222

{"id":503,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","range":{"start":{"line":115,"character":22},"end":{"line":115,"character":28}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 4114

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","languageId":"cpp","version":1,"text":"/*\n HardwareSerial.h - Hardware serial library for Wiring\n Copyright (c) 2006 Nicholas Zambetti.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\n Modified 28 September 2010 by Mark Sproul\n Modified 14 August 2012 by Alarus\n Modified 3 December 2013 by Matthijs Kooijman\n Modified 18 December 2014 by Ivan Grokhotkov (esp8266 platform support)\n Modified 31 March 2015 by Markus Sattler (rewrite the code for UART0 + UART1 support in ESP8266)\n Modified 25 April 2015 by Thomas Flayols (add configuration different from 8N1 in ESP8266)\n Modified 13 October 2018 by Jeroen Dll (add baudrate detection)\n Baudrate detection example usage (detection on Serial1):\n   void setup() {\n     Serial.begin(115200);\n     delay(100);\n     Serial.println();\n\n     Serial1.begin(0, SERIAL_8N1, -1, -1, true, 11000UL);  // Passing 0 for baudrate to detect it, the last parameter is a timeout in ms\n\n     unsigned long detectedBaudRate = Serial1.baudRate();\n     if(detectedBaudRate) {\n       Serial.printf(\"Detected baudrate is %lu\\n\", detectedBaudRate);\n     } else {\n       Serial.println(\"No baudrate detected, Serial1 will not work!\");\n     }\n   }\n\n Pay attention: the baudrate returned by baudRate() may be rounded, eg 115200 returns 115201\n */\n\n#ifndef HardwareSerial_h\n#define HardwareSerial_h\n\n#include <inttypes.h>\n\n#include \"Stream.h\"\n#include \"esp32-hal.h\"\n\nclass HardwareSerial: public Stream\n{\npublic:\n    HardwareSerial(int uart_nr);\n\n    void begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);\n    void end();\n    void updateBaudRate(unsigned long baud);\n    int available(void);\n    int availableForWrite(void);\n    int peek(void);\n    int read(void);\n    size_t read(uint8_t *buffer, size_t size);\n    inline size_t read(char * buffer, size_t size)\n    {\n        return read((uint8_t*) buffer, size);\n    }\n    void flush(void);\n    void flush( bool txOnly);\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    inline size_t write(const char * buffer, size_t size)\n    {\n        return write((uint8_t*) buffer, size);\n    }\n    inline size_t write(const char * s)\n    {\n        return write((uint8_t*) s, strlen(s));\n    }\n    inline size_t write(unsigned long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(long n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(unsigned int n)\n    {\n        return write((uint8_t) n);\n    }\n    inline size_t write(int n)\n    {\n        return write((uint8_t) n);\n    }\n    uint32_t baudRate();\n    operator bool() const;\n\n    size_t setRxBufferSize(size_t);\n    void setDebugOutput(bool);\n    \n    void setRxInvert(bool);\n\nprotected:\n    int _uart_nr;\n    uart_t* _uart;\n    uint8_t _tx_pin;\n    uint8_t _rx_pin;\n};\n\nextern void serialEventRun(void) __attribute__((weak));\n\n#if !defined(NO_GLOBAL_INSTANCES) && !defined(NO_GLOBAL_SERIAL)\nextern HardwareSerial Serial;\nextern HardwareSerial Serial1;\nextern HardwareSerial Serial2;\n#endif\n\n#endif // HardwareSerial_h\n"}}}Content-Length: 181

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h"}}}
>>>
Content-Length: 191

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/cores/esp32/HardwareSerial.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 417

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":748},"contentChanges":[{"range":{"start":{"line":238,"character":4},"end":{"line":238,"character":4}},"rangeLength":0,"text":"// "},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 284

{"jsonrpc":"2.0","id":504,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":7},"end":{"line":238,"character":57}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":504,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":748}}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":749},"contentChanges":[{"range":{"start":{"line":251,"character":3},"end":{"line":251,"character":3}},"rangeLength":0,"text":"\n  "}]}}Content-Length: 397

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":750},"contentChanges":[{"range":{"start":{"line":252,"character":2},"end":{"line":252,"character":2}},"rangeLength":0,"text":"Serial.print(\" Overflow Stack :\");\n    Serial.println(uxTaskGetStackHighWaterMark(NULL));"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":505,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":253,"character":54},"end":{"line":253,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":505,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":750}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":751},"contentChanges":[{"range":{"start":{"line":252,"character":2},"end":{"line":253,"character":54}},"rangeLength":89,"text":""}]}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":751}}}Content-Length: 283

{"jsonrpc":"2.0","id":506,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":506,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":752},"contentChanges":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"rangeLength":0,"text":"''"}]}}
>>>
Content-Length: 345

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":4}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":752}}}Content-Length: 453

{"jsonrpc":"2.0","id":507,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":3},"end":{"line":251,"character":3}},"context":{"diagnostics":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":4}},"message":"Expected expression","severity":1,"code":"expected_expression","source":"clang"}]}}}
>>>
Content-Length: 38

{"id":507,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":753},"contentChanges":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":4}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 175

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":508,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":508,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":753}}}Content-Length: 309

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":754},"contentChanges":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"rangeLength":0,"text":"\n  "}]}}Content-Length: 283

{"jsonrpc":"2.0","id":509,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":252,"character":2},"end":{"line":252,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":509,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":754}}}Content-Length: 397

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":755},"contentChanges":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"rangeLength":0,"text":"Serial.print(\" Overflow Stack :\");\n    Serial.println(uxTaskGetStackHighWaterMark(NULL));"}]}}Content-Length: 285

{"jsonrpc":"2.0","id":510,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":252,"character":54},"end":{"line":252,"character":54}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":510,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":755}}}Content-Length: 285

{"jsonrpc":"2.0","id":511,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":36},"end":{"line":251,"character":36}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":511,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":755}}}Content-Length: 209

{"jsonrpc":"2.0","id":512,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":251,"character":1}}}
>>>
Content-Length: 40

{"id":512,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":513,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":251,"character":2}}}
>>>
Content-Length: 2433

{"id":513,"result":[{"range":{"start":{"line":55,"character":2},"end":{"line":55,"character":8}},"kind":1},{"range":{"start":{"line":58,"character":4},"end":{"line":58,"character":10}},"kind":1},{"range":{"start":{"line":74,"character":4},"end":{"line":74,"character":10}},"kind":1},{"range":{"start":{"line":83,"character":10},"end":{"line":83,"character":16}},"kind":1},{"range":{"start":{"line":86,"character":2},"end":{"line":86,"character":8}},"kind":1},{"range":{"start":{"line":91,"character":4},"end":{"line":91,"character":10}},"kind":1},{"range":{"start":{"line":96,"character":2},"end":{"line":96,"character":8}},"kind":1},{"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":8}},"kind":1},{"range":{"start":{"line":108,"character":2},"end":{"line":108,"character":8}},"kind":1},{"range":{"start":{"line":109,"character":2},"end":{"line":109,"character":8}},"kind":1},{"range":{"start":{"line":110,"character":2},"end":{"line":110,"character":8}},"kind":1},{"range":{"start":{"line":111,"character":2},"end":{"line":111,"character":8}},"kind":1},{"range":{"start":{"line":112,"character":2},"end":{"line":112,"character":8}},"kind":1},{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":8}},"kind":1},{"range":{"start":{"line":114,"character":2},"end":{"line":114,"character":8}},"kind":1},{"range":{"start":{"line":115,"character":2},"end":{"line":115,"character":8}},"kind":1},{"range":{"start":{"line":116,"character":2},"end":{"line":116,"character":8}},"kind":1},{"range":{"start":{"line":117,"character":2},"end":{"line":117,"character":8}},"kind":1},{"range":{"start":{"line":118,"character":2},"end":{"line":118,"character":8}},"kind":1},{"range":{"start":{"line":119,"character":2},"end":{"line":119,"character":8}},"kind":1},{"range":{"start":{"line":127,"character":2},"end":{"line":127,"character":8}},"kind":1},{"range":{"start":{"line":128,"character":2},"end":{"line":128,"character":8}},"kind":1},{"range":{"start":{"line":129,"character":2},"end":{"line":129,"character":8}},"kind":1},{"range":{"start":{"line":218,"character":4},"end":{"line":218,"character":10}},"kind":1},{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":8}},"kind":1},{"range":{"start":{"line":252,"character":4},"end":{"line":252,"character":10}},"kind":1},{"range":{"start":{"line":258,"character":2},"end":{"line":258,"character":8}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":514,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":514,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":515,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":252,"character":3}}}
>>>
Content-Length: 40

{"id":515,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":756},"contentChanges":[{"range":{"start":{"line":251,"character":2},"end":{"line":251,"character":2}},"rangeLength":0,"text":"  "}]}}Content-Length: 283

{"jsonrpc":"2.0","id":516,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":251,"character":4},"end":{"line":251,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":516,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":756}}}Content-Length: 209

{"jsonrpc":"2.0","id":517,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":4}}}
>>>
Content-Length: 40

{"id":517,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":518,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":272,"character":6}}}
>>>
Content-Length: 216

{"id":518,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":307,"character":4},"end":{"line":307,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":519,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":281,"character":8}}}
>>>
Content-Length: 216

{"id":519,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":316,"character":4},"end":{"line":316,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":520,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":281,"character":7}}}
>>>
Content-Length: 216

{"id":520,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":316,"character":4},"end":{"line":316,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":521,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":8}}}
>>>
Content-Length: 217

{"id":521,"result":[{"range":{"start":{"line":268,"character":2},"end":{"line":268,"character":13}},"kind":1},{"range":{"start":{"line":277,"character":2},"end":{"line":277,"character":13}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":522,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":8},"end":{"line":280,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":522,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":523,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":2}}}
>>>
Content-Length: 40

{"id":523,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":524,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":5},"end":{"line":280,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":524,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":525,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":4},"end":{"line":280,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":525,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":526,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":4},"end":{"line":280,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":526,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":280,"character":4},"end":{"line":280,"character":8}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":757},"contentChanges":[{"range":{"start":{"line":280,"character":4},"end":{"line":280,"character":8}},"rangeLength":4,"text":"7"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":758},"contentChanges":[{"range":{"start":{"line":280,"character":5},"end":{"line":280,"character":5}},"rangeLength":0,"text":"6"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":759},"contentChanges":[{"range":{"start":{"line":280,"character":6},"end":{"line":280,"character":6}},"rangeLength":0,"text":"8"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":527,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":7},"end":{"line":280,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":527,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":759}}}Content-Length: 209

{"jsonrpc":"2.0","id":528,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":278,"character":4}}}
>>>
Content-Length: 314

{"id":528,"result":{"contents":{"kind":"markdown","value":"### function `task2`  \n\n---\n `void`  \nParameters:  \n- `void * parameters`\n\nPassed as pvTaskCode  \n\n---\n```cpp\nvoid task2(void *parameters)\n```"},"range":{"start":{"line":313,"character":4},"end":{"line":313,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":529,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":6}}}
>>>
Content-Length: 40

{"id":529,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":530,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":273,"character":6}}}
>>>
Content-Length: 670

{"id":530,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":308,"character":5},"end":{"line":308,"character":6}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":531,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":272,"character":5}}}
>>>
Content-Length: 216

{"id":531,"result":{"contents":{"kind":"markdown","value":"### macro `NULL`  \n\n---\n```cpp\n#define NULL __null\n```"},"range":{"start":{"line":307,"character":4},"end":{"line":307,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":532,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":272,"character":6}}}
>>>
Content-Length: 38

{"id":532,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":533,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":272,"character":6},"end":{"line":272,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 361

{"id":533,"result":[{"title":"Expand macro 'NULL'","kind":"refactor","command":{"title":"Expand macro 'NULL'","command":"clangd.applyTweak","arguments":[{"tweakID":"ExpandMacro","file":"file:///tmp/arduino-language-server115944645/sketch/Esp_Master.ino.cpp","selection":{"start":{"line":307,"character":6},"end":{"line":307,"character":6}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":534,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":271,"character":5}}}
>>>
Content-Length: 40

{"id":534,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":535,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":271,"character":6}}}
>>>
Content-Length: 38

{"id":535,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":536,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":271,"character":6},"end":{"line":271,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":536,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":537,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":279,"character":1}}}
>>>
Content-Length: 40

{"id":537,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":760},"contentChanges":[{"range":{"start":{"line":271,"character":5},"end":{"line":271,"character":6}},"rangeLength":1,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":538,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":271,"character":5},"end":{"line":271,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":538,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":761},"contentChanges":[{"range":{"start":{"line":271,"character":5},"end":{"line":271,"character":5}},"rangeLength":0,"text":"4"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":539,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":271,"character":6},"end":{"line":271,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":539,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":761}}}Content-Length: 209

{"jsonrpc":"2.0","id":540,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":279,"character":3}}}
>>>
Content-Length: 40

{"id":540,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":541,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":4}}}
>>>
Content-Length: 40

{"id":541,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":542,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":7}}}
>>>
Content-Length: 670

{"id":542,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":315,"character":7},"end":{"line":315,"character":8}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":543,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":8},"end":{"line":280,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":543,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":544,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":280,"character":7}}}
>>>
Content-Length: 217

{"id":544,"result":[{"range":{"start":{"line":268,"character":2},"end":{"line":268,"character":13}},"kind":1},{"range":{"start":{"line":277,"character":2},"end":{"line":277,"character":13}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":545,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":7},"end":{"line":280,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":545,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":546,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":4},"end":{"line":280,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 401

{"id":546,"result":[{"title":"Extract subexpression to variable","kind":"refactor","command":{"title":"Extract subexpression to variable","command":"clangd.applyTweak","arguments":[{"tweakID":"ExtractVariable","file":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","selection":{"start":{"line":280,"character":4},"end":{"line":280,"character":7}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":762},"contentChanges":[{"range":{"start":{"line":280,"character":4},"end":{"line":280,"character":7}},"rangeLength":3,"text":"1"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":547,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":5},"end":{"line":280,"character":5}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":547,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":763},"contentChanges":[{"range":{"start":{"line":280,"character":5},"end":{"line":280,"character":5}},"rangeLength":0,"text":"0"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":548,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":6},"end":{"line":280,"character":6}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":548,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":763}}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":764},"contentChanges":[{"range":{"start":{"line":280,"character":6},"end":{"line":280,"character":6}},"rangeLength":0,"text":"2"}]}}Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":765},"contentChanges":[{"range":{"start":{"line":280,"character":7},"end":{"line":280,"character":7}},"rangeLength":0,"text":"4"}]}}Content-Length: 283

{"jsonrpc":"2.0","id":549,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":280,"character":8},"end":{"line":280,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":549,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":765}}}Content-Length: 209

{"jsonrpc":"2.0","id":550,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":276,"character":9}}}
>>>
Content-Length: 40

{"id":550,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":551,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":12}}}
>>>
Content-Length: 671

{"id":551,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":2},"end":{"line":312,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":552,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":270,"character":10}}}
>>>
Content-Length: 38

{"id":552,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":553,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":270,"character":10},"end":{"line":270,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":553,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":766},"contentChanges":[{"range":{"start":{"line":270,"character":10},"end":{"line":270,"character":10}},"rangeLength":0,"text":" "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":554,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":270,"character":11},"end":{"line":270,"character":11}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":554,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":766}}}Content-Length: 209

{"jsonrpc":"2.0","id":555,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":278,"character":7}}}
>>>
Content-Length: 314

{"id":555,"result":{"contents":{"kind":"markdown","value":"### function `task2`  \n\n---\n `void`  \nParameters:  \n- `void * parameters`\n\nPassed as pvTaskCode  \n\n---\n```cpp\nvoid task2(void *parameters)\n```"},"range":{"start":{"line":313,"character":4},"end":{"line":313,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":556,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":279,"character":9}}}
>>>
Content-Length: 40

{"id":556,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":557,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":279,"character":10}}}
>>>
Content-Length: 38

{"id":557,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":558,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":279,"character":10},"end":{"line":279,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":558,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":559,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":12}}}
>>>
Content-Length: 671

{"id":559,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":2},"end":{"line":312,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 215

{"jsonrpc":"2.0","id":560,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":12}}}
>>>
Content-Length: 236

{"id":560,"result":[{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","range":{"start":{"line":431,"character":36},"end":{"line":431,"character":47}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 98387

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","languageId":"cpp","version":1,"text":"/*\n    FreeRTOS V8.2.0 - Copyright (C) 2015 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.\n\n\t***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n\t***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n\tthe FAQ page \"My application does not run, what could be wrong?\".  Have you\n\tdefined configASSERT()?\n\n\thttp://www.FreeRTOS.org/support - In return for receiving this top quality\n\tembedded software for free we request you assist our global community by\n\tparticipating in the support forum.\n\n\thttp://www.FreeRTOS.org/training - Investing in training allows your team to\n\tbe as productive as possible as early as possible.  Now you can receive\n\tFreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n\tLtd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n#ifndef INC_TASK_H\n#define INC_TASK_H\n\n#ifndef INC_FREERTOS_H\n\t#error \"include FreeRTOS.h must appear in source files before include task.h\"\n#endif\n\n#include <limits.h>\n\n#include \"list.h\"\n#include \"portmacro.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-----------------------------------------------------------\n * MACROS AND DEFINITIONS\n *----------------------------------------------------------*/\n\n#define tskKERNEL_VERSION_NUMBER \"V8.2.0\"\n#define tskKERNEL_VERSION_MAJOR 8\n#define tskKERNEL_VERSION_MINOR 2\n#define tskKERNEL_VERSION_BUILD 0\n\n/**\n * @brief Argument of xTaskCreatePinnedToCore indicating that task has no affinity\n */\n#define tskNO_AFFINITY INT_MAX\n\n/**\n * task. h\n *\n * Type by which tasks are referenced.  For example, a call to xTaskCreate\n * returns (via a pointer parameter) an TaskHandle_t variable that can then\n * be used as a parameter to vTaskDelete to delete the task.\n *\n * \\ingroup Tasks\n */\ntypedef void * TaskHandle_t;\n\n/**\n * Defines the prototype to which the application task hook function must\n * conform.\n */\ntypedef BaseType_t (*TaskHookFunction_t)( void * );\n\n/** Task states returned by eTaskGetState. */\ntypedef enum\n{\n\teRunning = 0,\t/*!< A task is querying the state of itself, so must be running. */\n\teReady,\t\t\t/*!< The task being queried is in a read or pending ready list. */\n\teBlocked,\t\t/*!< The task being queried is in the Blocked state. */\n\teSuspended,\t\t/*!< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */\n\teDeleted\t\t/*!< The task being queried has been deleted, but its TCB has not yet been freed. */\n} eTaskState;\n\n/** Actions that can be performed when vTaskNotify() is called. */\ntypedef enum\n{\n\teNoAction = 0,\t\t\t\t/*!< Notify the task without updating its notify value. */\n\teSetBits,\t\t\t\t\t/*!< Set bits in the task's notification value. */\n\teIncrement,\t\t\t\t\t/*!< Increment the task's notification value. */\n\teSetValueWithOverwrite,\t\t/*!< Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */\n\teSetValueWithoutOverwrite\t/*!< Set the task's notification value if the previous value has been read by the task. */\n} eNotifyAction;\n\n/** @cond */\n/**\n * Used internally only.\n */\ntypedef struct xTIME_OUT\n{\n\tBaseType_t xOverflowCount;\n\tTickType_t xTimeOnEntering;\n} TimeOut_t;\n\n/**\n * Defines the memory ranges allocated to the task when an MPU is used.\n */\ntypedef struct xMEMORY_REGION\n{\n\tvoid *pvBaseAddress;\n\tuint32_t ulLengthInBytes;\n\tuint32_t ulParameters;\n} MemoryRegion_t;\n\n/**\n * Parameters required to create an MPU protected task.\n */\ntypedef struct xTASK_PARAMETERS\n{\n\tTaskFunction_t pvTaskCode;\n\tconst char * const pcName;\t/*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tuint32_t usStackDepth;\n\tvoid *pvParameters;\n\tUBaseType_t uxPriority;\n\tStackType_t *puxStackBuffer;\n\tMemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];\n} TaskParameters_t;\n/** @endcond */\n\n/**\n *  Used with the uxTaskGetSystemState() function to return the state of each task in the system.\n*/\ntypedef struct xTASK_STATUS\n{\n\tTaskHandle_t xHandle;\t\t\t/*!< The handle of the task to which the rest of the information in the structure relates. */\n\tconst char *pcTaskName;\t\t\t/*!< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\tUBaseType_t xTaskNumber;\t\t/*!< A number unique to the task. */\n\teTaskState eCurrentState;\t\t/*!< The state in which the task existed when the structure was populated. */\n\tUBaseType_t uxCurrentPriority;\t/*!< The priority at which the task was running (may be inherited) when the structure was populated. */\n\tUBaseType_t uxBasePriority;\t\t/*!< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */\n\tuint32_t ulRunTimeCounter;\t\t/*!< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */\n\tStackType_t *pxStackBase;\t\t/*!< Points to the lowest address of the task's stack area. */\n\tuint32_t usStackHighWaterMark;\t/*!< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */\n#if configTASKLIST_INCLUDE_COREID\n\tBaseType_t xCoreID;\t\t\t\t/*!< Core this task is pinned to. This field is present if CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID is set. */\n#endif\n} TaskStatus_t;\n\n/**\n * Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system.\n * We need this struct because TCB_t is defined (hidden) in tasks.c.\n */\ntypedef struct xTASK_SNAPSHOT\n{\n\tvoid        *pxTCB;         /*!< Address of task control block. */\n\tStackType_t *pxTopOfStack;  /*!< Points to the location of the last item placed on the tasks stack. */\n\tStackType_t *pxEndOfStack;  /*!< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo\n\t\t\t\t\t\t\t\t\tpxTopOfStack > pxEndOfStack, stack grows lo2hi*/\n} TaskSnapshot_t;\n\n/**\n * Possible return values for eTaskConfirmSleepModeStatus().\n */\ntypedef enum\n{\n\teAbortSleep = 0,\t\t/*!< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */\n\teStandardSleep,\t\t\t/*!< Enter a sleep mode that will not last any longer than the expected idle time. */\n\teNoTasksWaitingTimeout\t/*!< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */\n} eSleepModeStatus;\n\n\n/**\n * Defines the priority used by the idle task.  This must not be modified.\n *\n * \\ingroup TaskUtils\n */\n#define tskIDLE_PRIORITY\t\t\t( ( UBaseType_t ) 0U )\n\n/**\n * task. h\n *\n * Macro for forcing a context switch.\n *\n * \\ingroup SchedulerControl\n */\n#define taskYIELD()\t\t\t\t\tportYIELD()\n\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskENTER_CRITICAL(mux)\t\tportENTER_CRITICAL(mux)\n#else\n#define taskENTER_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskENTER_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portENTER_CRITICAL(mux)'\\\"\") portENTER_CRITICAL(mux)\n#endif\n#define taskENTER_CRITICAL_ISR(mux)\t\tportENTER_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * @note This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\ingroup SchedulerControl\n */\n#ifdef _ESP_FREERTOS_INTERNAL\n#define taskEXIT_CRITICAL(mux)\t\t\tportEXIT_CRITICAL(mux)\n#else\n#define taskEXIT_CRITICAL(mux) _Pragma(\"GCC warning \\\"'taskEXIT_CRITICAL(mux)' is deprecated in ESP-IDF, consider using 'portEXIT_CRITICAL(mux)'\\\"\") portEXIT_CRITICAL(mux)\n#endif\n#define taskEXIT_CRITICAL_ISR(mux)\t\tportEXIT_CRITICAL_ISR(mux)\n\n/**\n * task. h\n *\n * Macro to disable all maskable interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskDISABLE_INTERRUPTS()\tportDISABLE_INTERRUPTS()\n\n/**\n * task. h\n *\n * Macro to enable microcontroller interrupts.\n *\n * \\ingroup SchedulerControl\n */\n#define taskENABLE_INTERRUPTS()\t\tportENABLE_INTERRUPTS()\n\n/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is\n0 to generate more optimal code when configASSERT() is defined as the constant\nis used in assert() statements. */\n#define taskSCHEDULER_SUSPENDED\t\t( ( BaseType_t ) 0 )\n#define taskSCHEDULER_NOT_STARTED\t( ( BaseType_t ) 1 )\n#define taskSCHEDULER_RUNNING\t\t( ( BaseType_t ) 2 )\n\n\n/*-----------------------------------------------------------\n * TASK CREATION API\n *----------------------------------------------------------*/\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreate, but allows setting task affinity\n * in SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\tBaseType_t xTaskCreatePinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\tconst uint32_t usStackDepth,\n\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\tTaskHandle_t * const pvCreatedTask,\n\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID);\n\n#endif\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * See xTaskCreateStatic() for a version that does not use any dynamic memory\n * allocation.\n *\n * xTaskCreate() can only be used to create a task that has unrestricted\n * access to the entire microcontroller memory map.  Systems that include MPU\n * support can alternatively create an MPU constrained task using\n * xTaskCreateRestricted().\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default\n * is 16.\n *\n * @param usStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task should run.  Systems that\n * include MPU support can optionally create tasks in a privileged (system)\n * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For\n * example, to create a privileged task at priority 2 the uxPriority parameter\n * should be set to ( 2 | portPRIVILEGE_BIT ).\n *\n * @param pvCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *  // Task to be created.\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *   }\n *  }\n *\n *  // Function that creates a task.\n *  void vOtherFunction( void )\n *  {\n *  static uint8_t ucParameterToPass;\n *  TaskHandle_t xHandle = NULL;\n *\n *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass\n *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an\n *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time\n *   // the new task attempts to access it.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );\n *      configASSERT( xHandle );\n *\n *   // Use the handle to delete the task.\n *      if( xHandle != NULL )\n *      {\n *       vTaskDelete( xHandle );\n *      }\n *  }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tstatic inline IRAM_ATTR BaseType_t xTaskCreate(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t usStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tTaskHandle_t * const pvCreatedTask)\n\t{\n\t\treturn xTaskCreatePinnedToCore( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask, tskNO_AFFINITY );\n\t}\n\n#endif\n\n\n\n\n/**\n * Create a new task with a specified affinity.\n *\n * This function is similar to xTaskCreateStatic, but allows specifying\n * task affinity in an SMP system.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @param xCoreID If the value is tskNO_AFFINITY, the created task is not\n * pinned to any CPU, and the scheduler can run it on any core available.\n * Other values indicate the index number of the CPU which the task should\n * be pinned to. Specifying values larger than (portNUM_PROCESSORS - 1) will\n * cause the function to fail.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * \\ingroup Tasks\n */\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tTaskHandle_t xTaskCreateStaticPinnedToCore(\tTaskFunction_t pvTaskCode,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char * const pcName,\n\t\t\t\t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth,\n\t\t\t\t\t\t\t\t\t\t\t\tvoid * const pvParameters,\n\t\t\t\t\t\t\t\t\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\t\t\t\t\t\t\t\t\tStackType_t * const pxStackBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tStaticTask_t * const pxTaskBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tconst BaseType_t xCoreID );\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/**\n * Create a new task and add it to the list of tasks that are ready to run.\n *\n * Internally, within the FreeRTOS implementation, tasks use two blocks of\n * memory.  The first block is used to hold the task's data structures.  The\n * second block is used by the task as its stack.  If a task is created using\n * xTaskCreate() then both blocks of memory are automatically dynamically\n * allocated inside the xTaskCreate() function.  (see\n * http://www.freertos.org/a00111.html).  If a task is created using\n * xTaskCreateStatic() then the application writer must provide the required\n * memory.  xTaskCreateStatic() therefore allows a task to be created without\n * using any dynamic memory allocation.\n *\n * @param pvTaskCode Pointer to the task entry function.  Tasks\n * must be implemented to never return (i.e. continuous loop).\n *\n * @param pcName A descriptive name for the task.  This is mainly used to\n * facilitate debugging.  The maximum length of the string is defined by\n * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.\n *\n * @param ulStackDepth The size of the task stack specified as the number of\n * bytes. Note that this differs from vanilla FreeRTOS.\n *\n * @param pvParameters Pointer that will be used as the parameter for the task\n * being created.\n *\n * @param uxPriority The priority at which the task will run.\n *\n * @param pxStackBuffer Must point to a StackType_t array that has at least\n * ulStackDepth indexes - the array will then be used as the task's stack,\n * removing the need for the stack to be allocated dynamically.\n *\n * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will\n * then be used to hold the task's data structures, removing the need for the\n * memory to be allocated dynamically.\n *\n * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will\n * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer\n * are NULL then the task will not be created and\n * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.\n *\n * @note If program uses thread local variables (ones specified with \"__thread\" keyword)\n * then storage for them will be allocated on the task's stack.\n *\n * Example usage:\n * @code{c}\n *\n *     // Dimensions the buffer that the task being created will use as its stack.\n *     // NOTE:  This is the number of bytes the stack will hold, not the number of\n *     // words as found in vanilla FreeRTOS.\n *     #define STACK_SIZE 200\n *\n *     // Structure that will hold the TCB of the task being created.\n *     StaticTask_t xTaskBuffer;\n *\n *     // Buffer that the task being created will use as its stack.  Note this is\n *     // an array of StackType_t variables.  The size of StackType_t is dependent on\n *     // the RTOS port.\n *     StackType_t xStack[ STACK_SIZE ];\n *\n *     // Function that implements the task being created.\n *     void vTaskCode( void * pvParameters )\n *     {\n *         // The parameter value is expected to be 1 as 1 is passed in the\n *         // pvParameters value in the call to xTaskCreateStatic().\n *         configASSERT( ( uint32_t ) pvParameters == 1UL );\n *\n *         for( ;; )\n *         {\n *             // Task code goes here.\n *         }\n *     }\n *\n *     // Function that creates a task.\n *     void vOtherFunction( void )\n *     {\n *         TaskHandle_t xHandle = NULL;\n *\n *         // Create the task without using any dynamic memory allocation.\n *         xHandle = xTaskCreateStatic(\n *                       vTaskCode,       // Function that implements the task.\n *                       \"NAME\",          // Text name for the task.\n *                       STACK_SIZE,      // Stack size in bytes, not words.\n *                       ( void * ) 1,    // Parameter passed into the task.\n *                       tskIDLE_PRIORITY,// Priority at which the task is created.\n *                       xStack,          // Array to use as the task's stack.\n *                       &xTaskBuffer );  // Variable to hold the task's data structure.\n *\n *         // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have\n *         // been created, and xHandle will be the task's handle.  Use the handle\n *         // to suspend the task.\n *         vTaskSuspend( xHandle );\n *     }\n * @endcode\n * \\ingroup Tasks\n */\n\n#if( configSUPPORT_STATIC_ALLOCATION == 1 )\n\tstatic inline IRAM_ATTR TaskHandle_t xTaskCreateStatic(\n\t\t\tTaskFunction_t pvTaskCode,\n\t\t\tconst char * const pcName,\n\t\t\tconst uint32_t ulStackDepth,\n\t\t\tvoid * const pvParameters,\n\t\t\tUBaseType_t uxPriority,\n\t\t\tStackType_t * const pxStackBuffer,\n\t\t\tStaticTask_t * const pxTaskBuffer)\n\t{\n\t\treturn xTaskCreateStaticPinnedToCore( pvTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, pxStackBuffer, pxTaskBuffer, tskNO_AFFINITY );\n\t}\n#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n/** @cond */\n/**\n * xTaskCreateRestricted() should only be used in systems that include an MPU\n * implementation.\n *\n * Create a new task and add it to the list of tasks that are ready to run.\n * The function parameters define the memory regions and associated access\n * permissions allocated to the task.\n *\n * @param pxTaskDefinition Pointer to a structure that contains a member\n * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API\n * documentation) plus an optional stack buffer and the memory region\n * definitions.\n *\n * @param pxCreatedTask Used to pass back a handle by which the created task\n * can be referenced.\n *\n * @return pdPASS if the task was successfully created and added to a ready\n * list, otherwise an error code defined in the file projdefs.h\n *\n * Example usage:\n * @code{c}\n * // Create an TaskParameters_t structure that defines the task to be created.\n * static const TaskParameters_t xCheckTaskParameters =\n * {\n * \tvATask,\t\t// pvTaskCode - the function that implements the task.\n * \t\"ATask\",\t// pcName - just a text name for the task to assist debugging.\n * \t100,\t\t// usStackDepth\t- the stack size DEFINED IN BYTES.\n * \tNULL,\t\t// pvParameters - passed into the task function as the function parameters.\n * \t( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.\n * \tcStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.\n *\n * \t// xRegions - Allocate up to three separate memory regions for access by\n * \t// the task, with appropriate access permissions.  Different processors have\n * \t// different memory alignment requirements - refer to the FreeRTOS documentation\n * \t// for full information.\n * \t{\n * \t\t// Base address\t\t\t\t\tLength\tParameters\n *         { cReadWriteArray,\t\t\t\t32,\t\tportMPU_REGION_READ_WRITE },\n *         { cReadOnlyArray,\t\t\t\t32,\t\tportMPU_REGION_READ_ONLY },\n *         { cPrivilegedOnlyAccessArray,\t128,\tportMPU_REGION_PRIVILEGED_READ_WRITE }\n * \t}\n * };\n *\n * int main( void )\n * {\n * TaskHandle_t xHandle;\n *\n * \t// Create a task from the const structure defined above.  The task handle\n * \t// is requested (the second parameter is not NULL) but in this case just for\n * \t// demonstration purposes as its not actually used.\n * \txTaskCreateRestricted( &xRegTest1Parameters, &xHandle );\n *\n * \t// Start the scheduler.\n * \tvTaskStartScheduler();\n *\n * \t// Will only get here if there was insufficient memory to create the idle\n * \t// and/or timer task.\n * \tfor( ;; );\n * }\n * @endcode\n * \\ingroup Tasks\n */\n#if( portUSING_MPU_WRAPPERS == 1 )\n\tBaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;\n#endif\n\n\n/**\n * Memory regions are assigned to a restricted task when the task is created by\n * a call to xTaskCreateRestricted().  These regions can be redefined using\n * vTaskAllocateMPURegions().\n *\n * @param xTask The handle of the task being updated.\n *\n * @param xRegions A pointer to an MemoryRegion_t structure that contains the\n * new memory region definitions.\n *\n * Example usage:\n *\n * @code{c}\n * // Define an array of MemoryRegion_t structures that configures an MPU region\n * // allowing read/write access for 1024 bytes starting at the beginning of the\n * // ucOneKByte array.  The other two of the maximum 3 definable regions are\n * // unused so set to zero.\n * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n * {\n * \t// Base address\t\tLength\t\tParameters\n * \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },\n * \t{ 0,\t\t\t\t0,\t\t\t0 },\n * \t{ 0,\t\t\t\t0,\t\t\t0 }\n * };\n *\n * void vATask( void *pvParameters )\n * {\n * \t// This task was created such that it has access to certain regions of\n * \t// memory as defined by the MPU configuration.  At some point it is\n * \t// desired that these MPU regions are replaced with that defined in the\n * \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n * \t// for this purpose.  NULL is used as the task handle to indicate that this\n * \t// function should modify the MPU regions of the calling task.\n * \tvTaskAllocateMPURegions( NULL, xAltRegions );\n *\n * \t// Now the task can continue its function, but from this point on can only\n * \t// access its stack and the ucOneKByte array (unless any other statically\n * \t// defined or shared regions have been declared elsewhere).\n * }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Remove a task from the RTOS real time kernel's management.\n *\n * The task being deleted will be removed from all ready, blocked, suspended\n * and event lists.\n *\n * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @note The idle task is responsible for freeing the kernel allocated\n * memory from tasks that have been deleted.  It is therefore important that\n * the idle task is not starved of microcontroller processing time if your\n * application makes any calls to vTaskDelete ().  Memory allocated by the\n * task code is not automatically freed, and should be freed before the task\n * is deleted.\n *\n * See the demo application file death.c for sample code that utilises\n * vTaskDelete ().\n *\n * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n * cause the calling task to be deleted.\n *\n * Example usage:\n * @code{c}\n *  void vOtherFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n * \t // Create the task, storing the handle.\n * \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n * \t // Use the handle to delete the task.\n * \t vTaskDelete( xHandle );\n *  }\n * @endcode\n * \\ingroup Tasks\n */\nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK CONTROL API\n *----------------------------------------------------------*/\n\n/**\n * Delay a task for a given number of ticks.\n *\n * The actual time that the task remains blocked depends on the tick rate.\n * The constant portTICK_PERIOD_MS can be used to calculate real time from\n * the tick rate - with the resolution of one tick period.\n *\n * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * vTaskDelay() specifies a time at which the task wishes to unblock relative to\n * the time at which vTaskDelay() is called.  For example, specifying a block\n * period of 100 ticks will cause the task to unblock 100 ticks after\n * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n * of controlling the frequency of a periodic task as the path taken through the\n * code, as well as other task and interrupt activity, will effect the frequency\n * at which vTaskDelay() gets called and therefore the time at which the task\n * next executes.  See vTaskDelayUntil() for an alternative API function designed\n * to facilitate fixed frequency execution.  It does this by specifying an\n * absolute time (rather than a relative time) at which the calling task should\n * unblock.\n *\n * @param xTicksToDelay The amount of time, in tick periods, that\n * the calling task should block.\n *\n * Example usage:\n * @code{c}\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  // Block for 500ms.\n *  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n *\n * \t for( ;; )\n * \t {\n * \t\t // Simply toggle the LED every 500ms, blocking between each toggle.\n * \t\t vToggleLED();\n * \t\t vTaskDelay( xDelay );\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;\n\n/**\n * Delay a task until a specified time.\n *\n * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * This function can be used by periodic tasks to ensure a constant execution frequency.\n *\n * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n * cause a task to block for the specified number of ticks from the time vTaskDelay () is\n * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n * execution frequency as the time between a task starting to execute and that task\n * calling vTaskDelay () may not be fixed [the task may take a different path though the\n * code between calls, or may get interrupted or preempted a different number of times\n * each time it executes].\n *\n * Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n * unblock.\n *\n * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick\n * rate - with the resolution of one tick period.\n *\n * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n * task was last unblocked.  The variable must be initialised with the current time\n * prior to its first use (see the example below).  Following this the variable is\n * automatically updated within vTaskDelayUntil ().\n *\n * @param xTimeIncrement The cycle time period.  The task will be unblocked at\n * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the\n * same xTimeIncrement parameter value will cause the task to execute with\n * a fixed interface period.\n *\n * Example usage:\n * @code{c}\n *  // Perform an action every 10 ticks.\n *  void vTaskFunction( void * pvParameters )\n *  {\n *  TickType_t xLastWakeTime;\n *  const TickType_t xFrequency = 10;\n *\n * \t // Initialise the xLastWakeTime variable with the current time.\n * \t xLastWakeTime = xTaskGetTickCount ();\n * \t for( ;; )\n * \t {\n * \t\t // Wait for the next cycle.\n * \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );\n *\n * \t\t // Perform action here.\n * \t }\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the priority of any task.\n *\n * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to obtain the priority of the created task.\n *   // It was created with tskIDLE_PRIORITY, but may have changed\n *   // it itself.\n *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n *   {\n *       // The task has changed it's priority.\n *   }\n *\n *   // ...\n *\n *   // Is our priority higher than the created task?\n *   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n *   {\n *       // Our priority (obtained using NULL handle) is higher.\n *   }\n * }\n * @endcode\n * \\ingroup TaskCtrl\n */\nUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * A version of uxTaskPriorityGet() that can be used from an ISR.\n *\n * @param xTask Handle of the task to be queried.  Passing a NULL\n * handle results in the priority of the calling task being returned.\n *\n * @return The priority of xTask.\n *\n */\nUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Obtain the state of any task.\n *\n * States are encoded by the eTaskState enumerated type.\n *\n * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * @param xTask Handle of the task to be queried.\n *\n * @return The state of xTask at the time the function was called.  Note the\n * state of the task might change between the function being called, and the\n * functions return value being tested by the calling task.\n */\neTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Set the priority of any task.\n *\n * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A context switch will occur before the function returns if the priority\n * being set is higher than the currently executing task.\n *\n * @param xTask Handle to the task for which the priority is being set.\n * Passing a NULL handle results in the priority of the calling task being set.\n *\n * @param uxNewPriority The priority to which the task will be set.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to raise the priority of the created task.\n *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n *\n *   // ...\n *\n *   // Use a NULL handle to raise our priority to the same value.\n *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;\n\n/**\n * Suspend a task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * When suspended, a task will never get any microcontroller processing time,\n * no matter what its priority.\n *\n * Calls to vTaskSuspend are not accumulative -\n * i.e. calling vTaskSuspend () twice on the same task still only requires one\n * call to vTaskResume () to ready the suspended task.\n *\n * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n * handle will cause the calling task to be suspended.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Suspend ourselves.\n *   vTaskSuspend( NULL );\n *\n *   // We cannot get here unless another task calls vTaskResume\n *   // with our handle as the parameter.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes a suspended task.\n *\n * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n * See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * vTaskResume ().\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *  TaskHandle_t xHandle;\n *\n *   // Create a task, storing the handle.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n *\n *   // ...\n *\n *   // Use the handle to suspend the created task.\n *   vTaskSuspend( xHandle );\n *\n *   // ...\n *\n *   // The created task will not run during this period, unless\n *   // another task calls vTaskResume( xHandle ).\n *\n *   //...\n *\n *\n *   // Resume the suspended task ourselves.\n *   vTaskResume( xHandle );\n *\n *   // The created task will once again get microcontroller processing\n *   // time in accordance with its priority within the system.\n *  }\n * @endcode\n * \\ingroup TaskCtrl\n */\nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/**\n * An implementation of vTaskResume() that can be called from within an ISR.\n *\n * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n * available.  See the configuration section for more information.\n *\n * A task that has been suspended by one or more calls to vTaskSuspend ()\n * will be made available for running again by a single call to\n * xTaskResumeFromISR ().\n *\n * xTaskResumeFromISR() should not be used to synchronise a task with an\n * interrupt if there is a chance that the interrupt could arrive prior to the\n * task being suspended - as this can lead to interrupts being missed. Use of a\n * semaphore as a synchronisation mechanism would avoid this eventuality.\n *\n * @param xTaskToResume Handle to the task being readied.\n *\n * @return pdTRUE if resuming the task should result in a context switch,\n * otherwise pdFALSE. This is used by the ISR to determine if a context switch\n * may be required following the ISR.\n *\n * \\ingroup TaskCtrl\n */\nBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * SCHEDULER CONTROL\n *----------------------------------------------------------*/\n/** @cond */\n/**\n * Starts the real time kernel tick processing.\n *\n * After calling the kernel has control over which tasks are executed and when.\n *\n * See the demo application file main.c for an example of creating\n * tasks and starting the kernel.\n *\n * Example usage:\n * @code{c}\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will not get here unless a task calls vTaskEndScheduler ()\n *  }\n * @endcode\n *\n * \\ingroup SchedulerControl\n */\nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Stops the real time kernel tick.\n *\n * @note At the time of writing only the x86 real mode port, which runs on a PC\n * in place of DOS, implements this function.\n *\n * All created tasks will be automatically deleted and multitasking\n * (either preemptive or cooperative) will stop.\n * Execution then resumes from the point where vTaskStartScheduler ()\n * was called, as if vTaskStartScheduler () had just returned.\n *\n * See the demo application file main. c in the demo/PC directory for an\n * example that uses vTaskEndScheduler ().\n *\n * vTaskEndScheduler () requires an exit function to be defined within the\n * portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n * performs hardware specific operations such as stopping the kernel tick.\n *\n * vTaskEndScheduler () will cause all of the resources allocated by the\n * kernel to be freed - but will not free resources allocated by application\n * tasks.\n *\n * Example usage:\n * @code{c}\n *  void vTaskCode( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // At some point we want to end the real time kernel processing\n *       // so call ...\n *       vTaskEndScheduler ();\n *   }\n *  }\n *\n *  void vAFunction( void )\n *  {\n *   // Create at least one task before starting the kernel.\n *   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n *\n *   // Start the real time kernel with preemption.\n *   vTaskStartScheduler ();\n *\n *   // Will only get here when the vTaskCode () task has called\n *   // vTaskEndScheduler ().  When we get here we are back to single task\n *   // execution.\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;\n\n/** @endcond */\n\n/**\n * Suspends the scheduler without disabling interrupts.\n *\n * Context switches will not occur while the scheduler is suspended.\n *\n * After calling vTaskSuspendAll () the calling task will continue to execute\n * without risk of being swapped out until a call to xTaskResumeAll () has been\n * made.\n *\n * API functions that have the potential to cause a context switch (for example,\n * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n * is suspended.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the kernel\n *       // tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.\n *       xTaskResumeAll ();\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Resumes scheduler activity after it was suspended by a call to\n * vTaskSuspendAll().\n *\n * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n * that were previously suspended by a call to vTaskSuspend().\n *\n * @return If resuming the scheduler caused a context switch then pdTRUE is\n *\t\t  returned, otherwise pdFALSE is returned.\n *\n * Example usage:\n * @code{c}\n *  void vTask1( void * pvParameters )\n *  {\n *   for( ;; )\n *   {\n *       // Task code goes here.\n *\n *       // ...\n *\n *       // At some point the task wants to perform a long operation during\n *       // which it does not want to get swapped out.  It cannot use\n *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n *       // operation may cause interrupts to be missed - including the\n *       // ticks.\n *\n *       // Prevent the real time kernel swapping out the task.\n *       vTaskSuspendAll ();\n *\n *       // Perform the operation here.  There is no need to use critical\n *       // sections as we have all the microcontroller processing time.\n *       // During this time interrupts will still operate and the real\n *       // time kernel tick count will be maintained.\n *\n *       // ...\n *\n *       // The operation is complete.  Restart the kernel.  We want to force\n *       // a context switch - but there is no point if resuming the scheduler\n *       // caused a context switch already.\n *       if( !xTaskResumeAll () )\n *       {\n *            taskYIELD ();\n *       }\n *   }\n *  }\n * @endcode\n * \\ingroup SchedulerControl\n */\nBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;\n\n/*-----------------------------------------------------------\n * TASK UTILITIES\n *----------------------------------------------------------*/\n\n/**\n * Get tick count\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get tick count from ISR\n *\n * @return The count of ticks since vTaskStartScheduler was called.\n *\n * This is a version of xTaskGetTickCount() that is safe to be called from an\n * ISR - provided that TickType_t is the natural word size of the\n * microcontroller being used or interrupt nesting is either not supported or\n * not being used.\n *\n * \\ingroup TaskUtils\n */\nTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get current number of tasks\n *\n * @return The number of tasks that the real time kernel is currently managing.\n * This includes all ready, blocked and suspended tasks.  A task that\n * has been deleted but not yet freed by the idle task will also be\n * included in the count.\n *\n * \\ingroup TaskUtils\n */\nUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;\n\n/**\n * Get task name\n *\n * @return The text (human readable) name of the task referenced by the handle\n * xTaskToQuery.  A task can query its own name by either passing in its own\n * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be\n * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.\n *\n * \\ingroup TaskUtils\n */\nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Returns the high water mark of the stack associated with xTask.\n *\n * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * High water mark is the minimum free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task started.\n * The smaller the returned number the closer the task has come to overflowing its stack.\n *\n * @param xTask Handle of the task associated with the stack to be checked.\n * Set xTask to NULL to check the stack of the calling task.\n *\n * @return The smallest amount of free stack space there has been (in bytes\n * rather than words as found in vanilla FreeRTOS) since the task referenced by\n * xTask was created.\n */\nUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/**\n * Returns the start of the stack associated with xTask.\n *\n * INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for\n * this function to be available.\n *\n * Returns the highest stack memory address on architectures where the stack grows down\n * from high memory, and the lowest memory address on architectures where the\n * stack grows up from low memory.\n *\n * @param xTask Handle of the task associated with the stack returned.\n * Set xTask to NULL to return the stack of the calling task.\n *\n * @return A pointer to the start of the stack.\n */\nuint8_t* pxTaskGetStackStart( TaskHandle_t xTask) PRIVILEGED_FUNCTION;\n\n/* When using trace macros it is sometimes necessary to include task.h before\nFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,\nso the following two prototypes will cause a compilation error.  This can be\nfixed by simply guarding against the inclusion of these two prototypes unless\nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration\nconstant. */\n#ifdef configUSE_APPLICATION_TASK_TAG\n\t#if configUSE_APPLICATION_TASK_TAG == 1\n\t\t/**\n\t\t * Sets pxHookFunction to be the task hook function used by the task xTask.\n\t\t * @param xTask Handle of the task to set the hook function for\n\t\t *              Passing xTask as NULL has the effect of setting the calling\n\t\t *              tasks hook function.\n\t\t * @param pxHookFunction  Pointer to the hook function.\n\t\t */\n\t\tvoid vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;\n\n\t\t/**\n\t\t * Get the hook function assigned to given task.\n\t\t * @param xTask Handle of the task to get the hook function for\n\t\t *              Passing xTask as NULL has the effect of getting the calling\n\t\t *              tasks hook function.\n\t\t * @return The pxHookFunction value assigned to the task xTask.\n\t\t */\n\t\tTaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\t#endif /* configUSE_APPLICATION_TASK_TAG ==1 */\n#endif /* ifdef configUSE_APPLICATION_TASK_TAG */\n#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )\n\n\t/**\n\t * Set local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t * @param xIndex The index of the pointer to set, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @param pvValue  Pointer value to set.\n\t */\n\tvoid vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;\n\n\n\t/**\n\t * Get local storage pointer specific to the given task.\n\t *\n\t * Each task contains an array of pointers that is dimensioned by the\n\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t * The kernel does not use the pointers itself, so the application writer\n\t * can use the pointers for any purpose they wish.\n\t *\n\t * @param xTaskToQuery  Task to get thread local storage pointer for\n\t * @param xIndex The index of the pointer to get, from 0 to\n\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t * @return  Pointer value\n\t */\n\tvoid *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;\n\n\t#if ( configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS )\n\n\t\t/**\n\t\t * Prototype of local storage pointer deletion callback.\n\t\t */\n\t\ttypedef void (*TlsDeleteCallbackFunction_t)( int, void * );\n\n\t\t/**\n\t\t * Set local storage pointer and deletion callback.\n\t\t *\n\t\t * Each task contains an array of pointers that is dimensioned by the\n\t\t * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.\n\t\t * The kernel does not use the pointers itself, so the application writer\n\t\t * can use the pointers for any purpose they wish.\n\t\t *\n\t\t * Local storage pointers set for a task can reference dynamically\n\t\t * allocated resources. This function is similar to\n\t\t * vTaskSetThreadLocalStoragePointer, but provides a way to release\n\t\t * these resources when the task gets deleted. For each pointer,\n\t\t * a callback function can be set. This function will be called\n\t\t * when task is deleted, with the local storage pointer index\n\t\t * and value as arguments.\n\t\t *\n\t\t * @param xTaskToSet  Task to set thread local storage pointer for\n\t\t * @param xIndex The index of the pointer to set, from 0 to\n\t\t *               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1.\n\t\t * @param pvValue  Pointer value to set.\n\t\t * @param pvDelCallback  Function to call to dispose of the local\n\t\t *                       storage pointer when the task is deleted.\n\t\t */\n\t\tvoid vTaskSetThreadLocalStoragePointerAndDelCallback( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue, TlsDeleteCallbackFunction_t pvDelCallback);\n\t#endif\n\n#endif\n\n/**\n * Calls the hook function associated with xTask. Passing xTask as NULL has\n * the effect of calling the Running tasks (the calling task) hook function.\n *\n * @param xTask  Handle of the task to call the hook for.\n * @param pvParameter  Parameter passed to the hook function for the task to interpret as it\n * wants.  The return value is the value returned by the task hook function\n * registered by the user.\n */\nBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;\n\n/**\n * Get the handle of idle task for the current CPU.\n *\n * xTaskGetIdleTaskHandle() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @return The handle of the idle task.  It is not valid to call\n * xTaskGetIdleTaskHandle() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandle( void );\n\n/**\n * Get the handle of idle task for the given CPU.\n *\n * xTaskGetIdleTaskHandleForCPU() is only available if\n * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n *\n * @param cpuid The CPU to get the handle for\n *\n * @return Idle task handle of a given cpu. It is not valid to call\n * xTaskGetIdleTaskHandleForCPU() before the scheduler has been started.\n */\nTaskHandle_t xTaskGetIdleTaskHandleForCPU( UBaseType_t cpuid );\n\n/**\n * Get the state of tasks in the system.\n *\n * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n * uxTaskGetSystemState() to be available.\n *\n * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n * the system.  TaskStatus_t structures contain, among other things, members\n * for the task handle, task name, task priority, task state, and total amount\n * of run time consumed by the task.  See the TaskStatus_t structure\n * definition in this file for the full member list.\n *\n * @note  This function is intended for debugging use only as its use results in\n * the scheduler remaining suspended for an extended period.\n *\n * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n * The array must contain at least one TaskStatus_t structure for each task\n * that is under the control of the RTOS.  The number of tasks under the control\n * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n *\n * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n * parameter.  The size is specified as the number of indexes in the array, or\n * the number of TaskStatus_t structures contained in the array, not by the\n * number of bytes in the array.\n *\n * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n * total run time (as defined by the run time stats clock, see\n * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.\n * pulTotalRunTime can be set to NULL to omit the total run time information.\n *\n * @return The number of TaskStatus_t structures that were populated by\n * uxTaskGetSystemState().  This should equal the number returned by the\n * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n * in the uxArraySize parameter was too small.\n *\n * Example usage:\n * @code{c}\n * // This example demonstrates how a human readable table of run time stats\n * // information is generated from raw data provided by uxTaskGetSystemState().\n * // The human readable table is written to pcWriteBuffer\n * void vTaskGetRunTimeStats( char *pcWriteBuffer )\n * {\n * TaskStatus_t *pxTaskStatusArray;\n * volatile UBaseType_t uxArraySize, x;\n * uint32_t ulTotalRunTime, ulStatsAsPercentage;\n *\n *  // Make sure the write buffer does not contain a string.\n *  *pcWriteBuffer = 0x00;\n *\n *  // Take a snapshot of the number of tasks in case it changes while this\n *  // function is executing.\n *  uxArraySize = uxTaskGetNumberOfTasks();\n *\n *  // Allocate a TaskStatus_t structure for each task.  An array could be\n *  // allocated statically at compile time.\n *  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n *\n *  if( pxTaskStatusArray != NULL )\n *  {\n *      // Generate raw status information about each task.\n *      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n *\n *      // For percentage calculations.\n *      ulTotalRunTime /= 100UL;\n *\n *      // Avoid divide by zero errors.\n *      if( ulTotalRunTime > 0 )\n *      {\n *          // For each populated position in the pxTaskStatusArray array,\n *          // format the raw data as human readable ASCII data\n *          for( x = 0; x < uxArraySize; x++ )\n *          {\n *              // What percentage of the total run time has the task used?\n *              // This will always be rounded down to the nearest integer.\n *              // ulTotalRunTimeDiv100 has already been divided by 100.\n *              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n *\n *              if( ulStatsAsPercentage > 0UL )\n *              {\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n *              }\n *              else\n *              {\n *                  // If the percentage is zero here then the task has\n *                  // consumed less than 1% of the total run time.\n *                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n *              }\n *\n *              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n *          }\n *      }\n *\n *      // The array is no longer needed, free the memory it consumes.\n *      vPortFree( pxTaskStatusArray );\n *  }\n * }\n * @endcode\n */\nUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime );\n\n/**\n * List all the current tasks.\n *\n * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n * both be defined as 1 for this function to be available.  See the\n * configuration section of the FreeRTOS.org website for more information.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Lists all the current tasks, along with their current state and stack\n * usage high water mark.\n *\n * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n * suspended ('S').\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskList() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays task\n * names, states and stack usage.\n *\n * vTaskList() has a dependency on the sprintf() C library function that might\n * bloat the code size, use a lot of stack, and provide different results on\n * different platforms.  An alternative, tiny, third party, and limited\n * functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState()\n * directly to get access to raw stats data, rather than indirectly through a\n * call to vTaskList().\n *\n * @param pcWriteBuffer A buffer into which the above mentioned details\n * will be written, in ASCII form.  This buffer is assumed to be large\n * enough to contain the generated report.  Approximately 40 bytes per\n * task should be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Get the state of running tasks as a string\n *\n * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n * must both be defined as 1 for this function to be available.  The application\n * must also then provide definitions for\n * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n * to configure a peripheral timer/counter and return the timers current count\n * value respectively.  The counter should be at least 10 times the frequency of\n * the tick count.\n *\n * @note This function will disable interrupts for its duration.  It is\n * not intended for normal application runtime use but as a debug aid.\n *\n * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n * accumulated execution time being stored for each task.  The resolution\n * of the accumulated time value depends on the frequency of the timer\n * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n * Calling vTaskGetRunTimeStats() writes the total execution time of each\n * task into a buffer, both as an absolute count value and as a percentage\n * of the total system execution time.\n *\n * @note This function is provided for convenience only, and is used by many of the\n * demo applications.  Do not consider it to be part of the scheduler.\n *\n * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n * uxTaskGetSystemState() output into a human readable table that displays the\n * amount of time each task has spent in the Running state in both absolute and\n * percentage terms.\n *\n * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n * that might bloat the code size, use a lot of stack, and provide different\n * results on different platforms.  An alternative, tiny, third party, and\n * limited functionality implementation of sprintf() is provided in many of the\n * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n * printf-stdarg.c does not provide a full snprintf() implementation!).\n *\n * It is recommended that production systems call uxTaskGetSystemState() directly\n * to get access to raw stats data, rather than indirectly through a call to\n * vTaskGetRunTimeStats().\n *\n * @param pcWriteBuffer A buffer into which the execution times will be\n * written, in ASCII form.  This buffer is assumed to be large enough to\n * contain the generated report.  Approximately 40 bytes per task should\n * be sufficient.\n *\n * \\ingroup TaskUtils\n */\nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\n/**\n * Send task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\tupdated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\n/**\n * Send task notification from an ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotify() that can be used from an interrupt service routine\n * (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param ulValue Data that can be sent with the notification.  How the data is\n * used depends on the value of the eAction parameter.\n *\n * @param eAction Specifies how the notification updates the task's notification\n * value, if at all.  Valid values for eAction are as follows:\n *\t- eSetBits:\n *\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()\n * \t  always returns pdPASS in this case.\n *\n *\t- eIncrement:\n *\t  The task's notification value is incremented.  ulValue is not used and\n *\t  xTaskNotify() always returns pdPASS in this case.\n *\n *\t- eSetValueWithOverwrite:\n *\t  The task's notification value is set to the value of ulValue, even if the\n *\t  task being notified had not yet processed the previous notification (the\n *\t  task already had a notification pending).  xTaskNotify() always returns\n *\t  pdPASS in this case.\n *\n *\t- eSetValueWithoutOverwrite:\n *\t  If the task being notified did not already have a notification pending then\n *\t  the task's notification value is set to ulValue and xTaskNotify() will\n *\t  return pdPASS.  If the task being notified already had a notification\n *\t  pending then no action is performed and pdFAIL is returned.\n *\n *\t- eNoAction:\n *\t  The task receives a notification without its notification value being\n *\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n *\t  this case.\n *\n * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n * be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * @return Dependent on the value of eAction.  See the description of the\n * eAction parameter.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Wait for task notification\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * A notification sent to a task will remain pending until it is cleared by the\n * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was\n * already in the Blocked state to wait for a notification when the notification\n * arrives then the task will automatically be removed from the Blocked state\n * (unblocked) and the notification cleared.\n *\n * A task can use xTaskNotifyWait() to [optionally] block to wait for a\n * notification to be pending, or ulTaskNotifyTake() to [optionally] block\n * to wait for its notification value to have a non-zero value.  The task does\n * not consume any CPU time while it is in the Blocked state.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n * will be cleared in the calling task's notification value before the task\n * checks to see if any notifications are pending, and optionally blocks if no\n * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n * the effect of resetting the task's notification value to 0.  Setting\n * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n *\n * @param ulBitsToClearOnExit If a notification is pending or received before\n * the calling task exits the xTaskNotifyWait() function then the task's\n * notification value (see the xTaskNotify() API function) is passed out using\n * the pulNotificationValue parameter.  Then any bits that are set in\n * ulBitsToClearOnExit will be cleared in the task's notification value (note\n * *pulNotificationValue is set before any bits are cleared).  Setting\n * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n * (if limits.h is not included) will have the effect of resetting the task's\n * notification value to 0 before the function exits.  Setting\n * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n * when the function exits (in which case the value passed out in\n * pulNotificationValue will match the task's notification value).\n *\n * @param pulNotificationValue Used to pass the task's notification value out\n * of the function.  Note the value passed out will not be effected by the\n * clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for a notification to be received, should a notification\n * not already be pending when xTaskNotifyWait() was called.  The task\n * will not consume any processing time while it is in the Blocked state.  This\n * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be\n * used to convert a time specified in milliseconds to a time specified in\n * ticks.\n *\n * @return If a notification was received (including notifications that were\n * already pending when xTaskNotifyWait was called) then pdPASS is\n * returned.  Otherwise pdFAIL is returned.\n *\n * \\ingroup TaskNotifications\n */\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );\n\n/**\n * Simplified macro for sending task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * xTaskNotifyGive() is a helper macro intended for use when task notifications\n * are used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,\n * the equivalent action that instead uses a task notification is\n * xTaskNotifyGive().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the\n * eAction parameter set to eIncrement - so pdPASS is always returned.\n *\n * \\ingroup TaskNotifications\n */\n#define xTaskNotifyGive( xTaskToNotify ) xTaskNotify( ( xTaskToNotify ), 0, eIncrement )\n\n/**\n * Simplified macro for sending task notification from ISR.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n * to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * A version of xTaskNotifyGive() that can be called from an interrupt service\n * routine (ISR).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * vTaskNotifyGiveFromISR() is intended for use when task notifications are\n * used as light weight and faster binary or counting semaphore equivalents.\n * Actual FreeRTOS semaphores are given from an ISR using the\n * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n * a task notification is vTaskNotifyGiveFromISR().\n *\n * When task notifications are being used as a binary or counting semaphore\n * equivalent then the task being notified should wait for the notification\n * using the ulTaskNotificationTake() API function rather than the\n * xTaskNotifyWait() API function.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n *\n * @param xTaskToNotify The handle of the task being notified.  The handle to a\n * task can be returned from the xTaskCreate() API function used to create the\n * task, and the handle of the currently running task can be obtained by calling\n * xTaskGetCurrentTaskHandle().\n *\n * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n * task to which the notification was sent to leave the Blocked state, and the\n * unblocked task has a priority higher than the currently running task.  If\n * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n * should be requested before the interrupt is exited.  How a context switch is\n * requested from an ISR is dependent on the port - see the documentation page\n * for the port in use.\n *\n * \\ingroup TaskNotifications\n */\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken );\n\n/**\n * Simplified macro for receiving task notification.\n *\n * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n * function to be available.\n *\n * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private\n * \"notification value\", which is a 32-bit unsigned integer (uint32_t).\n *\n * Events can be sent to a task using an intermediary object.  Examples of such\n * objects are queues, semaphores, mutexes and event groups.  Task notifications\n * are a method of sending an event directly to a task without the need for such\n * an intermediary object.\n *\n * A notification sent to a task can optionally perform an action, such as\n * update, overwrite or increment the task's notification value.  In that way\n * task notifications can be used to send data to a task, or be used as light\n * weight and fast binary or counting semaphores.\n *\n * ulTaskNotifyTake() is intended for use when a task notification is used as a\n * faster and lighter weight binary or counting semaphore alternative.  Actual\n * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the\n * equivalent action that instead uses a task notification is\n * ulTaskNotifyTake().\n *\n * When a task is using its notification value as a binary or counting semaphore\n * other tasks should send notifications to it using the xTaskNotifyGive()\n * macro, or xTaskNotify() function with the eAction parameter set to\n * eIncrement.\n *\n * ulTaskNotifyTake() can either clear the task's notification value to\n * zero on exit, in which case the notification value acts like a binary\n * semaphore, or decrement the task's notification value on exit, in which case\n * the notification value acts like a counting semaphore.\n *\n * A task can use ulTaskNotifyTake() to [optionally] block to wait for a\n * the task's notification value to be non-zero.  The task does not consume any\n * CPU time while it is in the Blocked state.\n *\n * Where as xTaskNotifyWait() will return when a notification is pending,\n * ulTaskNotifyTake() will return when the task's notification value is\n * not zero.\n *\n * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n *\n * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n * notification value is decremented when the function exits.  In this way the\n * notification value acts like a counting semaphore.  If xClearCountOnExit is\n * not pdFALSE then the task's notification value is cleared to zero when the\n * function exits.  In this way the notification value acts like a binary\n * semaphore.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait in\n * the Blocked state for the task's notification value to be greater than zero,\n * should the count not already be greater than zero when\n * ulTaskNotifyTake() was called.  The task will not consume any processing\n * time while it is in the Blocked state.  This is specified in kernel ticks,\n * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time\n * specified in milliseconds to a time specified in ticks.\n *\n * @return The task's notification count before it is either cleared to zero or\n * decremented (see the xClearCountOnExit parameter).\n *\n * \\ingroup TaskNotifications\n */\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n\n/*-----------------------------------------------------------\n * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES\n *----------------------------------------------------------*/\n/** @cond */\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Called from the real time kernel tick (either preemptive or cooperative),\n * this increments the tick count and checks if any tasks that are blocked\n * for a finite period required removing from a blocked list and placing on\n * a ready list.  If a non-zero value is returned then a context switch is\n * required because either:\n *   + A task was removed from a blocked list because its timeout had expired,\n *     or\n *   + Time slicing is in use and there is a task of equal priority to the\n *     currently running task.\n */\nBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes the calling task from the ready list and places it both\n * on the list of tasks waiting for a particular event, and the\n * list of delayed tasks.  The task will be removed from both lists\n * and replaced on the ready list should either the event occur (and\n * there be no higher priority tasks waiting on the same event) or\n * the delay period expires.\n *\n * The 'unordered' version replaces the event list item value with the\n * xItemValue value, and inserts the list item at the end of the list.\n *\n * The 'ordered' version uses the existing event list item value (which is the\n * owning tasks priority) to insert the list item into the event list is task\n * priority order.\n *\n * @param pxEventList The list containing tasks that are blocked waiting\n * for the event to occur.\n *\n * @param xItemValue The item value to use for the event list item when the\n * event list is not ordered by task priority.\n *\n * @param xTicksToWait The maximum amount of time that the task should wait\n * for the event to occur.  This is specified in kernel ticks,the constant\n * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time\n * period.\n */\nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * This function performs nearly the same function as vTaskPlaceOnEventList().\n * The difference being that this function does not permit tasks to block\n * indefinitely, whereas vTaskPlaceOnEventList() does.\n *\n */\nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN\n * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.\n *\n * Removes a task from both the specified event list and the list of blocked\n * tasks, and places it on a ready queue.\n *\n * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called\n * if either an event occurs to unblock a task, or the block timeout period\n * expires.\n *\n * xTaskRemoveFromEventList() is used when the event list is in task priority\n * order.  It removes the list item from the head of the event list as that will\n * have the highest priority owning task of all the tasks on the event list.\n * xTaskRemoveFromUnorderedEventList() is used when the event list is not\n * ordered and the event list items hold something other than the owning tasks\n * priority.  In this case the event list item value is updated to the value\n * passed in the xItemValue parameter.\n *\n * @return pdTRUE if the task being removed has a higher priority than the task\n * making the call, otherwise pdFALSE.\n */\nBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;\nBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;\n\n/*\n * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY\n * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS\n * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.\n *\n * Sets the pointer to the current TCB to the TCB of the highest priority task\n * that is ready to run.\n */\nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;\n\n/*\n * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY\n * THE EVENT BITS MODULE.\n */\nTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Return the handle of the calling task.\n */\nTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;\n\n\n\n/*\n * Return the handle of the task running on a certain CPU. Because of\n * the nature of SMP processing, there is no guarantee that this\n * value will still be valid on return and should only be used for\n * debugging purposes.\n */\nTaskHandle_t xTaskGetCurrentTaskHandleForCPU( BaseType_t cpuid );\n\n\n/*\n * Capture the current time status for future reference.\n */\nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;\n\n/*\n * Compare the time status now with that previously captured to see if the\n * timeout has expired.\n */\nBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;\n\n/*\n * Shortcut used by the queue implementation to prevent unnecessary call to\n * taskYIELD();\n */\nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Returns the scheduler state as taskSCHEDULER_RUNNING,\n * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.\n */\nBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;\n\n/*\n * Raises the priority of the mutex holder to that of the calling task should\n * the mutex holder have a priority less than the calling task.\n */\nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the priority of a task back to its proper priority in the case that it\n * inherited a higher priority while it was holding a semaphore.\n */\nBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;\n\n/*\n * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.\n */\nUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n\n/*\n * Get the current core affinity of a task\n */\nBaseType_t xTaskGetAffinity( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;\n\n/*\n * Set the uxTaskNumber of the task referenced by the xTask parameter to\n * uxHandle.\n */\nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;\n\n/*\n * Only available when configUSE_TICKLESS_IDLE is set to 1.\n * If tickless mode is being used, or a low power mode is implemented, then\n * the tick interrupt will not execute during idle periods.  When this is the\n * case, the tick count value maintained by the scheduler needs to be kept up\n * to date with the actual execution time by being skipped forward by a time\n * equal to the idle period.\n */\nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;\n\n/*\n * Only avilable when configUSE_TICKLESS_IDLE is set to 1.\n * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port\n * specific sleep function to determine if it is ok to proceed with the sleep,\n * and if it is ok to proceed, if it is ok to sleep indefinitely.\n *\n * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only\n * called with the scheduler suspended, not from within a critical section.  It\n * is therefore possible for an interrupt to request a context switch between\n * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being\n * entered.  eTaskConfirmSleepModeStatus() should be called from a short\n * critical section between the timer being stopped and the sleep mode being\n * entered to ensure it is ok to proceed into the sleep mode.\n */\neSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;\n\n/*\n * For internal use only.  Increment the mutex held count when a mutex is\n * taken and return the handle of the task that has taken the mutex.\n */\nvoid *pvTaskIncrementMutexHeldCount( void );\n\n/*\n * This function fills array with TaskSnapshot_t structures for every task in the system.\n * Used by core dump facility to get snapshots of all tasks in the system.\n * Only available when configENABLE_TASK_SNAPSHOT is set to 1.\n * @param pxTaskSnapshotArray Pointer to array of TaskSnapshot_t structures to store tasks snapshot data.\n * @param uxArraySize Size of tasks snapshots array.\n * @param pxTcbSz Pointer to store size of TCB.\n * @return Number of elements stored in array.\n */\nUBaseType_t uxTaskGetSnapshotAll( TaskSnapshot_t * const pxTaskSnapshotArray, const UBaseType_t uxArraySize, UBaseType_t * const pxTcbSz );\n\n/** @endcond */\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* INC_TASK_H */\n\n\n\n"}}}Content-Length: 307

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":767},"contentChanges":[{"range":{"start":{"line":270,"character":10},"end":{"line":270,"character":11}},"rangeLength":1,"text":""}]}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h"}}}
>>>
Content-Length: 205

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///home/manos/.arduino15/packages/esp32/hardware/esp32/1.0.6/tools/sdk/include/freertos/freertos/task.h","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":561,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":270,"character":10},"end":{"line":270,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":561,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":562,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":277,"character":12}}}
>>>
Content-Length: 671

{"id":562,"result":{"contents":{"kind":"markdown","value":"### function `xTaskCreate`  \n\n---\n `BaseType_t`  \nParameters:  \n- `TaskFunction_t pvTaskCode`\n- `const char *const pcName`\n- `const uint32_t usStackDepth`\n- `void *const pvParameters`\n- `UBaseType_t uxPriority`\n- `TaskHandle_t *const pvCreatedTask`\n\n---\n```cpp\nstatic inline BaseType_t\nxTaskCreate(TaskFunction_t pvTaskCode, const char *const pcName,\n            const uint32_t usStackDepth, void *const pvParameters,\n            UBaseType_t uxPriority, TaskHandle_t *const pvCreatedTask)\n```"},"range":{"start":{"line":312,"character":2},"end":{"line":312,"character":13}}},"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":767}}}Content-Length: 210

{"jsonrpc":"2.0","id":563,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":189,"character":11}}}
>>>
Content-Length: 40

{"id":563,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":564,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":189,"character":11}}}
>>>
Content-Length: 38

{"id":564,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":565,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":189,"character":0},"end":{"line":190,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":565,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":768},"contentChanges":[{"range":{"start":{"line":189,"character":0},"end":{"line":190,"character":0}},"rangeLength":19,"text":""}]}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":768}}}Content-Length: 210

{"jsonrpc":"2.0","id":566,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":11}}}
>>>
Content-Length: 40

{"id":566,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":567,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":12}}}
>>>
Content-Length: 38

{"id":567,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":769},"contentChanges":[{"range":{"start":{"line":190,"character":0},"end":{"line":191,"character":0}},"rangeLength":19,"text":""}]}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":769}}}Content-Length: 210

{"jsonrpc":"2.0","id":568,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":176,"character":39}}}
>>>
Content-Length: 40

{"id":568,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":569,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":145,"character":21}}}
>>>
Content-Length: 40

{"id":569,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":570,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":148,"character":49}}}
>>>
Content-Length: 40

{"id":570,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":571,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":250,"character":4}}}
>>>
Content-Length: 2434

{"id":571,"result":[{"range":{"start":{"line":55,"character":2},"end":{"line":55,"character":8}},"kind":1},{"range":{"start":{"line":58,"character":4},"end":{"line":58,"character":10}},"kind":1},{"range":{"start":{"line":74,"character":4},"end":{"line":74,"character":10}},"kind":1},{"range":{"start":{"line":83,"character":10},"end":{"line":83,"character":16}},"kind":1},{"range":{"start":{"line":86,"character":2},"end":{"line":86,"character":8}},"kind":1},{"range":{"start":{"line":91,"character":4},"end":{"line":91,"character":10}},"kind":1},{"range":{"start":{"line":96,"character":2},"end":{"line":96,"character":8}},"kind":1},{"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":8}},"kind":1},{"range":{"start":{"line":108,"character":2},"end":{"line":108,"character":8}},"kind":1},{"range":{"start":{"line":109,"character":2},"end":{"line":109,"character":8}},"kind":1},{"range":{"start":{"line":110,"character":2},"end":{"line":110,"character":8}},"kind":1},{"range":{"start":{"line":111,"character":2},"end":{"line":111,"character":8}},"kind":1},{"range":{"start":{"line":112,"character":2},"end":{"line":112,"character":8}},"kind":1},{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":8}},"kind":1},{"range":{"start":{"line":114,"character":2},"end":{"line":114,"character":8}},"kind":1},{"range":{"start":{"line":115,"character":2},"end":{"line":115,"character":8}},"kind":1},{"range":{"start":{"line":116,"character":2},"end":{"line":116,"character":8}},"kind":1},{"range":{"start":{"line":117,"character":2},"end":{"line":117,"character":8}},"kind":1},{"range":{"start":{"line":118,"character":2},"end":{"line":118,"character":8}},"kind":1},{"range":{"start":{"line":119,"character":2},"end":{"line":119,"character":8}},"kind":1},{"range":{"start":{"line":127,"character":2},"end":{"line":127,"character":8}},"kind":1},{"range":{"start":{"line":128,"character":2},"end":{"line":128,"character":8}},"kind":1},{"range":{"start":{"line":129,"character":2},"end":{"line":129,"character":8}},"kind":1},{"range":{"start":{"line":216,"character":4},"end":{"line":216,"character":10}},"kind":1},{"range":{"start":{"line":249,"character":4},"end":{"line":249,"character":10}},"kind":1},{"range":{"start":{"line":250,"character":4},"end":{"line":250,"character":10}},"kind":1},{"range":{"start":{"line":256,"character":2},"end":{"line":256,"character":8}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":572,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":250,"character":4},"end":{"line":250,"character":4}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":572,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":770},"contentChanges":[{"range":{"start":{"line":250,"character":4},"end":{"line":250,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 221

{"jsonrpc":"2.0","id":573,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":249,"character":7}}}
>>>
Content-Length: 2344

{"id":573,"result":[{"range":{"start":{"line":55,"character":2},"end":{"line":55,"character":8}},"kind":1},{"range":{"start":{"line":58,"character":4},"end":{"line":58,"character":10}},"kind":1},{"range":{"start":{"line":74,"character":4},"end":{"line":74,"character":10}},"kind":1},{"range":{"start":{"line":83,"character":10},"end":{"line":83,"character":16}},"kind":1},{"range":{"start":{"line":86,"character":2},"end":{"line":86,"character":8}},"kind":1},{"range":{"start":{"line":91,"character":4},"end":{"line":91,"character":10}},"kind":1},{"range":{"start":{"line":96,"character":2},"end":{"line":96,"character":8}},"kind":1},{"range":{"start":{"line":107,"character":2},"end":{"line":107,"character":8}},"kind":1},{"range":{"start":{"line":108,"character":2},"end":{"line":108,"character":8}},"kind":1},{"range":{"start":{"line":109,"character":2},"end":{"line":109,"character":8}},"kind":1},{"range":{"start":{"line":110,"character":2},"end":{"line":110,"character":8}},"kind":1},{"range":{"start":{"line":111,"character":2},"end":{"line":111,"character":8}},"kind":1},{"range":{"start":{"line":112,"character":2},"end":{"line":112,"character":8}},"kind":1},{"range":{"start":{"line":113,"character":2},"end":{"line":113,"character":8}},"kind":1},{"range":{"start":{"line":114,"character":2},"end":{"line":114,"character":8}},"kind":1},{"range":{"start":{"line":115,"character":2},"end":{"line":115,"character":8}},"kind":1},{"range":{"start":{"line":116,"character":2},"end":{"line":116,"character":8}},"kind":1},{"range":{"start":{"line":117,"character":2},"end":{"line":117,"character":8}},"kind":1},{"range":{"start":{"line":118,"character":2},"end":{"line":118,"character":8}},"kind":1},{"range":{"start":{"line":119,"character":2},"end":{"line":119,"character":8}},"kind":1},{"range":{"start":{"line":127,"character":2},"end":{"line":127,"character":8}},"kind":1},{"range":{"start":{"line":128,"character":2},"end":{"line":128,"character":8}},"kind":1},{"range":{"start":{"line":129,"character":2},"end":{"line":129,"character":8}},"kind":1},{"range":{"start":{"line":216,"character":4},"end":{"line":216,"character":10}},"kind":1},{"range":{"start":{"line":249,"character":4},"end":{"line":249,"character":10}},"kind":1},{"range":{"start":{"line":256,"character":2},"end":{"line":256,"character":8}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":574,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":249,"character":7},"end":{"line":249,"character":7}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":574,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":770}}}Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":771},"contentChanges":[{"range":{"start":{"line":249,"character":4},"end":{"line":249,"character":4}},"rangeLength":0,"text":"// "}]}}Content-Length: 285

{"jsonrpc":"2.0","id":575,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":249,"character":10},"end":{"line":249,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":575,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":771}}}Content-Length: 209

{"jsonrpc":"2.0","id":576,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":237,"character":8}}}
>>>
Content-Length: 1892

{"id":576,"result":{"contents":{"kind":"markdown","value":"### function `vTaskDelay`  \n\n---\n `void`  \nParameters:  \n- `const TickType_t xTicksToDelay`\n\nDelay a task for a given number of ticks.  \nThe actual time that the task remains blocked depends on the tick rate.  \nThe constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.  \nINCLUDE_vTaskDelay must be defined as 1 for this function to be available.  \nSee the configuration section for more information.  \nvTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.  \n@param xTicksToDelay The amount of time, in tick periods, that the calling task should block.  \nExample usage:  \n@code{c} void vTaskFunction( void * pvParameters ) { // Block for 500ms.  \nconst TickType_t xDelay = 500 / portTICK_PERIOD_MS;  \nfor( ;; ) { // Simply toggle the LED every 500ms, blocking between each toggle.  \nvToggleLED();  \nvTaskDelay( xDelay );  \n} }  \n@endcode  \n\\\\ingroup TaskCtrl  \n\n---\n```cpp\nvoid vTaskDelay(const TickType_t xTicksToDelay)\n```"},"range":{"start":{"line":272,"character":4},"end":{"line":272,"character":14}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":577,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":241,"character":9}}}
>>>
Content-Length: 40

{"id":577,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":578,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":240,"character":0},"end":{"line":242,"character":44}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":578,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 308

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":772},"contentChanges":[{"range":{"start":{"line":240,"character":0},"end":{"line":242,"character":44}},"rangeLength":103,"text":""}]}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":772}}}Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":773},"contentChanges":[{"range":{"start":{"line":239,"character":3},"end":{"line":240,"character":0}},"rangeLength":1,"text":""}]}}Content-Length: 283

{"jsonrpc":"2.0","id":579,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":239,"character":3},"end":{"line":239,"character":3}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":579,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":773}}}
>>>
Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":9,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":9,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}
<<<
Content-Length: 305

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":774},"contentChanges":[{"range":{"start":{"line":238,"character":0},"end":{"line":238,"character":2}},"rangeLength":2,"text":""}]}}
>>>
Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 306

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":775},"contentChanges":[{"range":{"start":{"line":237,"character":39},"end":{"line":238,"character":0}},"rangeLength":1,"text":""}]}}Content-Length: 285

{"jsonrpc":"2.0","id":580,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":237,"character":39},"end":{"line":237,"character":39}},"context":{"diagnostics":[]}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":775}}}Content-Length: 178

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino","version":775}}}Content-Length: 209

{"jsonrpc":"2.0","id":581,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":245,"character":2}}}Content-Length: 64

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":581}}
>>>
Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 112

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":10,"jsonrpc":"2.0"}Content-Length: 38

{"id":580,"result":[],"jsonrpc":"2.0"}Content-Length: 40

{"id":581,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 39

{"jsonrpc":"2.0","id":10,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":582,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":163,"character":13}}}
>>>
Content-Length: 321

{"id":582,"result":{"contents":{"kind":"markdown","value":"### field `(anonymous)`  \n\n---\nType: `union sensors_event_t::(anonymous)`  \n\n---\n```cpp\n// In (anonymous struct)\npublic: sensors_event_t::(anonymous)\n```"},"range":{"start":{"line":198,"character":11},"end":{"line":198,"character":23}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":583,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":140,"character":80}}}
>>>
Content-Length: 40

{"id":583,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":584,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":204,"character":20}}}
>>>
Content-Length: 277

{"id":584,"result":{"contents":{"kind":"markdown","value":"### function `blinking`  \n\n---\n `void`  \nParameters:  \n- `int pin`\n\n---\n```cpp\nvoid blinking(int pin)\n```"},"range":{"start":{"line":239,"character":13},"end":{"line":239,"character":20}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":585,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":197,"character":11}}}
>>>
Content-Length: 322

{"id":585,"result":{"contents":{"kind":"markdown","value":"### function `digitalWrite`  \n\n---\n `void`  \nParameters:  \n- `uint8_t pin`\n- `uint8_t val`\n\n---\n```cpp\nvoid digitalWrite(uint8_t pin, uint8_t val)\n```"},"range":{"start":{"line":232,"character":4},"end":{"line":232,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":586,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":196,"character":29}}}
>>>
Content-Length: 40

{"id":586,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":587,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":196,"character":29},"end":{"line":196,"character":29}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":587,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":588,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":204,"character":5}}}
>>>
Content-Length: 276

{"id":588,"result":{"contents":{"kind":"markdown","value":"### function `blinking`  \n\n---\n `void`  \nParameters:  \n- `int pin`\n\n---\n```cpp\nvoid blinking(int pin)\n```"},"range":{"start":{"line":239,"character":4},"end":{"line":239,"character":12}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":589,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":198,"character":6}}}
>>>
Content-Length: 40

{"id":589,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":590,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":199,"character":9}}}
>>>
Content-Length: 322

{"id":590,"result":{"contents":{"kind":"markdown","value":"### function `digitalWrite`  \n\n---\n `void`  \nParameters:  \n- `uint8_t pin`\n- `uint8_t val`\n\n---\n```cpp\nvoid digitalWrite(uint8_t pin, uint8_t val)\n```"},"range":{"start":{"line":234,"character":4},"end":{"line":234,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":591,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":199,"character":22}}}
>>>
Content-Length: 313

{"id":591,"result":{"contents":{"kind":"markdown","value":"### variable `lightPin`  \n\n---\nType: `const int`  \nValue = `12`  \nPassed as pin (converted to uint8_t)  \n\n---\n```cpp\nconst int lightPin = 12\n```"},"range":{"start":{"line":234,"character":17},"end":{"line":234,"character":25}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":592,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":199,"character":23}}}
>>>
Content-Length: 313

{"id":592,"result":{"contents":{"kind":"markdown","value":"### variable `lightPin`  \n\n---\nType: `const int`  \nValue = `12`  \nPassed as pin (converted to uint8_t)  \n\n---\n```cpp\nconst int lightPin = 12\n```"},"range":{"start":{"line":234,"character":17},"end":{"line":234,"character":25}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":593,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":197,"character":26}}}
>>>
Content-Length: 215

{"id":593,"result":{"contents":{"kind":"markdown","value":"### macro `HIGH`  \n\n---\n```cpp\n#define HIGH 0x1\n```"},"range":{"start":{"line":232,"character":26},"end":{"line":232,"character":30}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":594,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":197,"character":8}}}
>>>
Content-Length: 322

{"id":594,"result":{"contents":{"kind":"markdown","value":"### function `digitalWrite`  \n\n---\n `void`  \nParameters:  \n- `uint8_t pin`\n- `uint8_t val`\n\n---\n```cpp\nvoid digitalWrite(uint8_t pin, uint8_t val)\n```"},"range":{"start":{"line":232,"character":4},"end":{"line":232,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":595,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":199,"character":3}}}
>>>
Content-Length: 40

{"id":595,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":596,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":196,"character":18}}}
>>>
Content-Length: 272

{"id":596,"result":{"contents":{"kind":"markdown","value":"### field `lightSensor`  \n\n---\nType: `int`  \n\n---\n```cpp\n// In masterMessage\npublic: int lightSensor\n```"},"range":{"start":{"line":231,"character":17},"end":{"line":231,"character":28}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":597,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":229,"character":17}}}
>>>
Content-Length: 40

{"id":597,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":598,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":17}}}
>>>
Content-Length: 38

{"id":598,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":599,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":187,"character":15},"end":{"line":190,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":599,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":600,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":187,"character":15},"end":{"line":187,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":600,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":601,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":188,"character":9}}}
>>>
Content-Length: 397

{"id":601,"result":[{"range":{"start":{"line":188,"character":4},"end":{"line":188,"character":14}},"kind":1},{"range":{"start":{"line":190,"character":4},"end":{"line":190,"character":14}},"kind":1},{"range":{"start":{"line":237,"character":4},"end":{"line":237,"character":14}},"kind":1},{"range":{"start":{"line":244,"character":4},"end":{"line":244,"character":14}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":602,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":188,"character":9},"end":{"line":188,"character":9}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":602,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":603,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":187,"character":4}}}
>>>
Content-Length: 322

{"id":603,"result":{"contents":{"kind":"markdown","value":"### function `digitalWrite`  \n\n---\n `void`  \nParameters:  \n- `uint8_t pin`\n- `uint8_t val`\n\n---\n```cpp\nvoid digitalWrite(uint8_t pin, uint8_t val)\n```"},"range":{"start":{"line":222,"character":4},"end":{"line":222,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":604,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":187,"character":8}}}
>>>
Content-Length: 322

{"id":604,"result":{"contents":{"kind":"markdown","value":"### function `digitalWrite`  \n\n---\n `void`  \nParameters:  \n- `uint8_t pin`\n- `uint8_t val`\n\n---\n```cpp\nvoid digitalWrite(uint8_t pin, uint8_t val)\n```"},"range":{"start":{"line":222,"character":4},"end":{"line":222,"character":16}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":605,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":187,"character":18}}}
>>>
Content-Length: 283

{"id":605,"result":{"contents":{"kind":"markdown","value":"### param `pin`  \n\n---\nType: `int`  \nPassed as pin (converted to uint8_t)  \n\n---\n```cpp\n// In blinking\nint pin\n```"},"range":{"start":{"line":222,"character":17},"end":{"line":222,"character":20}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":606,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":188,"character":18}}}
>>>
Content-Length: 223

{"id":606,"result":{"contents":{"kind":"markdown","value":"### `expression`  \n\n---\nType: `unsigned int`  \nValue = `200`"},"range":{"start":{"line":223,"character":18},"end":{"line":223,"character":19}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":607,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":188,"character":19}}}
>>>
Content-Length: 279

{"id":607,"result":{"contents":{"kind":"markdown","value":"### macro `portTICK_PERIOD_MS`  \n\n---\n```cpp\n#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)\n```"},"range":{"start":{"line":223,"character":19},"end":{"line":223,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":608,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":15}}}
>>>
Content-Length: 40

{"id":608,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":609,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":18}}}
>>>
Content-Length: 223

{"id":609,"result":{"contents":{"kind":"markdown","value":"### `expression`  \n\n---\nType: `unsigned int`  \nValue = `300`"},"range":{"start":{"line":225,"character":18},"end":{"line":225,"character":19}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":610,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":190,"character":19}}}
>>>
Content-Length: 279

{"id":610,"result":{"contents":{"kind":"markdown","value":"### macro `portTICK_PERIOD_MS`  \n\n---\n```cpp\n#define portTICK_PERIOD_MS ((TickType_t)1000 / configTICK_RATE_HZ)\n```"},"range":{"start":{"line":225,"character":19},"end":{"line":225,"character":37}}},"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":611,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":186,"character":21}}}
>>>
Content-Length: 318

{"id":611,"result":{"contents":{"kind":"markdown","value":"### variable `k`  \n\n---\nType: `int`  \nValue = `0`  \nBlinking the alarm 5 times (about 1 second procedure)  \n\n---\n```cpp\n// In blinking\nint k = 0\n```"},"range":{"start":{"line":221,"character":21},"end":{"line":221,"character":22}}},"jsonrpc":"2.0"}
<<<
Content-Length: 284

{"jsonrpc":"2.0","id":612,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":258,"character":26},"end":{"line":259,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":612,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 222

{"jsonrpc":"2.0","id":613,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":263,"character":26}}}
>>>
Content-Length: 38

{"id":613,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 285

{"jsonrpc":"2.0","id":614,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":263,"character":26},"end":{"line":263,"character":26}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":614,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 210

{"jsonrpc":"2.0","id":615,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":264,"character":25}}}
>>>
Content-Length: 40

{"id":615,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 209

{"jsonrpc":"2.0","id":616,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"position":{"line":15,"character":14}}}
>>>
Content-Length: 300

{"id":616,"result":{"contents":{"kind":"markdown","value":"### variable `accPitch`  \n\n---\nType: `float`  \nunits degrees (roll and pitch noisy, yaw not possible)  \n\n---\n```cpp\nfloat accPitch\n```"},"range":{"start":{"line":17,"character":13},"end":{"line":17,"character":14}}},"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":617,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":1}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":617,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 283

{"jsonrpc":"2.0","id":618,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/manos/Documents/IOT_SmartHelmet_project/Esp_Master/Esp_Master.ino"},"range":{"start":{"line":241,"character":0},"end":{"line":249,"character":1}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":618,"result":[],"jsonrpc":"2.0"}